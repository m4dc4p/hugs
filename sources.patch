diff --git a/ac_macros/ice_prog_cpp_traditional.m4 b/ac_macros/ice_prog_cpp_traditional.m4
index e5df3d1..e0a538f 100644
--- a/ac_macros/ice_prog_cpp_traditional.m4
+++ b/ac_macros/ice_prog_cpp_traditional.m4
@@ -26,8 +26,7 @@ AC_CACHE_CHECK([for a traditional C preprocessor],
 [
 cat > conftest.c << EOF
 #if 1
-{-# INLINE f'
- #-}
+{-# INLINE f' #-}
 f' x = x+1
 #endif
 EOF
@@ -35,13 +34,12 @@ ice_cv_traditional_cpp=
 ice_save_cpp="$CPP"
 ice_save_cppflags="$CPPFLAGS"
 for ice_cpp in "$CPP" "$CC -E" "/lib/cpp"; do
-for ice_cppflags in '' ' -traditional-cpp' ' -traditional' ' -Xs'; do
+for ice_cppflags in '' ' -traditional-cpp' ' -traditional' ' -Xs' ; do
 CPP="$ice_cpp"
 CPPFLAGS="$ice_cppflags"
 AC_PREPROC_IFELSE([AC_LANG_PROGRAM([[
 #if 1
-{-# INLINE f'
- #-}
+{-# INLINE f' #-}
 f' x = x+1
 #endif
 ]])], [ice_cv_traditional_cpp="${CPP}${CPPFLAGS}"])
diff --git a/configure b/configure
index ac21d0c..61defe8 100755
--- a/configure
+++ b/configure
@@ -16313,7 +16313,7 @@ echo "${ECHO_T}$ac_cv_dll_flags" >&6; }
 
 
 cat >>confdefs.h <<_ACEOF
-#define MKDLL_CMD "${CC-cc} $CFLAGS $CPPFLAGS $LDFLAGS $ac_cv_dll_flags"
+#define MKDLL_CMD "${CC-cc} $CFLAGS $CPPFLAGS -fgnu89-inline $LDFLAGS $ac_cv_dll_flags"
 _ACEOF
 
 if test "$ac_cv_leading_underscore" = "yes"; then
@@ -16568,7 +16568,7 @@ elif test "x$host" = "xdos"; then
 else
     BAT=
     hugsdir_deflt='${libdir}/hugs'
-    HUGSPATH=".:{Home}/lib/hugs/packages/*:/usr/local/lib/hugs/packages/*:{Hugs}/packages/*"
+    HUGSPATH="{Hugs}/packages/*"
     HUGSSUFFIXES=".hs:.lhs"
     MkInstall="src/MkInstal.in"
 fi
diff --git a/debian/control b/debian/control
deleted file mode 100644
index aefda96..0000000
--- a/debian/control
+++ /dev/null
@@ -1,336 +0,0 @@
-Source: hugs98
-Section: interpreters
-Priority: optional
-Maintainer: Isaac Jones <ijones@debian.org>
-Standards-Version: 3.6.1
-Build-Depends: debhelper (>= 4), autoconf, autotools-dev, bison,
- libncurses5-dev, libreadline5-dev,
- libxt-dev, xlibmesa-gl-dev, xlibmesa-glu-dev, freeglut3-dev, libopenal-dev
-
-Package: hugs
-Architecture: any
-Depends: libhugs-base, libhugs-haskell98, ${shlibs:Depends}
-Conflicts: hugs98
-Provides: hugs98
-Replaces: hugs98
-Suggests: haskell-mode, haskell-doc, hugs-cabal, cpphs
-Section: interpreters
-Priority: optional
-Description: A Haskell 98 interpreter
- Hugs is an interpreter for the non-strict, purely functional programming
- language Haskell.  This version of Hugs, Hugs 98, supports nearly all of
- the Haskell 98 specification, as well as a number of extensions.
- .
- The Haskell language is described by documents in the haskell-doc
- package.  Other libraries are documented in the ghc6-doc package.
-
-Package: libhugs-alut-bundled
-Architecture: any
-Depends: hugs, libhugs-base, libhugs-opengl, libhugs-openal, ${shlibs:Depends}
-Section: devel
-Priority: optional
-Provides: libhugs-alut
-Conflicts: libhugs-alut
-Description: A binding for the OpenAL Utility Toolkit
- A Haskell binding for the OpenAL Utility Toolkit, which makes
- managing of OpenAL contexts, loading sounds in various formats
- and creating waveforms very easy. For more information about the
- C library on which this binding is based, please see:
- <http://www.openal.org/openal_webstf/specs/alut.html>.
- .
- This is the version bundled with the interpreter.
-
-Package: libhugs-cabal-bundled
-Architecture: any
-Depends: hugs, libhugs-base, ${shlibs:Depends}
-Section: devel
-Priority: optional
-Provides: libhugs-cabal
-Conflicts: libhugs-cabal
-Description: A framework for packaging Haskell software
- The Haskell Common Architecture for Building Applications and
- Libraries: a framework defining a common interface for authors to more
- easily build their Haskell applications in a portable way.
- .
- The Haskell Cabal is meant to be a part of a larger infrastructure
- for distributing, organizing, and cataloging Haskell libraries
- and tools.
- .
- This is the version bundled with the interpreter.
-
-Package: libhugs-glut-bundled
-Architecture: any
-Depends: hugs, libhugs-base, libhugs-opengl, ${shlibs:Depends}
-Section: devel
-Priority: optional
-Provides: libhugs-glut
-Conflicts: libhugs-glut
-Description: A binding for the OpenGL Utility Toolkit
- A Haskell binding for the OpenGL Utility Toolkit, a window
- system independent toolkit for writing OpenGL programs. For more
- information about the C library on which this binding is based,
- please see: <http://www.opengl.org/resources/libraries/glut/>.
- .
- This is the version bundled with the interpreter.
-
-Package: libhugs-hgl-bundled
-Architecture: any
-Depends: hugs, libhugs-base, libhugs-x11, ${shlibs:Depends}
-Section: devel
-Priority: optional
-Provides: libhugs-hgl
-Conflicts: libhugs-hgl
-Description: A simple graphics library based on X11 or Win32
- A simple graphics library, designed to give the programmer access
- to most interesting parts of the Win32 Graphics Device Interface
- and X11 library without exposing the programmer to the pain and
- anguish usually associated with using these interfaces.
- .
- The library also includes a module Graphics.SOE providing the
- interface used in "The Haskell School of Expression", by Paul
- Hudak, cf <http://www.haskell.org/soe/>.
- .
- This is the version bundled with the interpreter.
-
-Package: libhugs-hunit-bundled
-Architecture: any
-Depends: hugs, libhugs-base, ${shlibs:Depends}
-Section: devel
-Priority: optional
-Provides: libhugs-hunit
-Conflicts: libhugs-hunit
-Description: A unit testing framework for Haskell
- HUnit is a unit testing framework for Haskell, inspired by the
- JUnit tool for Java, see: <http://www.junit.org>.
- .
- This is the version bundled with the interpreter.
-
-Package: libhugs-haxml-bundled
-Architecture: any
-Depends: hugs, libhugs-base, libhugs-haskell98, ${shlibs:Depends}
-Section: devel
-Priority: optional
-Provides: libhugs-haxml
-Conflicts: libhugs-haxml
-Description: Utilities for manipulating XML documents
- Haskell utilities for parsing, filtering, transforming and
- generating XML documents.
- .
- This is the version bundled with the interpreter.
-
-Package: libhugs-openal-bundled
-Architecture: any
-Depends: hugs, libhugs-base, libhugs-opengl, ${shlibs:Depends}
-Section: devel
-Priority: optional
-Provides: libhugs-openal
-Conflicts: libhugs-openal
-Description: A binding to the OpenAL cross-platform 3D audio API
- A Haskell binding for the OpenAL cross-platform 3D audio API,
- appropriate for use with gaming applications and many other
- types of audio applications.  For more information about OpenAL,
- please see: <http://www.openal.org/>.
- .
- This is the version bundled with the interpreter.
-
-Package: libhugs-opengl-bundled
-Architecture: any
-Depends: hugs, libhugs-base, ${shlibs:Depends}
-Section: devel
-Priority: optional
-Provides: libhugs-opengl
-Conflicts: libhugs-opengl
-Description: A binding for the OpenGL graphics system
- A Haskell binding for the OpenGL graphics system (GL, version
- 1.5) and its accompanying utility library (GLU, version 1.3).
- OpenGL is the industry's most widely used and supported 2D and 3D
- graphics application programming interface (API), incorporating
- a broad set of rendering, texture mapping, special effects, and
- other powerful visualization functions.  For more information
- about OpenGL, please see: <http://www.opengl.org/>.
- .
- This is the version bundled with the interpreter.
-
-Package: libhugs-quickcheck-bundled
-Architecture: any
-Depends: hugs, libhugs-base, ${shlibs:Depends}
-Section: devel
-Priority: optional
-Provides: libhugs-quickcheck
-Conflicts: libhugs-quickcheck
-Description: Automatic testing of Haskell programs
- A library for testing Haskell programs automatically.
- The programmer provides a specification of the program, in
- the form of properties which functions should satisfy, and
- QuickCheck then tests that the properties hold in a large number
- of randomly generated cases.  Specifications are expressed in
- Haskell, using combinators defined in the QuickCheck library.
- QuickCheck provides combinators to define properties, observe
- the distribution of test data, and define test
- data generators.
- .
- This is the version bundled with the interpreter.
-
-Package: libhugs-x11-bundled
-Architecture: any
-Depends: hugs, libhugs-base, ${shlibs:Depends}
-Section: devel
-Priority: optional
-Provides: libhugs-x11
-Conflicts: libhugs-x11
-Description: A binding to the X11 graphics library
- A Haskell binding to the X11 graphics library.
- .
- The binding is a direct translation of the C binding; for
- documentation of these calls, refer to "The Xlib Programming
- Manual", available online at <http://tronche.com/gui/x/xlib/>.
- .
- This is the version bundled with the interpreter.
-
-Package: libhugs-base-bundled
-Architecture: any
-Depends: hugs, ${shlibs:Depends}
-Section: devel
-Priority: optional
-Provides: libhugs-base
-Conflicts: libhugs-base
-Description: Basic libraries
- This package contains the Prelude and its support libraries,
- and a large collection of useful libraries ranging from data
- structures to parsing combinators and debugging utilities.
- .
- This is the version bundled with the interpreter.
-
-Package: libhugs-fgl-bundled
-Architecture: any
-Depends: hugs, libhugs-base, libhugs-mtl, ${shlibs:Depends}
-Section: devel
-Priority: optional
-Provides: libhugs-fgl
-Conflicts: libhugs-fgl
-Description: Martin Erwig's Functional Graph Library
- .
- This is the version bundled with the interpreter.
-
-Package: libhugs-haskell-src-bundled
-Architecture: any
-Depends: hugs, libhugs-base, libhugs-haskell98, ${shlibs:Depends}
-Section: devel
-Priority: optional
-Provides: libhugs-haskell-src
-Conflicts: libhugs-haskell-src
-Description: Manipulating Haskell source code
- Facilities for manipulating Haskell source code:
- an abstract syntax, lexer, parser and pretty-printer.
- .
- This is the version bundled with the interpreter.
-
-Package: libhugs-haskell98-bundled
-Architecture: any
-Depends: hugs, libhugs-base, ${shlibs:Depends}
-Section: devel
-Priority: optional
-Provides: libhugs-haskell98
-Conflicts: libhugs-haskell98
-Description: Compatibility with Haskell 98
- This package provides compatibility with the modules of Haskell
- 98 and the FFI addendum, by means of wrappers around modules from
- the base package (which in many cases have additional features).
- However Prelude, Numeric and Foreign are provided directly by
- the base package.
- .
- This is the version bundled with the interpreter.
-
-Package: libhugs-mtl-bundled
-Architecture: any
-Depends: hugs, libhugs-base, ${shlibs:Depends}
-Section: devel
-Priority: optional
-Provides: libhugs-mtl
-Conflicts: libhugs-mtl
-Description: Monad transformer library
- A monad transformer library, inspired by the paper "Functional
- Programming with Overloading and Higher-Order Polymorphism",
- by Mark P Jones (<http://www.cse.ogi.edu/~mpj/>), Advanced School
- of Functional Programming, 1995.
- .
- This is the version bundled with the interpreter.
-
-Package: libhugs-network-bundled
-Architecture: any
-Depends: hugs, libhugs-base, libhugs-parsec, ${shlibs:Depends}
-Section: devel
-Priority: optional
-Provides: libhugs-network
-Conflicts: libhugs-network
-Description: Networking-related facilities
- .
- This is the version bundled with the interpreter.
-
-Package: libhugs-parsec-bundled
-Architecture: any
-Depends: hugs, libhugs-base, ${shlibs:Depends}
-Section: devel
-Priority: optional
-Provides: libhugs-parsec
-Conflicts: libhugs-parsec
-Description: Monadic parser combinators
- Parsec is designed from scratch as an industrial-strength parser
- library.  It is simple, safe, well documented (on the package
- homepage), has extensive libraries and good error messages,
- and is also fast.
- .
- This is the version bundled with the interpreter.
-
-Package: libhugs-stm-bundled
-Architecture: any
-Depends: hugs, libhugs-base, ${shlibs:Depends}
-Section: devel
-Priority: optional
-Provides: libhugs-stm
-Conflicts: libhugs-stm
-Description: Software Transactional Memory
- A modular composable concurrency abstraction.
- .
- This is the version bundled with the interpreter.
-
-Package: libhugs-time-bundled
-Architecture: any
-Depends: hugs, libhugs-base, ${shlibs:Depends}
-Section: devel
-Priority: optional
-Provides: libhugs-time
-Conflicts: libhugs-time
-Description: time library
- .
- This is the version bundled with the interpreter.
-
-Package: libhugs-unix-bundled
-Architecture: any
-Depends: hugs, libhugs-base, ${shlibs:Depends}
-Section: devel
-Priority: optional
-Provides: libhugs-unix
-Conflicts: libhugs-unix
-Description: POSIX functionality
- This package gives you access to the set of operating system
- services standardised by POSIX 1003.1b (or the IEEE Portable
- Operating System Interface for Computing Environments -
- IEEE Std. 1003.1).
- .
- The package is not supported under Windows (except under Cygwin).
- .
- This is the version bundled with the interpreter.
-
-Package: libhugs-xhtml-bundled
-Architecture: any
-Depends: hugs, libhugs-haskell98, libhugs-base, ${shlibs:Depends}
-Section: devel
-Priority: optional
-Provides: libhugs-xhtml
-Conflicts: libhugs-xhtml
-Description: A Haskell XHTML combinator library
- This is a version of the standard Text.Html
- modified to produce XHTML 1.0.
- .
- This is the version bundled with the interpreter.
diff --git a/debian/hugs.copyright b/debian/hugs.copyright
deleted file mode 100644
index 93eded5..0000000
--- a/debian/hugs.copyright
+++ /dev/null
@@ -1,32 +0,0 @@
-The Hugs 98 system is Copyright (c) Mark P Jones, Alastair Reid, the
-Yale Haskell Group, and the OGI School of Science & Engineering at
-OHSU, 1994-2003, All rights reserved, and is distributed as free
-software under the following license.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions
-are met:
-
-- Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
-
-- Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in the
-documentation and/or other materials provided with the distribution.
-
-- Neither name of the copyright holders nor the names of its
-contributors may be used to endorse or promote products derived from
-this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND THE CONTRIBUTORS
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-HOLDERS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
-OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
-TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
-USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
diff --git a/debian/libhugs-alut-bundled.README.Debian b/debian/libhugs-alut-bundled.README.Debian
deleted file mode 100644
index 9d98df7..0000000
--- a/debian/libhugs-alut-bundled.README.Debian
+++ /dev/null
@@ -1,3 +0,0 @@
-Version of the ALUT library package bundled with Hugs.
-
-Documentation for this package can be found in the ghc6-doc package.
diff --git a/debian/libhugs-alut-bundled.copyright b/debian/libhugs-alut-bundled.copyright
deleted file mode 100644
index fabfe5a..0000000
--- a/debian/libhugs-alut-bundled.copyright
+++ /dev/null
@@ -1,28 +0,0 @@
-Copyright (c) 2005, Sven Panne
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-1. Redistributions of source code must retain the above copyright notice,
-   this list of conditions and the following disclaimer.
-
-2. Redistributions in binary form must reproduce the above copyright
-   notice, this list of conditions and the following disclaimer in the
-   documentation and/or other materials provided with the distribution.
-
-3. Neither the name of the author nor the names of its contributors may be
-   used to endorse or promote products derived from this software without
-   specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
diff --git a/debian/libhugs-alut-bundled.examples b/debian/libhugs-alut-bundled.examples
deleted file mode 100644
index 13fdef2..0000000
--- a/debian/libhugs-alut-bundled.examples
+++ /dev/null
@@ -1 +0,0 @@
-debian/tmp/usr/lib/hugs/demos/ALUT
diff --git a/debian/libhugs-alut-bundled.install b/debian/libhugs-alut-bundled.install
deleted file mode 100644
index c315d1b..0000000
--- a/debian/libhugs-alut-bundled.install
+++ /dev/null
@@ -1 +0,0 @@
-usr/lib/hugs/packages/ALUT
diff --git a/debian/libhugs-base-bundled.README.Debian b/debian/libhugs-base-bundled.README.Debian
deleted file mode 100644
index 325e01e..0000000
--- a/debian/libhugs-base-bundled.README.Debian
+++ /dev/null
@@ -1,3 +0,0 @@
-Version of the base library package bundled with Hugs.
-
-Documentation for this package can be found in the ghc6-doc package.
diff --git a/debian/libhugs-base-bundled.copyright b/debian/libhugs-base-bundled.copyright
deleted file mode 100644
index e25dd46..0000000
--- a/debian/libhugs-base-bundled.copyright
+++ /dev/null
@@ -1,83 +0,0 @@
-This library (libraries/base) is derived from code from several
-sources: 
-
-  * Code from the GHC project which is largely (c) The University of
-    Glasgow, and distributable under a BSD-style license (see below),
-
-  * Code from the Haskell 98 Report which is (c) Simon Peyton Jones
-    and freely redistributable (but see the full license for
-    restrictions).
-
-  * Code from the Haskell Foreign Function Interface specification,
-    which is (c) Manuel M. T. Chakravarty and freely redistributable
-    (but see the full license for restrictions).
-
-The full text of these licenses is reproduced below.  All of the
-licenses are BSD-style or compatible.
-
------------------------------------------------------------------------------
-
-The Glasgow Haskell Compiler License
-
-Copyright 2004, The University Court of the University of Glasgow. 
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-- Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
- 
-- Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution.
- 
-- Neither name of the University nor the names of its contributors may be
-used to endorse or promote products derived from this software without
-specific prior written permission. 
-
-THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY COURT OF THE UNIVERSITY OF
-GLASGOW AND THE CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
-INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
-FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-UNIVERSITY COURT OF THE UNIVERSITY OF GLASGOW OR THE CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
-OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
-DAMAGE.
-
------------------------------------------------------------------------------
-
-Code derived from the document "Report on the Programming Language
-Haskell 98", is distributed under the following license:
-
-  Copyright (c) 2002 Simon Peyton Jones
-
-  The authors intend this Report to belong to the entire Haskell
-  community, and so we grant permission to copy and distribute it for
-  any purpose, provided that it is reproduced in its entirety,
-  including this Notice.  Modified versions of this Report may also be
-  copied and distributed for any purpose, provided that the modified
-  version is clearly presented as such, and that it does not claim to
-  be a definition of the Haskell 98 Language.
-
------------------------------------------------------------------------------
-
-Code derived from the document "The Haskell 98 Foreign Function
-Interface, An Addendum to the Haskell 98 Report" is distributed under
-the following license:
-
-  Copyright (c) 2002 Manuel M. T. Chakravarty
-
-  The authors intend this Report to belong to the entire Haskell
-  community, and so we grant permission to copy and distribute it for
-  any purpose, provided that it is reproduced in its entirety,
-  including this Notice.  Modified versions of this Report may also be
-  copied and distributed for any purpose, provided that the modified
-  version is clearly presented as such, and that it does not claim to
-  be a definition of the Haskell 98 Foreign Function Interface.
-
------------------------------------------------------------------------------
diff --git a/debian/libhugs-base-bundled.install b/debian/libhugs-base-bundled.install
deleted file mode 100644
index c0b2b40..0000000
--- a/debian/libhugs-base-bundled.install
+++ /dev/null
@@ -1 +0,0 @@
-usr/lib/hugs/packages/base
diff --git a/debian/libhugs-cabal-bundled.README.Debian b/debian/libhugs-cabal-bundled.README.Debian
deleted file mode 100644
index e2b2fa7..0000000
--- a/debian/libhugs-cabal-bundled.README.Debian
+++ /dev/null
@@ -1,3 +0,0 @@
-Version of the Cabal library package bundled with Hugs.
-
-Documentation for this package can be found in the ghc6-doc package.
diff --git a/debian/libhugs-cabal-bundled.copyright b/debian/libhugs-cabal-bundled.copyright
deleted file mode 100644
index 01636f5..0000000
--- a/debian/libhugs-cabal-bundled.copyright
+++ /dev/null
@@ -1,30 +0,0 @@
-Copyright Isaac Jones 2003-2005.
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-
-    * Redistributions in binary form must reproduce the above
-      copyright notice, this list of conditions and the following
-      disclaimer in the documentation and/or other materials provided
-      with the distribution.
-
-    * Neither the name of Isaac Jones nor the names of other
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/debian/libhugs-cabal-bundled.examples b/debian/libhugs-cabal-bundled.examples
deleted file mode 100644
index 3ec8992..0000000
--- a/debian/libhugs-cabal-bundled.examples
+++ /dev/null
@@ -1 +0,0 @@
-debian/tmp/usr/lib/hugs/demos/Cabal
diff --git a/debian/libhugs-cabal-bundled.install b/debian/libhugs-cabal-bundled.install
deleted file mode 100644
index 8a1bf3d..0000000
--- a/debian/libhugs-cabal-bundled.install
+++ /dev/null
@@ -1 +0,0 @@
-usr/lib/hugs/packages/Cabal
diff --git a/debian/libhugs-fgl-bundled.README.Debian b/debian/libhugs-fgl-bundled.README.Debian
deleted file mode 100644
index a67909a..0000000
--- a/debian/libhugs-fgl-bundled.README.Debian
+++ /dev/null
@@ -1,3 +0,0 @@
-Version of the fgl library package bundled with Hugs.
-
-Documentation for this package can be found in the ghc6-doc package.
diff --git a/debian/libhugs-fgl-bundled.copyright b/debian/libhugs-fgl-bundled.copyright
deleted file mode 100644
index 56d41c0..0000000
--- a/debian/libhugs-fgl-bundled.copyright
+++ /dev/null
@@ -1,28 +0,0 @@
-Copyright (c) 1999-2004, Martin Erwig
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-1. Redistributions of source code must retain the above copyright notice,
-   this list of conditions and the following disclaimer.
-
-2. Redistributions in binary form must reproduce the above copyright
-   notice, this list of conditions and the following disclaimer in the
-   documentation and/or other materials provided with the distribution.
-
-3. Neither the name of the author nor the names of its contributors may be
-   used to endorse or promote products derived from this software without
-   specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
diff --git a/debian/libhugs-fgl-bundled.install b/debian/libhugs-fgl-bundled.install
deleted file mode 100644
index 4edf65d..0000000
--- a/debian/libhugs-fgl-bundled.install
+++ /dev/null
@@ -1 +0,0 @@
-usr/lib/hugs/packages/fgl
diff --git a/debian/libhugs-glut-bundled.README.Debian b/debian/libhugs-glut-bundled.README.Debian
deleted file mode 100644
index 8ad71cf..0000000
--- a/debian/libhugs-glut-bundled.README.Debian
+++ /dev/null
@@ -1,3 +0,0 @@
-Version of the GLUT library package bundled with Hugs.
-
-Documentation for this package can be found in the ghc6-doc package.
diff --git a/debian/libhugs-glut-bundled.copyright b/debian/libhugs-glut-bundled.copyright
deleted file mode 100644
index 40cf095..0000000
--- a/debian/libhugs-glut-bundled.copyright
+++ /dev/null
@@ -1,28 +0,0 @@
-Copyright (c) 2002-2005, Sven Panne
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-1. Redistributions of source code must retain the above copyright notice,
-   this list of conditions and the following disclaimer.
-
-2. Redistributions in binary form must reproduce the above copyright
-   notice, this list of conditions and the following disclaimer in the
-   documentation and/or other materials provided with the distribution.
-
-3. Neither the name of the author nor the names of its contributors may be
-   used to endorse or promote products derived from this software without
-   specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
diff --git a/debian/libhugs-glut-bundled.examples b/debian/libhugs-glut-bundled.examples
deleted file mode 100644
index b692441..0000000
--- a/debian/libhugs-glut-bundled.examples
+++ /dev/null
@@ -1 +0,0 @@
-debian/tmp/usr/lib/hugs/demos/GLUT
diff --git a/debian/libhugs-glut-bundled.install b/debian/libhugs-glut-bundled.install
deleted file mode 100644
index a81008b..0000000
--- a/debian/libhugs-glut-bundled.install
+++ /dev/null
@@ -1 +0,0 @@
-usr/lib/hugs/packages/GLUT
diff --git a/debian/libhugs-haskell-src-bundled.README.Debian b/debian/libhugs-haskell-src-bundled.README.Debian
deleted file mode 100644
index ee967ef..0000000
--- a/debian/libhugs-haskell-src-bundled.README.Debian
+++ /dev/null
@@ -1,3 +0,0 @@
-Version of the haskell-src library package bundled with Hugs.
-
-Documentation for this package can be found in the ghc6-doc package.
diff --git a/debian/libhugs-haskell-src-bundled.copyright b/debian/libhugs-haskell-src-bundled.copyright
deleted file mode 100644
index 4ec14bf..0000000
--- a/debian/libhugs-haskell-src-bundled.copyright
+++ /dev/null
@@ -1,31 +0,0 @@
-The Glasgow Haskell Compiler License
-
-Copyright 2004, The University Court of the University of Glasgow. 
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-- Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
- 
-- Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution.
- 
-- Neither name of the University nor the names of its contributors may be
-used to endorse or promote products derived from this software without
-specific prior written permission. 
-
-THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY COURT OF THE UNIVERSITY OF
-GLASGOW AND THE CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
-INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
-FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-UNIVERSITY COURT OF THE UNIVERSITY OF GLASGOW OR THE CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
-OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
-DAMAGE.
diff --git a/debian/libhugs-haskell-src-bundled.examples b/debian/libhugs-haskell-src-bundled.examples
deleted file mode 100644
index 3a31839..0000000
--- a/debian/libhugs-haskell-src-bundled.examples
+++ /dev/null
@@ -1 +0,0 @@
-debian/tmp/usr/lib/hugs/demos/haskell-src
diff --git a/debian/libhugs-haskell-src-bundled.install b/debian/libhugs-haskell-src-bundled.install
deleted file mode 100644
index b7f867a..0000000
--- a/debian/libhugs-haskell-src-bundled.install
+++ /dev/null
@@ -1 +0,0 @@
-usr/lib/hugs/packages/haskell-src
diff --git a/debian/libhugs-haskell98-bundled.README.Debian b/debian/libhugs-haskell98-bundled.README.Debian
deleted file mode 100644
index d90e8fe..0000000
--- a/debian/libhugs-haskell98-bundled.README.Debian
+++ /dev/null
@@ -1,3 +0,0 @@
-Version of the haskell98 library package bundled with Hugs.
-
-Documentation for this package can be found in the ghc6-doc package.
diff --git a/debian/libhugs-haskell98-bundled.copyright b/debian/libhugs-haskell98-bundled.copyright
deleted file mode 100644
index de923be..0000000
--- a/debian/libhugs-haskell98-bundled.copyright
+++ /dev/null
@@ -1,28 +0,0 @@
-Code derived from the document "Report on the Programming Language
-Haskell 98", is distributed under the following license:
-
-  Copyright (c) 2002 Simon Peyton Jones
-
-  The authors intend this Report to belong to the entire Haskell
-  community, and so we grant permission to copy and distribute it for
-  any purpose, provided that it is reproduced in its entirety,
-  including this Notice.  Modified versions of this Report may also be
-  copied and distributed for any purpose, provided that the modified
-  version is clearly presented as such, and that it does not claim to
-  be a definition of the Haskell 98 Language.
-
------------------------------------------------------------------------------
-
-Code derived from the document "The Haskell 98 Foreign Function
-Interface, An Addendum to the Haskell 98 Report" is distributed under
-the following license:
-
-  Copyright (c) 2002 Manuel M. T. Chakravarty
-
-  The authors intend this Report to belong to the entire Haskell
-  community, and so we grant permission to copy and distribute it for
-  any purpose, provided that it is reproduced in its entirety,
-  including this Notice.  Modified versions of this Report may also be
-  copied and distributed for any purpose, provided that the modified
-  version is clearly presented as such, and that it does not claim to
-  be a definition of the Haskell 98 Foreign Function Interface.
diff --git a/debian/libhugs-haskell98-bundled.install b/debian/libhugs-haskell98-bundled.install
deleted file mode 100644
index 72132dd..0000000
--- a/debian/libhugs-haskell98-bundled.install
+++ /dev/null
@@ -1 +0,0 @@
-usr/lib/hugs/packages/haskell98
diff --git a/debian/libhugs-haxml-bundled.README.Debian b/debian/libhugs-haxml-bundled.README.Debian
deleted file mode 100644
index 459fc15..0000000
--- a/debian/libhugs-haxml-bundled.README.Debian
+++ /dev/null
@@ -1,3 +0,0 @@
-Version of the HaXml library package bundled with Hugs.
-
-Documentation for this package can be found in the ghc6-doc package.
diff --git a/debian/libhugs-haxml-bundled.copyright b/debian/libhugs-haxml-bundled.copyright
deleted file mode 100644
index d10e9cc..0000000
--- a/debian/libhugs-haxml-bundled.copyright
+++ /dev/null
@@ -1,34 +0,0 @@
-The HaXml library and tools were written by and are copyright to
-    (c) copyright 1998-2006    Malcolm Wallace and Colin Runciman
-
-The library incorporates the module Text.ParserCombinators.HuttonMeijerWallace
-    (c) copyright 1996         Graham Hutton and Erik Meijer
-with modifications
-    (c) copyright 1998-2000    Malcolm Wallace
-
-The HaXml library is licensed under the terms of the GNU Lesser
-General Public Licence (LGPL), which can be found in the file called
-LICENCE-LGPL, with the following special exception:
-
-----
-As a relaxation of clause 6 of the LGPL, the copyright holders of this
-library give permission to use, copy, link, modify, and distribute,
-binary-only object-code versions of an executable linked with the
-original unmodified Library, without requiring the supply of any
-mechanism to modify or replace the Library and relink (clauses 6a,
-6b, 6c, 6d, 6e), provided that all the other terms of clause 6 are
-complied with.
-----
-
-The HaXml tools Xtract, Validate, DtdToHaskell, and MkOneOf, are
-licensed under the terms of the GNU General Public Licence (GPL),
-which can be found in the file called LICENCE-GPL.
-
-This library and toolset is distributed in the hope that it will be
-useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-Licences for more details.
-
-If these licensing terms are not acceptable to you, please contact me for
-negotiation.  :-)
-    Malcolm.Wallace@cs.york.ac.uk
diff --git a/debian/libhugs-haxml-bundled.examples b/debian/libhugs-haxml-bundled.examples
deleted file mode 100644
index 019dd5d..0000000
--- a/debian/libhugs-haxml-bundled.examples
+++ /dev/null
@@ -1 +0,0 @@
-debian/tmp/usr/lib/hugs/demos/HaXml
diff --git a/debian/libhugs-haxml-bundled.install b/debian/libhugs-haxml-bundled.install
deleted file mode 100644
index fa251da..0000000
--- a/debian/libhugs-haxml-bundled.install
+++ /dev/null
@@ -1 +0,0 @@
-usr/lib/hugs/packages/HaXml
diff --git a/debian/libhugs-hgl-bundled.README.Debian b/debian/libhugs-hgl-bundled.README.Debian
deleted file mode 100644
index d8364ff..0000000
--- a/debian/libhugs-hgl-bundled.README.Debian
+++ /dev/null
@@ -1,3 +0,0 @@
-Version of the HGL library package bundled with Hugs.
-
-Documentation for this package can be found in the ghc6-doc package.
diff --git a/debian/libhugs-hgl-bundled.copyright b/debian/libhugs-hgl-bundled.copyright
deleted file mode 100644
index 53e7a36..0000000
--- a/debian/libhugs-hgl-bundled.copyright
+++ /dev/null
@@ -1,26 +0,0 @@
-The Haskell Graphics Library is Copyright (c) Alastair Reid,
-1996-2003, All rights reserved, and is distributed as free software
-under the following license.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions
-are met:
-
-- Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
-
-- Neither name of the copyright holders nor the names of its
-contributors may be used to endorse or promote products derived from
-this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND THE CONTRIBUTORS
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-HOLDERS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
-OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
-TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
-USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/debian/libhugs-hgl-bundled.examples b/debian/libhugs-hgl-bundled.examples
deleted file mode 100644
index 7aa04d1..0000000
--- a/debian/libhugs-hgl-bundled.examples
+++ /dev/null
@@ -1 +0,0 @@
-debian/tmp/usr/lib/hugs/demos/HGL
diff --git a/debian/libhugs-hgl-bundled.install b/debian/libhugs-hgl-bundled.install
deleted file mode 100644
index fc39eed..0000000
--- a/debian/libhugs-hgl-bundled.install
+++ /dev/null
@@ -1 +0,0 @@
-usr/lib/hugs/packages/HGL
diff --git a/debian/libhugs-hunit-bundled.README.Debian b/debian/libhugs-hunit-bundled.README.Debian
deleted file mode 100644
index 93aadf6..0000000
--- a/debian/libhugs-hunit-bundled.README.Debian
+++ /dev/null
@@ -1,3 +0,0 @@
-Version of the HUnit library package bundled with Hugs.
-
-Documentation for this package can be found in the ghc6-doc package.
diff --git a/debian/libhugs-hunit-bundled.copyright b/debian/libhugs-hunit-bundled.copyright
deleted file mode 100644
index ae83e4c..0000000
--- a/debian/libhugs-hunit-bundled.copyright
+++ /dev/null
@@ -1,29 +0,0 @@
-HUnit is Copyright (c) Dean Herington, 2002, all rights reserved,
-and is distributed as free software under the following license.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions
-are met:
-
-- Redistributions of source code must retain the above copyright
-notice, this list of conditions, and the following disclaimer.
-
-- Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions, and the following disclaimer in the
-documentation and/or other materials provided with the distribution.
-
-- The names of the copyright holders may not be used to endorse or
-promote products derived from this software without specific prior
-written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS "AS IS" AND ANY
-EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
-BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
-OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
-IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/debian/libhugs-hunit-bundled.examples b/debian/libhugs-hunit-bundled.examples
deleted file mode 100644
index f08a25b..0000000
--- a/debian/libhugs-hunit-bundled.examples
+++ /dev/null
@@ -1 +0,0 @@
-debian/tmp/usr/lib/hugs/demos/HUnit
diff --git a/debian/libhugs-hunit-bundled.install b/debian/libhugs-hunit-bundled.install
deleted file mode 100644
index 9cbe9ae..0000000
--- a/debian/libhugs-hunit-bundled.install
+++ /dev/null
@@ -1 +0,0 @@
-usr/lib/hugs/packages/HUnit
diff --git a/debian/libhugs-mtl-bundled.README.Debian b/debian/libhugs-mtl-bundled.README.Debian
deleted file mode 100644
index aeb9e58..0000000
--- a/debian/libhugs-mtl-bundled.README.Debian
+++ /dev/null
@@ -1,3 +0,0 @@
-Version of the mtl library package bundled with Hugs.
-
-Documentation for this package can be found in the ghc6-doc package.
diff --git a/debian/libhugs-mtl-bundled.copyright b/debian/libhugs-mtl-bundled.copyright
deleted file mode 100644
index 4ec14bf..0000000
--- a/debian/libhugs-mtl-bundled.copyright
+++ /dev/null
@@ -1,31 +0,0 @@
-The Glasgow Haskell Compiler License
-
-Copyright 2004, The University Court of the University of Glasgow. 
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-- Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
- 
-- Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution.
- 
-- Neither name of the University nor the names of its contributors may be
-used to endorse or promote products derived from this software without
-specific prior written permission. 
-
-THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY COURT OF THE UNIVERSITY OF
-GLASGOW AND THE CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
-INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
-FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-UNIVERSITY COURT OF THE UNIVERSITY OF GLASGOW OR THE CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
-OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
-DAMAGE.
diff --git a/debian/libhugs-mtl-bundled.install b/debian/libhugs-mtl-bundled.install
deleted file mode 100644
index 8a50490..0000000
--- a/debian/libhugs-mtl-bundled.install
+++ /dev/null
@@ -1 +0,0 @@
-usr/lib/hugs/packages/mtl
diff --git a/debian/libhugs-network-bundled.README.Debian b/debian/libhugs-network-bundled.README.Debian
deleted file mode 100644
index f5508f1..0000000
--- a/debian/libhugs-network-bundled.README.Debian
+++ /dev/null
@@ -1,3 +0,0 @@
-Version of the network library package bundled with Hugs.
-
-Documentation for this package can be found in the ghc6-doc package.
diff --git a/debian/libhugs-network-bundled.copyright b/debian/libhugs-network-bundled.copyright
deleted file mode 100644
index b5059b7..0000000
--- a/debian/libhugs-network-bundled.copyright
+++ /dev/null
@@ -1,31 +0,0 @@
-The Glasgow Haskell Compiler License
-
-Copyright 2002, The University Court of the University of Glasgow. 
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-- Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
- 
-- Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution.
- 
-- Neither name of the University nor the names of its contributors may be
-used to endorse or promote products derived from this software without
-specific prior written permission. 
-
-THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY COURT OF THE UNIVERSITY OF
-GLASGOW AND THE CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
-INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
-FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-UNIVERSITY COURT OF THE UNIVERSITY OF GLASGOW OR THE CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
-OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
-DAMAGE.
diff --git a/debian/libhugs-network-bundled.install b/debian/libhugs-network-bundled.install
deleted file mode 100644
index 3426e2f..0000000
--- a/debian/libhugs-network-bundled.install
+++ /dev/null
@@ -1 +0,0 @@
-usr/lib/hugs/packages/network
diff --git a/debian/libhugs-openal-bundled.README.Debian b/debian/libhugs-openal-bundled.README.Debian
deleted file mode 100644
index f9acf92..0000000
--- a/debian/libhugs-openal-bundled.README.Debian
+++ /dev/null
@@ -1,3 +0,0 @@
-Version of the OpenAL library package bundled with Hugs.
-
-Documentation for this package can be found in the ghc6-doc package.
diff --git a/debian/libhugs-openal-bundled.copyright b/debian/libhugs-openal-bundled.copyright
deleted file mode 100644
index 20df169..0000000
--- a/debian/libhugs-openal-bundled.copyright
+++ /dev/null
@@ -1,28 +0,0 @@
-Copyright (c) 2003-2005, Sven Panne
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-1. Redistributions of source code must retain the above copyright notice,
-   this list of conditions and the following disclaimer.
-
-2. Redistributions in binary form must reproduce the above copyright
-   notice, this list of conditions and the following disclaimer in the
-   documentation and/or other materials provided with the distribution.
-
-3. Neither the name of the author nor the names of its contributors may be
-   used to endorse or promote products derived from this software without
-   specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
diff --git a/debian/libhugs-openal-bundled.examples b/debian/libhugs-openal-bundled.examples
deleted file mode 100644
index ffd613c..0000000
--- a/debian/libhugs-openal-bundled.examples
+++ /dev/null
@@ -1 +0,0 @@
-debian/tmp/usr/lib/hugs/demos/OpenAL
diff --git a/debian/libhugs-openal-bundled.install b/debian/libhugs-openal-bundled.install
deleted file mode 100644
index 507ae5b..0000000
--- a/debian/libhugs-openal-bundled.install
+++ /dev/null
@@ -1 +0,0 @@
-usr/lib/hugs/packages/OpenAL
diff --git a/debian/libhugs-opengl-bundled.README.Debian b/debian/libhugs-opengl-bundled.README.Debian
deleted file mode 100644
index 082070a..0000000
--- a/debian/libhugs-opengl-bundled.README.Debian
+++ /dev/null
@@ -1,3 +0,0 @@
-Version of the OpenGL library package bundled with Hugs.
-
-Documentation for this package can be found in the ghc6-doc package.
diff --git a/debian/libhugs-opengl-bundled.copyright b/debian/libhugs-opengl-bundled.copyright
deleted file mode 100644
index 40cf095..0000000
--- a/debian/libhugs-opengl-bundled.copyright
+++ /dev/null
@@ -1,28 +0,0 @@
-Copyright (c) 2002-2005, Sven Panne
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-1. Redistributions of source code must retain the above copyright notice,
-   this list of conditions and the following disclaimer.
-
-2. Redistributions in binary form must reproduce the above copyright
-   notice, this list of conditions and the following disclaimer in the
-   documentation and/or other materials provided with the distribution.
-
-3. Neither the name of the author nor the names of its contributors may be
-   used to endorse or promote products derived from this software without
-   specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
diff --git a/debian/libhugs-opengl-bundled.install b/debian/libhugs-opengl-bundled.install
deleted file mode 100644
index 53398d8..0000000
--- a/debian/libhugs-opengl-bundled.install
+++ /dev/null
@@ -1 +0,0 @@
-usr/lib/hugs/packages/OpenGL
diff --git a/debian/libhugs-parsec-bundled.README.Debian b/debian/libhugs-parsec-bundled.README.Debian
deleted file mode 100644
index 1612587..0000000
--- a/debian/libhugs-parsec-bundled.README.Debian
+++ /dev/null
@@ -1,3 +0,0 @@
-Version of the parsec library package bundled with Hugs.
-
-Documentation for this package can be found in the ghc6-doc package.
diff --git a/debian/libhugs-parsec-bundled.copyright b/debian/libhugs-parsec-bundled.copyright
deleted file mode 100644
index adae961..0000000
--- a/debian/libhugs-parsec-bundled.copyright
+++ /dev/null
@@ -1,21 +0,0 @@
-Copyright 1999-2000, Daan Leijen. All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-* Redistributions of source code must retain the above copyright notice,
-  this list of conditions and the following disclaimer.
-* Redistributions in binary form must reproduce the above copyright
-  notice, this list of conditions and the following disclaimer in the
-  documentation and/or other materials provided with the distribution.
-
-This software is provided by the copyright holders "as is" and any express or
-implied warranties, including, but not limited to, the implied warranties of
-merchantability and fitness for a particular purpose are disclaimed. In no
-event shall the copyright holders be liable for any direct, indirect,
-incidental, special, exemplary, or consequential damages (including, but not
-limited to, procurement of substitute goods or services; loss of use, data,
-or profits; or business interruption) however caused and on any theory of
-liability, whether in contract, strict liability, or tort (including
-negligence or otherwise) arising in any way out of the use of this software,
-even if advised of the possibility of such damage.
diff --git a/debian/libhugs-parsec-bundled.examples b/debian/libhugs-parsec-bundled.examples
deleted file mode 100644
index 84a1328..0000000
--- a/debian/libhugs-parsec-bundled.examples
+++ /dev/null
@@ -1 +0,0 @@
-debian/tmp/usr/lib/hugs/demos/parsec
diff --git a/debian/libhugs-parsec-bundled.install b/debian/libhugs-parsec-bundled.install
deleted file mode 100644
index fce112b..0000000
--- a/debian/libhugs-parsec-bundled.install
+++ /dev/null
@@ -1 +0,0 @@
-usr/lib/hugs/packages/parsec
diff --git a/debian/libhugs-quickcheck-bundled.README.Debian b/debian/libhugs-quickcheck-bundled.README.Debian
deleted file mode 100644
index d6f78cb..0000000
--- a/debian/libhugs-quickcheck-bundled.README.Debian
+++ /dev/null
@@ -1,3 +0,0 @@
-Version of the QuickCheck library package bundled with Hugs.
-
-Documentation for this package can be found in the ghc6-doc package.
diff --git a/debian/libhugs-quickcheck-bundled.copyright b/debian/libhugs-quickcheck-bundled.copyright
deleted file mode 100644
index 4ec14bf..0000000
--- a/debian/libhugs-quickcheck-bundled.copyright
+++ /dev/null
@@ -1,31 +0,0 @@
-The Glasgow Haskell Compiler License
-
-Copyright 2004, The University Court of the University of Glasgow. 
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-- Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
- 
-- Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution.
- 
-- Neither name of the University nor the names of its contributors may be
-used to endorse or promote products derived from this software without
-specific prior written permission. 
-
-THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY COURT OF THE UNIVERSITY OF
-GLASGOW AND THE CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
-INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
-FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-UNIVERSITY COURT OF THE UNIVERSITY OF GLASGOW OR THE CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
-OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
-DAMAGE.
diff --git a/debian/libhugs-quickcheck-bundled.install b/debian/libhugs-quickcheck-bundled.install
deleted file mode 100644
index a40a95a..0000000
--- a/debian/libhugs-quickcheck-bundled.install
+++ /dev/null
@@ -1 +0,0 @@
-usr/lib/hugs/packages/QuickCheck
diff --git a/debian/libhugs-stm-bundled.README.Debian b/debian/libhugs-stm-bundled.README.Debian
deleted file mode 100644
index 8697b97..0000000
--- a/debian/libhugs-stm-bundled.README.Debian
+++ /dev/null
@@ -1,3 +0,0 @@
-Version of the stm library package bundled with Hugs.
-
-Documentation for this package can be found in the ghc6-doc package.
diff --git a/debian/libhugs-stm-bundled.copyright b/debian/libhugs-stm-bundled.copyright
deleted file mode 100644
index 4ec14bf..0000000
--- a/debian/libhugs-stm-bundled.copyright
+++ /dev/null
@@ -1,31 +0,0 @@
-The Glasgow Haskell Compiler License
-
-Copyright 2004, The University Court of the University of Glasgow. 
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-- Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
- 
-- Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution.
- 
-- Neither name of the University nor the names of its contributors may be
-used to endorse or promote products derived from this software without
-specific prior written permission. 
-
-THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY COURT OF THE UNIVERSITY OF
-GLASGOW AND THE CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
-INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
-FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-UNIVERSITY COURT OF THE UNIVERSITY OF GLASGOW OR THE CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
-OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
-DAMAGE.
diff --git a/debian/libhugs-stm-bundled.install b/debian/libhugs-stm-bundled.install
deleted file mode 100644
index 6a9615b..0000000
--- a/debian/libhugs-stm-bundled.install
+++ /dev/null
@@ -1 +0,0 @@
-usr/lib/hugs/packages/stm
diff --git a/debian/libhugs-time-bundled.README.Debian b/debian/libhugs-time-bundled.README.Debian
deleted file mode 100644
index 2a28711..0000000
--- a/debian/libhugs-time-bundled.README.Debian
+++ /dev/null
@@ -1,3 +0,0 @@
-Version of the time library package bundled with Hugs.
-
-Documentation for this package can be found in the ghc6-doc package.
diff --git a/debian/libhugs-time-bundled.copyright b/debian/libhugs-time-bundled.copyright
deleted file mode 100644
index 17f1f27..0000000
--- a/debian/libhugs-time-bundled.copyright
+++ /dev/null
@@ -1,10 +0,0 @@
-TimeLib is Copyright (c) Ashley Yakeley, 2004-2005.
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
-
-- Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
-
-- Neither name of the copyright holders nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/debian/libhugs-time-bundled.install b/debian/libhugs-time-bundled.install
deleted file mode 100644
index 1c802bb..0000000
--- a/debian/libhugs-time-bundled.install
+++ /dev/null
@@ -1 +0,0 @@
-usr/lib/hugs/packages/time
diff --git a/debian/libhugs-unix-bundled.README.Debian b/debian/libhugs-unix-bundled.README.Debian
deleted file mode 100644
index ceb256a..0000000
--- a/debian/libhugs-unix-bundled.README.Debian
+++ /dev/null
@@ -1,3 +0,0 @@
-Version of the unix library package bundled with Hugs.
-
-Documentation for this package can be found in the ghc6-doc package.
diff --git a/debian/libhugs-unix-bundled.copyright b/debian/libhugs-unix-bundled.copyright
deleted file mode 100644
index 4ec14bf..0000000
--- a/debian/libhugs-unix-bundled.copyright
+++ /dev/null
@@ -1,31 +0,0 @@
-The Glasgow Haskell Compiler License
-
-Copyright 2004, The University Court of the University of Glasgow. 
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-- Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
- 
-- Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution.
- 
-- Neither name of the University nor the names of its contributors may be
-used to endorse or promote products derived from this software without
-specific prior written permission. 
-
-THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY COURT OF THE UNIVERSITY OF
-GLASGOW AND THE CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
-INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
-FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-UNIVERSITY COURT OF THE UNIVERSITY OF GLASGOW OR THE CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
-OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
-DAMAGE.
diff --git a/debian/libhugs-unix-bundled.install b/debian/libhugs-unix-bundled.install
deleted file mode 100644
index 35854dc..0000000
--- a/debian/libhugs-unix-bundled.install
+++ /dev/null
@@ -1 +0,0 @@
-usr/lib/hugs/packages/unix
diff --git a/debian/libhugs-x11-bundled.README.Debian b/debian/libhugs-x11-bundled.README.Debian
deleted file mode 100644
index 28edd66..0000000
--- a/debian/libhugs-x11-bundled.README.Debian
+++ /dev/null
@@ -1,3 +0,0 @@
-Version of the X11 library package bundled with Hugs.
-
-Documentation for this package can be found in the ghc6-doc package.
diff --git a/debian/libhugs-x11-bundled.copyright b/debian/libhugs-x11-bundled.copyright
deleted file mode 100644
index c51c23d..0000000
--- a/debian/libhugs-x11-bundled.copyright
+++ /dev/null
@@ -1,26 +0,0 @@
-The HSX11 Library is Copyright (c) Alastair Reid,
-1997-2003, All rights reserved, and is distributed as free software
-under the following license.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions
-are met:
-
-- Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
-
-- Neither name of the copyright holders nor the names of its
-contributors may be used to endorse or promote products derived from
-this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND THE CONTRIBUTORS
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-HOLDERS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
-OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
-TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
-USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/debian/libhugs-x11-bundled.install b/debian/libhugs-x11-bundled.install
deleted file mode 100644
index 99c121f..0000000
--- a/debian/libhugs-x11-bundled.install
+++ /dev/null
@@ -1 +0,0 @@
-usr/lib/hugs/packages/X11
diff --git a/debian/libhugs-xhtml-bundled.README.Debian b/debian/libhugs-xhtml-bundled.README.Debian
deleted file mode 100644
index 21dba3a..0000000
--- a/debian/libhugs-xhtml-bundled.README.Debian
+++ /dev/null
@@ -1,3 +0,0 @@
-Version of the xhtml library package bundled with Hugs.
-
-Documentation for this package can be found in the ghc6-doc package.
diff --git a/debian/libhugs-xhtml-bundled.copyright b/debian/libhugs-xhtml-bundled.copyright
deleted file mode 100644
index 249526e..0000000
--- a/debian/libhugs-xhtml-bundled.copyright
+++ /dev/null
@@ -1,31 +0,0 @@
-Copyright 2001-2005, The University Court of the University of
-Glasgow, Bjorn Bringert, Andy Gill, Ian Lynagh, Erik Meijer, Sven Panne
-
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-- Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
- 
-- Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution.
- 
-- Neither name of the University nor the names of its contributors may be
-used to endorse or promote products derived from this software without
-specific prior written permission. 
-
-THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY COURT OF THE UNIVERSITY OF
-GLASGOW AND THE CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
-INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
-FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-UNIVERSITY COURT OF THE UNIVERSITY OF GLASGOW OR THE CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
-OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
-DAMAGE.
diff --git a/debian/libhugs-xhtml-bundled.install b/debian/libhugs-xhtml-bundled.install
deleted file mode 100644
index a3ffc1b..0000000
--- a/debian/libhugs-xhtml-bundled.install
+++ /dev/null
@@ -1 +0,0 @@
-usr/lib/hugs/packages/xhtml
diff --git a/fptools/hslibs/lang/PrelByteArr.lhs b/fptools/hslibs/lang/PrelByteArr.lhs
index 61df433..ca2b84d 100644
--- a/fptools/hslibs/lang/PrelByteArr.lhs
+++ b/fptools/hslibs/lang/PrelByteArr.lhs
@@ -181,8 +181,7 @@ writeDoubleArray (MutableByteArray l u barr#) n (D# ele) = ST $ \ s# ->
 \begin{code}
 unsafeFreezeByteArray :: Ix ix => MutableByteArray s ix -> ST s (ByteArray ix)
 
-{-# SPECIALIZE unsafeFreezeByteArray :: MutableByteArray s Int -> ST s (ByteArray Int)
-  #-}
+{-# SPECIALIZE unsafeFreezeByteArray :: MutableByteArray s Int -> ST s (ByteArray Int)  #-}
 
 unsafeFreezeByteArray (MutableByteArray l u arr#) = ST $ \ s# ->
     case unsafeFreezeByteArray# arr# s# of { (# s2#, frozen# #) ->
diff --git a/libraries/configure b/libraries/configure
index d00e600..10b0b31 100755
--- a/libraries/configure
+++ b/libraries/configure
@@ -3430,8 +3430,7 @@ else
 
 cat > conftest.c << EOF
 #if 1
-{-# INLINE f'
- #-}
+{-# INLINE f' #-}
 f' x = x+1
 #endif
 EOF
@@ -3450,8 +3449,7 @@ cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
 #if 1
-{-# INLINE f'
- #-}
+{-# INLINE f' #-}
 f' x = x+1
 #endif
 
diff --git a/libraries/tools/make_bootlib b/libraries/tools/make_bootlib
index c317f68..ab0154e 100755
--- a/libraries/tools/make_bootlib
+++ b/libraries/tools/make_bootlib
@@ -1,5 +1,5 @@
 #!/bin/sh
-
+set -e -o pipefail
 # Create libraries sufficient for runhugs, ffihugs, cpphs, hsc2hs and
 # Cabal scripts.
 
@@ -32,19 +32,19 @@ export HUGSDIR HUGSFLAGS
 
 case `uname -a` in
 *CYGWIN*)
-	# Canonicalize win32 paths 
-	# (i.e., stay far away from unportable /cygdrive-paths)
-	case $platform in
-	Cygwin)	# stay away from -m
-		# (older versions of 'cygpath' don't support it.)
-		source=`cygpath -w $source | sed -e 's@\\\\@/@g'`
-		target=`cygpath -w $target | sed -e 's@\\\\@/@g'`
-		tmpdir_root=`cygpath -w $tmpdir_root | sed -e 's@\\\\@/@g'`
-	esac
-
-	platform=Win32 ;;
+  # Canonicalize win32 paths 
+  # (i.e., stay far away from unportable /cygdrive-paths)
+  case $platform in
+  Cygwin)	# stay away from -m
+    # (older versions of 'cygpath' don't support it.)
+    source=`cygpath -w $source | sed -e 's@\\\\@/@g'`
+    target=`cygpath -w $target | sed -e 's@\\\\@/@g'`
+    tmpdir_root=`cygpath -w $tmpdir_root | sed -e 's@\\\\@/@g'`
+  esac
+
+  platform=Win32 ;;
 *MINGW*)
-	platform=Win32 ;;
+  platform=Win32 ;;
 *)	platform=Unix ;;
 esac
 
@@ -58,14 +58,14 @@ mkdir $tmpdir
 # K&R-style C preprocessor
 
 through_cpp() {
-	# The input file need not be called *.c, but for
-	# portability we run the preprocessor on a .c file.
-	cpp_input=$tmpdir/cppinput.c
+  # The input file need not be called *.c, but for
+  # portability we run the preprocessor on a .c file.
+  cpp_input=$tmpdir/cppinput.c
 
-	cp "$1" $cpp_input
+  cp "$1" $cpp_input
 
-	# gcc-3.3 on MacOS X 10.3 is reported to add #pragma
-	$cpp $cpp_flags $cpp_input | grep -v '^#' | cat -s
+  # gcc-3.3 on MacOS X 10.3 is reported to add #pragma
+  $cpp $cpp_flags $cpp_input | grep -v '^#' | cat -s
 }
 
 # internal Hugs modules
@@ -78,65 +78,83 @@ cp libraries/hugsbase/Hugs.hs $target
 
 for package in $boot_packages
 do
-	package_dir=$source/$package
-
-	# configure the library package first
-
-	if test -x $package_dir/configure; then
-		(cd $package_dir; ./configure)
-	fi
-
-	# Determine the list of modules to be converted
-
-	module_list=$tmpdir/list.1
-	all_modules=$tmpdir/list.2
-
-	(
-		cd $package_dir
-		$FIND . \( -name '[a-z]*' -o -name '[GN]HC' \) -prune -o \
-			\( -name \*.hs -o -name \*.lhs -o -name \*.hsc \) -print |
-			sed '	s:^\./::
-				s/\..*//' |
-			grep -v '^Text/Regex' |
-			$SORT -u >$all_modules
-
-		if [ -f hugs/exclude ]; then
-			sed '	/^[	]*#/ d
-				/^[ 	]*$/ d
-				s/[ 	].*//
-				s:\.:/:g' hugs/exclude |
-			$SORT -u | comm -13 - $all_modules >$module_list
-		else
-			mv $all_modules $module_list
-		fi
-	)
-
-	# Preprocess modules
-
-	while read modname
-	do	echo "Preprocessing $modname"
-
-		stem=$package_dir/$modname
-		target_stem=$target/$modname
-		dstdir=`dirname $target_stem`
-		basename=`basename $stem`
-		cpp_flags="$CPPFLAGS -I$HUGSDIR/include -I$package_dir/include -I$fp_includes"
-
-		mkdir -p $dstdir
-
-		# Hack: can't assume hsc2hs at this point, so just use cpp.
-		# This works for System.Time and System.CPUTime, but not
-		# Text.Regex.Posix, so we won't be compiling that.
-		if [ -f $stem.hsc ]; then
-			through_cpp $stem.hsc >$target_stem.hs
-		elif [ -f $stem.hs ]; then
-			through_cpp $stem.hs >$target_stem.hs
-		elif [ -f $stem.lhs ]; then
-			through_cpp $stem.lhs >$target_stem.lhs
-		else
-			echo "$0: don't know how to handle $stem" >&2
-		fi
-	done <$module_list
+  package_dir=$source/$package
+
+  # configure the library package first
+
+  if test -x $package_dir/configure && ! test -a $package_dir/config.status; then
+    (cd $package_dir; ./configure)
+  fi
+
+  # Determine the list of modules to be converted
+
+  module_list=$tmpdir/list.1
+  all_modules=$tmpdir/list.2
+
+  (
+    cd $package_dir
+    $FIND . \( -name '[a-z]*' -o -name '[GN]HC' \) -prune -o \
+      \( -name \*.hs -o -name \*.lhs -o -name \*.hsc \) -print |
+      sed '	s:^\./::
+        s/\..*//' |
+      grep -v '^Text/Regex' |
+      $SORT -u >$all_modules
+
+    if [ -f hugs/exclude ]; then
+      sed '	/^[	]*#/ d
+        /^[ 	]*$/ d
+        s/[ 	].*//
+        s:\.:/:g' hugs/exclude |
+      $SORT -u | comm -13 - $all_modules >$module_list
+    else
+      mv $all_modules $module_list
+    fi
+  )
+
+  # Preprocess modules
+
+  while read modname
+  do	echo "Preprocessing $modname"
+
+    stem=$package_dir/$modname
+    target_stem=$target/$modname
+    dstdir=`dirname $target_stem`
+    basename=`basename $stem`
+    # Need additional libraries added here
+    cpp_flags="$CPPFLAGS -I$HUGSDIR/include -I$package_dir/include -I$fp_includes -Ilibraries/include -Isrc"
+
+    mkdir -p $dstdir
+
+    # Hack: can't assume hsc2hs at this point, so just use cpp.
+    # This works for System.Time and System.CPUTime, but not
+    # Text.Regex.Posix, so we won't be compiling that.
+    if [ "packages/Cabal/DefaultSetup" == "$stem" ]; then
+      # Preprocessor chokes on this module, skip it.
+      cp $stem.lhs $target_stem.lhs
+    elif [ "packages/base/Control/Arrow" == "$stem" ]; then
+      # Preprocessor chokes on this module, skip it.
+      cp $stem.hs $target_stem.hs
+    elif [ "packages/base/System/Info" == "$stem" ]; then
+      # Need a define or preprocessor errors here
+      cpp_flags="-D__HUGS__ $cpp_flags" through_cpp $stem.hs > $target_stem.hs
+    elif [ "packages/base/System/Time" == "$stem" ]; then
+        # Need a define or preprocessor errors here
+        cpp_flags="-D__HUGS__ $cpp_flags" through_cpp $stem.hsc > $target_stem.hs
+    elif [ "packages/base/Data/Array" == "$stem" ]; then
+        # Preprocessor strips (//) operator unless --comments flag passed
+        cpp_flags="-D__HUGS__ --comments $cpp_flags" through_cpp $stem.hs > $target_stem.hs
+    else
+      if [ -f $stem.hsc ]; then
+        through_cpp $stem.hsc >$target_stem.hs
+      elif [ -f $stem.hs ]; then
+        through_cpp $stem.hs >$target_stem.hs
+      elif [ -f $stem.lhs ]; then
+        through_cpp $stem.lhs >$target_stem.lhs
+      else
+        echo "$0: don't know how to handle $stem" >&2
+      fi
+    fi
+  done <$module_list
 done
 
 # compile some modules in bootlibs with ffihugs
@@ -150,26 +168,45 @@ Unix)	base_libs= ;;
 Win32)	base_libs='-lwsock32' ;;
 esac
 
+# $ffihugs Hugs.Storable \
+# 	libraries/hugsbase/Hugs/Storable_aux.c
+
+# $ffihugs '-i"HsBase.h"' Foreign.C.Error $base_includes $base_libs
+# $ffihugs '-i"HsBase.h"' Foreign.Marshal.Alloc $base_includes $source/base/cbits/dirUtils.c $source/base/cbits/consUtils.c $base_libs
+# $ffihugs '-i"HsBase.h"' Foreign.Marshal.Utils $base_includes $base_libs
+# $ffihugs '-i"HsBase.h"' Foreign.Ptr $base_includes $base_libs
+
+# case $platform in
+# Unix)
+# 	$ffihugs '-i"HsBase.h"' System.Posix.Internals $source/base/cbits/dirUtils.c $base_includes
+# 	;;
+# Win32)
+# 	$ffihugs '-i"HsBase.h"' System.Directory $base_includes $base_libs
+# 	$ffihugs Distribution.Simple.Utils
+# 	$ffihugs -98 Distribution.Simple.LocalBuildInfo
+# 	;;
+# esac
+
 $ffihugs Hugs.Storable \
-	libraries/hugsbase/Hugs/Storable_aux.c
+  libraries/hugsbase/Hugs/Storable_aux.c
 
 $ffihugs '-i"HsBase.h"' Foreign.C.Error $base_includes \
-	$source/base/cbits/PrelIOUtils.c $base_libs
+  $source/base/cbits/PrelIOUtils.c $base_libs
 $ffihugs '-i"HsBase.h"' Foreign.Marshal.Alloc $base_includes \
-	$source/base/cbits/PrelIOUtils.c \
-	$source/base/cbits/dirUtils.c \
-	$source/base/cbits/consUtils.c $base_libs
+  $source/base/cbits/PrelIOUtils.c \
+  $source/base/cbits/dirUtils.c \
+  $source/base/cbits/consUtils.c $base_libs
 $ffihugs '-i"HsBase.h"' Foreign.Marshal.Utils $base_includes $base_libs
 $ffihugs '-i"HsBase.h"' Foreign.Ptr $base_includes \
-	$source/base/cbits/PrelIOUtils.c $base_libs
+  $source/base/cbits/PrelIOUtils.c $base_libs
 
 case $platform in
 Unix)
-	$ffihugs '-i"HsBase.h"' System.Posix.Internals $base_includes
-	;;
+  $ffihugs '-i"HsBase.h"' System.Posix.Internals $source/base/cbits/dirUtils.c  $base_includes
+  ;;
 Win32)
-	$ffihugs '-i"HsBase.h"' System.Directory $base_includes $base_libs
-	$ffihugs Distribution.Simple.Utils
-	$ffihugs -98 Distribution.Simple.LocalBuildInfo
-	;;
+  $ffihugs '-i"HsBase.h"' System.Directory $base_includes $base_libs
+  $ffihugs Distribution.Simple.Utils
+  $ffihugs -98 Distribution.Simple.LocalBuildInfo
+  ;;
 esac
diff --git a/packages/Cabal/Distribution/InstalledPackageInfo.hs b/packages/Cabal/Distribution/InstalledPackageInfo.hs
index 624c730..a3ff7e4 100644
--- a/packages/Cabal/Distribution/InstalledPackageInfo.hs
+++ b/packages/Cabal/Distribution/InstalledPackageInfo.hs
@@ -46,24 +46,24 @@ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. -}
 -- This module is meant to be local-only to Distribution...
 
 module Distribution.InstalledPackageInfo (
-	InstalledPackageInfo(..),
-	ParseResult(..),
-	emptyInstalledPackageInfo,
-	parseInstalledPackageInfo,
-	showInstalledPackageInfo,
-	showInstalledPackageInfoField,
+  InstalledPackageInfo(..),
+  ParseResult(..),
+  emptyInstalledPackageInfo,
+  parseInstalledPackageInfo,
+  showInstalledPackageInfo,
+  showInstalledPackageInfoField,
   ) where
 
 import Distribution.ParseUtils (
-	StanzaField(..), singleStanza, ParseResult(..), LineNo,
-	simpleField, listField, parseLicenseQ,
-	parseFilePathQ, parseTokenQ, parseModuleNameQ, parsePackageNameQ,
-	showFilePath, showToken, parseReadS, parseOptVersion, parseQuoted,
-	showFreeText)
+  StanzaField(..), singleStanza, ParseResult(..), LineNo,
+  simpleField, listField, parseLicenseQ,
+  parseFilePathQ, parseTokenQ, parseModuleNameQ, parsePackageNameQ,
+  showFilePath, showToken, parseReadS, parseOptVersion, parseQuoted,
+  showFreeText)
 import Distribution.License 	( License(..) )
 import Distribution.Compiler 	( Opt )
 import Distribution.Package	( PackageIdentifier(..), showPackageId,
-				  parsePackageId )
+          parsePackageId )
 import Distribution.Version	( Version(..), showVersion )
 import Distribution.Compat.ReadP as ReadP
 
@@ -75,26 +75,26 @@ import Text.PrettyPrint
 
 data InstalledPackageInfo
    = InstalledPackageInfo {
-	-- these parts are exactly the same as PackageDescription
-	package           :: PackageIdentifier,
+  -- these parts are exactly the same as PackageDescription
+  package           :: PackageIdentifier,
         license           :: License,
         copyright         :: String,
         maintainer        :: String,
-	author            :: String,
+  author            :: String,
         stability         :: String,
-	homepage          :: String,
-	pkgUrl            :: String,
-	description       :: String,
-	category          :: String,
-	-- these parts are required by an installed package only:
+  homepage          :: String,
+  pkgUrl            :: String,
+  description       :: String,
+  category          :: String,
+  -- these parts are required by an installed package only:
         exposed           :: Bool,
-	exposedModules	  :: [String],
-	hiddenModules     :: [String],
+  exposedModules	  :: [String],
+  hiddenModules     :: [String],
         importDirs        :: [FilePath],  -- contain sources in case of Hugs
         libraryDirs       :: [FilePath],
         hsLibraries       :: [String],
         extraLibraries    :: [String],
-	extraGHCiLibraries:: [String],    -- overrides extraLibraries for GHCi
+  extraGHCiLibraries:: [String],    -- overrides extraLibraries for GHCi
         includeDirs       :: [FilePath],
         includes          :: [String],
         depends           :: [PackageIdentifier],
@@ -103,8 +103,8 @@ data InstalledPackageInfo
         ldOptions	  :: [Opt],
         frameworkDirs     :: [FilePath],
         frameworks	  :: [String],
-	haddockInterfaces :: [FilePath],
-	haddockHTMLs      :: [FilePath]
+  haddockInterfaces :: [FilePath],
+  haddockHTMLs      :: [FilePath]
     }
     deriving (Read, Show)
 
@@ -115,15 +115,15 @@ emptyInstalledPackageInfo
         license           = AllRightsReserved,
         copyright         = "",
         maintainer        = "",
-	author		  = "",
+  author		  = "",
         stability         = "",
-	homepage	  = "",
-	pkgUrl		  = "",
-	description	  = "",
-	category	  = "",
+  homepage	  = "",
+  pkgUrl		  = "",
+  description	  = "",
+  category	  = "",
         exposed           = False,
-	exposedModules	  = [],
-	hiddenModules     = [],
+  exposedModules	  = [],
+  hiddenModules     = [],
         importDirs        = [],
         libraryDirs       = [],
         hsLibraries       = [],
@@ -137,8 +137,8 @@ emptyInstalledPackageInfo
         ldOptions         = [],
         frameworkDirs     = [],
         frameworks        = [],
-	haddockInterfaces = [],
-	haddockHTMLs      = []
+  haddockInterfaces = [],
+  haddockHTMLs      = []
     }
 
 noVersion :: Version
@@ -150,14 +150,14 @@ noVersion = Version{ versionBranch=[], versionTags=[] }
 parseInstalledPackageInfo :: String -> ParseResult InstalledPackageInfo
 parseInstalledPackageInfo inp = do
   stLines <- singleStanza inp
-	-- not interested in stanzas, so just allow blank lines in
-	-- the package info.
+  -- not interested in stanzas, so just allow blank lines in
+  -- the package info.
   foldM (parseBasicStanza fields) emptyInstalledPackageInfo stLines
 
 parseBasicStanza :: [StanzaField a]
-		    -> a
-		    -> (LineNo, String, String)
-		    -> ParseResult a
+        -> a
+        -> (LineNo, String, String)
+        -> ParseResult a
 parseBasicStanza ((StanzaField name _ set):fields) pkg (lineNo, f, val)
   | name == f = set lineNo val pkg
   | otherwise = parseBasicStanza fields pkg (lineNo, f, val)
@@ -171,15 +171,15 @@ showInstalledPackageInfo pkg = render (ppFields fields)
   where
     ppFields [] = empty
     ppFields ((StanzaField name get' _):flds) = 
-	pprField name (get' pkg) $$ ppFields flds
+      pprField name (get' pkg) $$ ppFields flds
 
 showInstalledPackageInfoField
-	:: String
-	-> Maybe (InstalledPackageInfo -> String)
+  :: String
+  -> Maybe (InstalledPackageInfo -> String)
 showInstalledPackageInfoField field
   = case [ (f,get') | (StanzaField f get' _) <- fields, f == field ] of
-	[]      -> Nothing
-	((f,get'):_) -> Just (render . pprField f . get')
+     []      -> Nothing
+     ((f,get'):_) -> Just (render . pprField f . get')
 
 pprField name field = text name <> colon <+> field
 
@@ -229,59 +229,59 @@ basicStanzaFields =
 installedStanzaFields :: [StanzaField InstalledPackageInfo]
 installedStanzaFields = [
    simpleField "exposed"
-	(text.show) 	   parseReadS
-	exposed     	   (\val pkg -> pkg{exposed=val})
+  (text.show) 	   parseReadS
+  exposed     	   (\val pkg -> pkg{exposed=val})
  , listField   "exposed-modules"
-	text               parseModuleNameQ
-	exposedModules     (\xs    pkg -> pkg{exposedModules=xs})
+  text               parseModuleNameQ
+  exposedModules     (\xs    pkg -> pkg{exposedModules=xs})
  , listField   "hidden-modules"
-	text               parseModuleNameQ
-	hiddenModules      (\xs    pkg -> pkg{hiddenModules=xs})
+  text               parseModuleNameQ
+  hiddenModules      (\xs    pkg -> pkg{hiddenModules=xs})
  , listField   "import-dirs"
-	showFilePath       parseFilePathQ
-	importDirs         (\xs pkg -> pkg{importDirs=xs})
+  showFilePath       parseFilePathQ
+  importDirs         (\xs pkg -> pkg{importDirs=xs})
  , listField   "library-dirs"
-	showFilePath       parseFilePathQ
-	libraryDirs        (\xs pkg -> pkg{libraryDirs=xs})
+  showFilePath       parseFilePathQ
+  libraryDirs        (\xs pkg -> pkg{libraryDirs=xs})
  , listField   "hs-libraries"
-	showFilePath       parseTokenQ
-	hsLibraries        (\xs pkg -> pkg{hsLibraries=xs})
+  showFilePath       parseTokenQ
+  hsLibraries        (\xs pkg -> pkg{hsLibraries=xs})
  , listField   "extra-libraries"
-	showToken          parseTokenQ
-	extraLibraries     (\xs pkg -> pkg{extraLibraries=xs})
+  showToken          parseTokenQ
+  extraLibraries     (\xs pkg -> pkg{extraLibraries=xs})
  , listField   "extra-ghci-libraries"
-	showToken          parseTokenQ
-	extraGHCiLibraries (\xs pkg -> pkg{extraGHCiLibraries=xs})
+  showToken          parseTokenQ
+  extraGHCiLibraries (\xs pkg -> pkg{extraGHCiLibraries=xs})
  , listField   "include-dirs"
-	showFilePath       parseFilePathQ
-	includeDirs        (\xs pkg -> pkg{includeDirs=xs})
+  showFilePath       parseFilePathQ
+  includeDirs        (\xs pkg -> pkg{includeDirs=xs})
  , listField   "includes"
-	showFilePath       parseFilePathQ
-	includes           (\xs pkg -> pkg{includes=xs})
+  showFilePath       parseFilePathQ
+  includes           (\xs pkg -> pkg{includes=xs})
  , listField   "depends"
-	(text.showPackageId)  parsePackageId'
-	depends            (\xs pkg -> pkg{depends=xs})
+  (text.showPackageId)  parsePackageId'
+  depends            (\xs pkg -> pkg{depends=xs})
  , listField   "hugs-options"
-	showToken	   parseTokenQ
-	hugsOptions        (\path  pkg -> pkg{hugsOptions=path})
+  showToken	   parseTokenQ
+  hugsOptions        (\path  pkg -> pkg{hugsOptions=path})
  , listField   "cc-options"
-	showToken	   parseTokenQ
-	ccOptions          (\path  pkg -> pkg{ccOptions=path})
+  showToken	   parseTokenQ
+  ccOptions          (\path  pkg -> pkg{ccOptions=path})
  , listField   "ld-options"
-	showToken	   parseTokenQ
-	ldOptions          (\path  pkg -> pkg{ldOptions=path})
+  showToken	   parseTokenQ
+  ldOptions          (\path  pkg -> pkg{ldOptions=path})
  , listField   "framework-dirs"
-	showFilePath       parseFilePathQ
-	frameworkDirs      (\xs pkg -> pkg{frameworkDirs=xs})
+  showFilePath       parseFilePathQ
+  frameworkDirs      (\xs pkg -> pkg{frameworkDirs=xs})
  , listField   "frameworks"
-	showToken          parseTokenQ
-	frameworks         (\xs pkg -> pkg{frameworks=xs})
+  showToken          parseTokenQ
+  frameworks         (\xs pkg -> pkg{frameworks=xs})
  , listField   "haddock-interfaces"
-	showFilePath       parseFilePathQ
-	haddockInterfaces  (\xs pkg -> pkg{haddockInterfaces=xs})
+  showFilePath       parseFilePathQ
+  haddockInterfaces  (\xs pkg -> pkg{haddockInterfaces=xs})
  , listField   "haddock-html"
-	showFilePath       parseFilePathQ
-	haddockHTMLs       (\xs pkg -> pkg{haddockHTMLs=xs})
+  showFilePath       parseFilePathQ
+  haddockHTMLs       (\xs pkg -> pkg{haddockHTMLs=xs})
  ]
 
 parsePackageId' = parseQuoted parsePackageId <++ parsePackageId
diff --git a/packages/Cabal/Distribution/Package.hs b/packages/Cabal/Distribution/Package.hs
index 80e3606..4530ac6 100644
--- a/packages/Cabal/Distribution/Package.hs
+++ b/packages/Cabal/Distribution/Package.hs
@@ -40,8 +40,8 @@ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. -}
 
 module Distribution.Package (
-	PackageIdentifier(..),
-	showPackageId, parsePackageId, parsePackageName,
+  PackageIdentifier(..),
+  showPackageId, parsePackageId, parsePackageName,
   ) where
 
 import Distribution.Version
@@ -51,8 +51,8 @@ import Data.List ( intersperse )
 
 data PackageIdentifier
     = PackageIdentifier {
-	pkgName    :: String,
-	pkgVersion :: Version
+  pkgName    :: String,
+  pkgVersion :: Version
      }
      deriving (Read, Show, Eq, Ord)
 
@@ -65,10 +65,10 @@ parsePackageName :: ReadP r String
 parsePackageName = do ns <- sepBy1 component (char '-')
                       return (concat (intersperse "-" ns))
   where component = do 
-	   cs <- munch1 isAlphaNum
-	   if all isDigit cs then pfail else return cs
-	-- each component must contain an alphabetic character, to avoid
-	-- ambiguity in identifiers like foo-1 (the 1 is the version number).
+         cs <- munch1 isAlphaNum
+         if all isDigit cs then pfail else return cs
+  -- each component must contain an alphabetic character, to avoid
+  -- ambiguity in identifiers like foo-1 (the 1 is the version number).
 
 parsePackageId :: ReadP r PackageIdentifier
 parsePackageId = do 
diff --git a/packages/Cabal/Distribution/ParseUtils.hs b/packages/Cabal/Distribution/ParseUtils.hs
index f62e7f7..aef1c46 100644
--- a/packages/Cabal/Distribution/ParseUtils.hs
+++ b/packages/Cabal/Distribution/ParseUtils.hs
@@ -46,15 +46,15 @@ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. -}
 module Distribution.ParseUtils (
         LineNo, PError(..), PWarning,
         locatedErrorMsg, showError, syntaxError, warning,
-	runP, ParseResult(..),
-	StanzaField(..), splitStanzas, Stanza, singleStanza,
-	parseFilePathQ, parseTokenQ,
-	parseModuleNameQ, parseDependency, parseOptVersion,
-	parsePackageNameQ, parseVersionRangeQ,
-	parseTestedWithQ, parseLicenseQ, parseExtensionQ, parseCommaList, parseOptCommaList,
-	showFilePath, showToken, showTestedWith, showDependency, showFreeText,
-	simpleField, listField, commaListField, optsField, 
-	parseReadS, parseQuoted,
+  runP, ParseResult(..),
+  StanzaField(..), splitStanzas, Stanza, singleStanza,
+  parseFilePathQ, parseTokenQ,
+  parseModuleNameQ, parseDependency, parseOptVersion,
+  parsePackageNameQ, parseVersionRangeQ,
+  parseTestedWithQ, parseLicenseQ, parseExtensionQ, parseCommaList, parseOptCommaList,
+  showFilePath, showToken, showTestedWith, showDependency, showFreeText,
+  simpleField, listField, commaListField, optsField, 
+  parseReadS, parseQuoted,
   ) where
 
 import Text.PrettyPrint.HughesPJ
@@ -83,12 +83,12 @@ data ParseResult a = ParseFailed PError | ParseOk [PWarning] a
         deriving Show
 
 instance Monad ParseResult where
-	return x = ParseOk [] x
-	ParseFailed err >>= _ = ParseFailed err
-	ParseOk ws x >>= f = case f x of
-	                       ParseFailed err -> ParseFailed err
-			       ParseOk ws' x' -> ParseOk (ws'++ws) x'
-	fail s = ParseFailed (FromString s Nothing)
+  return x = ParseOk [] x
+  ParseFailed err >>= _ = ParseFailed err
+  ParseOk ws x >>= f = case f x of
+                         ParseFailed err -> ParseFailed err
+                         ParseOk ws' x' -> ParseOk (ws'++ws) x'
+  fail s = ParseFailed (FromString s Nothing)
 
 runP :: LineNo -> String -> ReadP a a -> String -> ParseResult a
 runP lineNo field p s =
@@ -224,9 +224,9 @@ mkStanza ((n,xs):ys) =
 parseModuleNameQ :: ReadP r String
 parseModuleNameQ = parseQuoted modu <++ modu
  where modu = do 
-	  c <- satisfy isUpper
-	  cs <- munch (\x -> isAlphaNum x || x `elem` "_'.")
-	  return (c:cs)
+        c <- satisfy isUpper
+        cs <- munch (\x -> isAlphaNum x || x `elem` "_'.")
+        return (c:cs)
 
 parseFilePathQ :: ReadP r FilePath
 parseFilePathQ = liftM platformPath parseTokenQ
@@ -250,15 +250,16 @@ parseVersionRangeQ = parseQuoted parseVersionRange <++ parseVersionRange
 parseOptVersion :: ReadP r Version
 parseOptVersion = parseQuoted ver <++ ver
   where ver = parseVersion <++ return noVersion
-	noVersion = Version{ versionBranch=[], versionTags=[] }
+        noVersion = Version{ versionBranch=[], versionTags=[] }
 
 parseTestedWithQ :: ReadP r (CompilerFlavor,VersionRange)
 parseTestedWithQ = parseQuoted tw <++ tw
-  where tw = do compiler <- parseReadS
-		skipSpaces
-		version <- parseVersionRange <++ return AnyVersion
-		skipSpaces
-		return (compiler,version)
+  where tw = do 
+              compiler <- parseReadS
+              skipSpaces
+              version <- parseVersionRange <++ return AnyVersion
+              skipSpaces
+              return (compiler,version)
 
 parseLicenseQ :: ReadP r License
 parseLicenseQ = parseQuoted parseReadS <++ parseReadS
diff --git a/packages/Cabal/Distribution/PreProcess.hs b/packages/Cabal/Distribution/PreProcess.hs
index 75464ae..71b1e48 100644
--- a/packages/Cabal/Distribution/PreProcess.hs
+++ b/packages/Cabal/Distribution/PreProcess.hs
@@ -41,14 +41,14 @@ module Distribution.PreProcess (preprocessSources, knownSuffixHandlers,
                                 ppSuffixes, PPSuffixHandler, PreProcessor,
                                 removePreprocessed, removePreprocessedPackage,
                                 ppCpp, ppCpp', ppGreenCard, ppC2hs, ppHsc2hs,
-				ppHappy, ppAlex, ppUnlit
+        ppHappy, ppAlex, ppUnlit
                                )
     where
 
 import Distribution.PreProcess.Unlit(unlit)
 import Distribution.PackageDescription (setupMessage, PackageDescription(..),
                                         BuildInfo(..), Executable(..), withExe,
-					Library(..), withLib, libModules)
+          Library(..), withLib, libModules)
 import Distribution.Compiler (CompilerFlavor(..), Compiler(..))
 import Distribution.Simple.LocalBuildInfo (LocalBuildInfo(..))
 import Distribution.Simple.Utils (rawSystemVerbose,
@@ -61,7 +61,7 @@ import System.Exit (ExitCode(..))
 import System.Directory (removeFile, getModificationTime)
 import System.Info (os, arch)
 import Distribution.Compat.FilePath
-	(splitFileExt, joinFileName, joinFileExt)
+  (splitFileExt, joinFileName, joinFileExt)
 
 -- |The interface to a preprocessor, which may be implemented using an
 -- external program, but need not be.  The arguments are the name of
@@ -91,17 +91,17 @@ type PPSuffixHandler
 -- |Apply preprocessors to the sources from 'hsSourceDirs', to obtain
 -- a Haskell source file for each module.
 preprocessSources :: PackageDescription 
-		  -> LocalBuildInfo 
-		  -> Int                -- ^ verbose
+      -> LocalBuildInfo 
+      -> Int                -- ^ verbose
                   -> [PPSuffixHandler]  -- ^ preprocessors to try
-		  -> IO ()
+      -> IO ()
 
 preprocessSources pkg_descr lbi verbose handlers = do
     withLib pkg_descr () $ \ lib -> do
         setupMessage "Preprocessing library" pkg_descr
         let bi = libBuildInfo lib
-	let biHandlers = localHandlers bi
-	sequence_ [do retVal <- preprocessModule (hsSourceDirs bi) modu
+        let biHandlers = localHandlers bi
+        sequence_ [do retVal <- preprocessModule (hsSourceDirs bi) modu
                                                  verbose builtinSuffixes biHandlers
                       unless (retVal == ExitSuccess)
                              (die $ "got error code while preprocessing: " ++ modu)
@@ -110,18 +110,18 @@ preprocessSources pkg_descr lbi verbose handlers = do
         setupMessage "Preprocessing executables for" pkg_descr
     withExe pkg_descr $ \ theExe -> do
         let bi = buildInfo theExe
-	let biHandlers = localHandlers bi
-	sequence_ [do retVal <- preprocessModule (nub $ (hsSourceDirs bi)
+        let biHandlers = localHandlers bi
+        sequence_ [do retVal <- preprocessModule (nub $ (hsSourceDirs bi)
                                      ++(maybe [] (hsSourceDirs . libBuildInfo) (library pkg_descr)))
                                      modu verbose builtinSuffixes biHandlers
                       unless (retVal == ExitSuccess)
                              (die $ "got error code while preprocessing: " ++ modu)
                    | modu <- otherModules bi]
   where hc = compilerFlavor (compiler lbi)
-	builtinSuffixes
-	  | hc == NHC = ["hs", "lhs", "gc"]
-	  | otherwise = ["hs", "lhs"]
-	localHandlers bi = [(ext, h bi lbi) | (ext, h) <- handlers]
+        builtinSuffixes
+          | hc == NHC = ["hs", "lhs", "gc"]
+          | otherwise = ["hs", "lhs"]
+        localHandlers bi = [(ext, h bi lbi) | (ext, h) <- handlers]
 
 -- |Find the first extension of the file that exists, and preprocess it
 -- if required.
@@ -136,22 +136,22 @@ preprocessModule searchLoc modu verbose builtinSuffixes handlers = do
     bsrcFiles <- moduleToFilePath searchLoc modu builtinSuffixes
     psrcFiles <- moduleToFilePath searchLoc modu (map fst handlers)
     case psrcFiles of
-	[] -> case bsrcFiles of
-	          [] -> die ("can't find source for " ++ modu ++ " in " ++ show searchLoc)
-	          _  -> return ExitSuccess
-	(psrcFile:_) -> do
-	    let (srcStem, ext) = splitFileExt psrcFile
-	        pp = fromMaybe (error "Internal error in preProcess module: Just expected")
-	                       (lookup ext handlers)
-	    recomp <- case bsrcFiles of
-	                  [] -> return True
-	                  (bsrcFile:_) -> do
-	                      btime <- getModificationTime bsrcFile
-	                      ptime <- getModificationTime psrcFile
-	                      return (btime < ptime)
-	    if recomp
-	      then pp psrcFile (srcStem `joinFileExt` "hs") verbose
-	      else return ExitSuccess
+     [] -> case bsrcFiles of
+               [] -> die ("can't find source for " ++ modu ++ " in " ++ show searchLoc)
+               _  -> return ExitSuccess
+     (psrcFile:_) -> do
+         let (srcStem, ext) = splitFileExt psrcFile
+             pp = fromMaybe (error "Internal error in preProcess module: Just expected")
+                            (lookup ext handlers)
+         recomp <- case bsrcFiles of
+                       [] -> return True
+                       (bsrcFile:_) -> do
+                           btime <- getModificationTime bsrcFile
+                           ptime <- getModificationTime psrcFile
+                           return (btime < ptime)
+         if recomp
+           then pp psrcFile (srcStem `joinFileExt` "hs") verbose
+           else return ExitSuccess
 
 removePreprocessedPackage :: PackageDescription
                           -> FilePath -- ^root of source tree (where to look for hsSources)
@@ -173,12 +173,12 @@ removePreprocessed :: [FilePath] -- ^search Location
 removePreprocessed searchLocs mods suffixesIn
     = mapM_ removePreprocessedModule mods
   where removePreprocessedModule m = do
-	    -- collect related files
-	    fs <- moduleToFilePath searchLocs m otherSuffixes
-	    -- does M.hs also exist?
-	    hs <- moduleToFilePath searchLocs m ["hs"]
-	    unless (null fs) (mapM_ removeFile hs)
-	otherSuffixes = filter (/= "hs") suffixesIn
+            -- collect related files
+            fs <- moduleToFilePath searchLocs m otherSuffixes
+            -- does M.hs also exist?
+            hs <- moduleToFilePath searchLocs m ["hs"]
+            unless (null fs) (mapM_ removeFile hs)
+        otherSuffixes = filter (/= "hs") suffixesIn
 
 -- ------------------------------------------------------------
 -- * known preprocessors
@@ -211,12 +211,12 @@ ppCpp' inputArgs bi lbi =
      Nothing | compilerFlavor hc == GHC -> use_ghc
      _otherwise                         -> ppNone "cpphs (or GHC)"
   where 
-	hc = compiler lbi
-
-	use_cpphs cpphs inFile outFile verbose
-	  = rawSystemVerbose verbose cpphs cpphsArgs
-	  where cpphsArgs = ("-O"++outFile) : inFile : "--noline" : "--strip"
-				 : extraArgs
+        hc = compiler lbi
+      
+        use_cpphs cpphs inFile outFile verbose
+          = rawSystemVerbose verbose cpphs cpphsArgs
+          where cpphsArgs = ("-O"++outFile) : inFile : "--noline" : "--strip"
+                 : extraArgs
 
         extraArgs = sysDefines ++ cppOptions bi lbi ++ inputArgs
 
@@ -225,9 +225,9 @@ ppCpp' inputArgs bi lbi =
                 ["-D" ++ arch ++ "_" ++ loc ++ "_ARCH" | loc <- locations]
         locations = ["BUILD", "HOST"]
 
-	use_ghc inFile outFile verbose
-	  = rawSystemVerbose verbose (compilerPath hc) 
-		(["-E", "-cpp", "-optP-P", "-o", outFile, inFile] ++ extraArgs)
+        use_ghc inFile outFile verbose
+          = rawSystemVerbose verbose (compilerPath hc) 
+          (["-E", "-cpp", "-optP-P", "-o", outFile, inFile] ++ extraArgs)
 
 ppHsc2hs :: BuildInfo -> LocalBuildInfo -> PreProcessor
 ppHsc2hs bi lbi
@@ -272,16 +272,16 @@ ppHappy _ lbi
     = maybe (ppNone "happy") pp (withHappy lbi)
   where pp n = standardPP n (hcFlags hc)
         hc = compilerFlavor (compiler lbi)
-	hcFlags GHC = ["-agc"]
-	hcFlags _ = []
+        hcFlags GHC = ["-agc"]
+        hcFlags _ = []
 
 ppAlex :: BuildInfo -> LocalBuildInfo -> PreProcessor
 ppAlex _ lbi
     = maybe (ppNone "alex") pp (withAlex lbi)
   where pp n = standardPP n (hcFlags hc)
         hc = compilerFlavor (compiler lbi)
-	hcFlags GHC = ["-g"]
-	hcFlags _ = []
+        hcFlags GHC = ["-g"]
+        hcFlags _ = []
 
 standardPP :: String -> [String] -> PreProcessor
 standardPP eName args inFile outFile verbose
diff --git a/packages/Cabal/Distribution/PreProcess/Unlit.hs b/packages/Cabal/Distribution/PreProcess/Unlit.hs
index 60f01b7..9c3cacf 100644
--- a/packages/Cabal/Distribution/PreProcess/Unlit.hs
+++ b/packages/Cabal/Distribution/PreProcess/Unlit.hs
@@ -29,15 +29,15 @@ plain _ hs = hs
 ----
 
 data Classified = Program String | Blank | Comment
-		| Include Int String | Pre String
+      | Include Int String | Pre String
 
 classify :: Int -> [String] -> [Classified]
 classify _ []                = []
 classify _ (('\\':x):xs) | x == "begin{code}" = Blank : allProg xs
    where allProg [] = []	-- Should give an error message, but I have no
-				-- good position information.
+            -- good position information.
          allProg (('\\':x'):xs') |  x' == "end{code}" = Blank : classify 0 xs'
-	 allProg (x':xs') = Program x':allProg xs'
+         allProg (x':xs') = Program x':allProg xs'
 classify 0 (('>':x):xs)  = let (sp,code) = span isSpace x in
                            Program code : classify (length sp + 1) xs
 classify n (('>':x):xs)  = Program (drop (n-1) x) : classify n xs
@@ -58,13 +58,13 @@ unclassify Comment     = ""
 
 adjacent :: String -> Int -> Classified -> [Classified] -> [Classified]
 adjacent file 0 _             (x              :xs) = x: adjacent file 1 x xs
-					-- force evaluation of line number
+               -- force evaluation of line number
 adjacent file n   (Program _) (Comment      :_) =
-				error (message file n "program" "comment")
+            error (message file n "program" "comment")
 adjacent _    _ y@(Program _) (x@(Include i f):xs) = x: adjacent f    i     y xs
 adjacent file n y@(Program _) (x@(Pre _)      :xs) = x: adjacent file (n+1) y xs
 adjacent file n    Comment    ((Program _)  :_) =
-				error (message file n "comment" "program")
+            error (message file n "comment" "program")
 adjacent _    _ y@Comment     (x@(Include i f):xs) = x: adjacent f    i     y xs
 adjacent file n y@Comment     (x@(Pre _)      :xs) = x: adjacent file (n+1) y xs
 adjacent _    _ y@Blank       (x@(Include i f):xs) = x: adjacent f    i     y xs
diff --git a/packages/Cabal/Distribution/Setup.hs b/packages/Cabal/Distribution/Setup.hs
index 5bfdeaf..67d50f0 100644
--- a/packages/Cabal/Distribution/Setup.hs
+++ b/packages/Cabal/Distribution/Setup.hs
@@ -46,13 +46,13 @@ module Distribution.Setup (--parseArgs,
                            Action(..),
                            ConfigFlags(..), emptyConfigFlags, configureArgs,
                            CopyFlags(..), CopyDest(..), 
-			   InstallFlags(..), emptyInstallFlags,
+         InstallFlags(..), emptyInstallFlags,
                            HaddockFlags(..), emptyHaddockFlags,
                            BuildFlags(..), CleanFlags(..), PFEFlags(..),
                            RegisterFlags(..), emptyRegisterFlags,
-			   SDistFlags(..),
+         SDistFlags(..),
                            MaybeUserFlag(..), userOverride,
-			   --optionHelpString,
+         --optionHelpString,
 #ifdef DEBUG
                            hunitTests,
 #endif
@@ -95,7 +95,7 @@ data Action = ConfigCmd ConfigFlags   -- config
             | TestCmd                 -- test
             | RegisterCmd    	      -- register
             | UnregisterCmd           -- unregister
-	    | HelpCmd		      -- help
+      | HelpCmd		      -- help
 --            | NoCmd -- error case, help case.
 --             | TestCmd 1.0?
 --             | BDist -- 1.0
@@ -122,24 +122,24 @@ data ConfigFlags = ConfigFlags {
         configProfLib  :: Bool,           -- ^Enable profiling in the library
         configProfExe  :: Bool,           -- ^Enable profiling in the executables.
         configPrefix   :: Maybe FilePath,
-		-- ^installation prefix
-	configBinDir   :: Maybe FilePath, 
-		-- ^installation dir for binaries,
-	configLibDir   :: Maybe FilePath, 
-		-- ^installation dir for object code libraries, 
-	configLibSubDir :: Maybe FilePath,
-		-- ^subdirectory of libdir in which libs are installed
-	configLibExecDir :: Maybe FilePath,
-		-- ^installation dir for program executables,
-	configDataDir  :: Maybe FilePath,
-		-- ^installation dir for read-only arch-independent data,
-	configDataSubDir :: Maybe FilePath,
-		-- ^subdirectory of datadir in which data files are installed
+    -- ^installation prefix
+  configBinDir   :: Maybe FilePath, 
+    -- ^installation dir for binaries,
+  configLibDir   :: Maybe FilePath, 
+    -- ^installation dir for object code libraries, 
+  configLibSubDir :: Maybe FilePath,
+    -- ^subdirectory of libdir in which libs are installed
+  configLibExecDir :: Maybe FilePath,
+    -- ^installation dir for program executables,
+  configDataDir  :: Maybe FilePath,
+    -- ^installation dir for read-only arch-independent data,
+  configDataSubDir :: Maybe FilePath,
+    -- ^subdirectory of datadir in which data files are installed
 
         configVerbose  :: Int,            -- ^verbosity level
-	configUser     :: Bool,		  -- ^--user flag?
-	configGHCiLib  :: Bool,           -- ^Enable compiling library for GHCi
-	configSplitObjs :: Bool		  -- ^Enable -split-objs with GHC
+  configUser     :: Bool,		  -- ^--user flag?
+  configGHCiLib  :: Bool,           -- ^Enable compiling library for GHCi
+  configSplitObjs :: Bool		  -- ^Enable -split-objs with GHC
     }
 
 emptyConfigFlags :: ProgramConfiguration -> ConfigFlags
@@ -159,16 +159,16 @@ emptyConfigFlags progConf = ConfigFlags {
         configCpphs    = Nothing,
         configGreencard= Nothing,
         configPrefix   = Nothing,
-	configBinDir   = Nothing,
-	configLibDir   = Nothing,
-	configLibSubDir = Nothing,
-	configLibExecDir = Nothing,
-	configDataDir  = Nothing,
-	configDataSubDir = Nothing,
+  configBinDir   = Nothing,
+  configLibDir   = Nothing,
+  configLibSubDir = Nothing,
+  configLibExecDir = Nothing,
+  configDataDir  = Nothing,
+  configDataSubDir = Nothing,
         configVerbose  = 0,
-	configUser     = False,
-	configGHCiLib  = True,
-	configSplitObjs = False -- takes longer, so turn off by default
+  configUser     = False,
+  configGHCiLib  = True,
+  configSplitObjs = False -- takes longer, so turn off by default
     }
 
 -- | Flags to @copy@: (destdir, copy-prefix (backwards compat), verbose)
@@ -197,7 +197,7 @@ data InstallFlags = InstallFlags {installUserFlags::MaybeUserFlag
 
 emptyInstallFlags :: InstallFlags
 emptyInstallFlags = InstallFlags{ installUserFlags=MaybeUserNone,
-				  installVerbose=0 }
+          installVerbose=0 }
 
 -- | Flags to @sdist@: (snapshot, verbose)
 data SDistFlags = SDistFlags {sDistSnapshot::Bool
@@ -207,17 +207,17 @@ data SDistFlags = SDistFlags {sDistSnapshot::Bool
 -- in-place, verbose)
 data RegisterFlags = RegisterFlags {regUser::MaybeUserFlag
                                    ,regGenScript::Bool
-				   ,regInPlace::Bool
-				   ,regWithHcPkg::Maybe FilePath
+           ,regInPlace::Bool
+           ,regWithHcPkg::Maybe FilePath
                                    ,regVerbose::Int}
 
 
 emptyRegisterFlags :: RegisterFlags
 emptyRegisterFlags = RegisterFlags { regUser=MaybeUserNone,
-				     regGenScript=False,
-				     regInPlace=False,
-				     regWithHcPkg=Nothing,
-				     regVerbose=0 }
+             regGenScript=False,
+             regInPlace=False,
+             regWithHcPkg=Nothing,
+             regVerbose=0 }
 
 data HaddockFlags = HaddockFlags {haddockHoogle :: Bool
                                  ,haddockVerbose :: Int}
@@ -240,16 +240,16 @@ data Flag a = GhcFlag | NhcFlag | HugsFlag | JhcFlag
           | WithVanillaLib | WithoutVanillaLib
           | WithProfLib | WithoutProfLib
           | WithProfExe | WithoutProfExe
-	  | WithGHCiLib | WithoutGHCiLib
-	  | WithSplitObjs | WithoutSplitObjs
+    | WithGHCiLib | WithoutGHCiLib
+    | WithSplitObjs | WithoutSplitObjs
 
-	  | Prefix FilePath
-	  | BinDir FilePath
-	  | LibDir FilePath
-	  | LibSubDir FilePath
-	  | LibExecDir FilePath
-	  | DataDir FilePath
-	  | DataSubDir FilePath
+    | Prefix FilePath
+    | BinDir FilePath
+    | LibDir FilePath
+    | LibSubDir FilePath
+    | LibExecDir FilePath
+    | DataDir FilePath
+    | DataSubDir FilePath
 
           | ProgramArgs String String   -- program name, arguments
           | WithProgram String FilePath -- program name, location
@@ -258,10 +258,10 @@ data Flag a = GhcFlag | NhcFlag | HugsFlag | JhcFlag
           | UserFlag | GlobalFlag
           -- for register & unregister
           | GenScriptFlag
-	  | InPlaceFlag
+    | InPlaceFlag
           -- For copy:
           | InstPrefix FilePath
-	  | DestDir FilePath
+    | DestDir FilePath
           -- For sdist:
           | Snapshot
           -- For haddock:
@@ -414,21 +414,21 @@ configureCmd progConf = Cmd {
            Option "" ["hugs"] (NoArg HugsFlag) "compile with hugs",
            Option "w" ["with-compiler"] (reqPathArg WithCompiler)
                "give the path to a particular compiler",
-	   cmd_with_hc_pkg,
+     cmd_with_hc_pkg,
            Option "" ["prefix"] (reqDirArg Prefix)
                "bake this prefix in preparation of installation",
-	   Option "" ["bindir"] (reqDirArg BinDir)
-		"installation directory for executables",
-	   Option "" ["libdir"] (reqDirArg LibDir)
-		"installation directory for libraries",
-	   Option "" ["libsubdir"] (reqDirArg LibSubDir)
-		"subdirectory of libdir in which libs are installed",
-	   Option "" ["libexecdir"] (reqDirArg LibExecDir)
-		"installation directory for program executables",
-	   Option "" ["datadir"] (reqDirArg DataDir)
-		"installation directory for read-only data",
-	   Option "" ["datasubdir"] (reqDirArg DataSubDir)
-		"subdirectory of datadir in which data files are installed",
+     Option "" ["bindir"] (reqDirArg BinDir)
+    "installation directory for executables",
+     Option "" ["libdir"] (reqDirArg LibDir)
+    "installation directory for libraries",
+     Option "" ["libsubdir"] (reqDirArg LibSubDir)
+    "subdirectory of libdir in which libs are installed",
+     Option "" ["libexecdir"] (reqDirArg LibExecDir)
+    "installation directory for program executables",
+     Option "" ["datadir"] (reqDirArg DataDir)
+    "installation directory for read-only data",
+     Option "" ["datasubdir"] (reqDirArg DataSubDir)
+    "subdirectory of datadir in which data files are installed",
            Option "" ["with-happy"] (reqPathArg WithHappy)
                "give the path to happy",
            Option "" ["with-alex"] (reqPathArg WithAlex)
@@ -453,14 +453,14 @@ configureCmd progConf = Cmd {
                "Enable executable profiling",
            Option "" ["disable-executable-profiling"] (NoArg WithoutProfExe)
                "Disable executable profiling",
-	   Option "" ["enable-library-for-ghci"] (NoArg WithGHCiLib)
+     Option "" ["enable-library-for-ghci"] (NoArg WithGHCiLib)
                "compile library for use with GHCi",
-	   Option "" ["disable-library-for-ghci"] (NoArg WithoutGHCiLib)
+     Option "" ["disable-library-for-ghci"] (NoArg WithoutGHCiLib)
                "do not compile libraries for GHCi",
-	   Option "" ["enable-split-objs"] (NoArg WithSplitObjs)
-	       "split library into smaller objects to reduce binary sizes (GHC 6.6+)",
-	   Option "" ["disable-split-objs"] (NoArg WithoutSplitObjs)
-	       "split library into smaller objects to reduce binary sizes (GHC 6.6+)",
+     Option "" ["enable-split-objs"] (NoArg WithSplitObjs)
+         "split library into smaller objects to reduce binary sizes (GHC 6.6+)",
+     Option "" ["disable-split-objs"] (NoArg WithoutSplitObjs)
+         "split library into smaller objects to reduce binary sizes (GHC 6.6+)",
            Option "" ["user"] (NoArg UserFlag)
                "allow dependencies to be satisfied from the user package database. also implies install --user",
            Option "" ["global"] (NoArg GlobalFlag)
@@ -521,8 +521,8 @@ parseConfigureArgs progConf = parseArgs (configureCmd progConf) updateCfg
         updateCfg t WithoutProfLib       = t { configProfLib  = False }
         updateCfg t WithProfExe          = t { configProfExe  = True }
         updateCfg t WithoutProfExe       = t { configProfExe  = False }
-	updateCfg t WithGHCiLib          = t { configGHCiLib  = True }
-	updateCfg t WithoutGHCiLib       = t { configGHCiLib  = False }
+        updateCfg t WithGHCiLib          = t { configGHCiLib  = True }
+        updateCfg t WithoutGHCiLib       = t { configGHCiLib  = False }
         updateCfg t (Prefix path)        = t { configPrefix   = Just path }
         updateCfg t (BinDir path)        = t { configBinDir   = Just path }
         updateCfg t (LibDir path)        = t { configLibDir   = Just path }
@@ -533,8 +533,8 @@ parseConfigureArgs progConf = parseArgs (configureCmd progConf) updateCfg
         updateCfg t (Verbose n)          = t { configVerbose  = n }
         updateCfg t UserFlag             = t { configUser     = True }
         updateCfg t GlobalFlag           = t { configUser     = False }
-	updateCfg t WithSplitObjs	 = t { configSplitObjs = True }
-	updateCfg t WithoutSplitObjs	 = t { configSplitObjs = False }
+        updateCfg t WithSplitObjs	 = t { configSplitObjs = True }
+        updateCfg t WithoutSplitObjs	 = t { configSplitObjs = False }
         updateCfg t (Lift _)             = t
         updateCfg t _                    = error $ "Unexpected flag!"
 
@@ -626,7 +626,7 @@ parseCopyArgs :: CopyFlags -> [String] -> [OptDescr a] ->
 parseCopyArgs = parseArgs copyCmd updateCfg
   where updateCfg (CopyFlags copydest verbose) fl = case fl of
             InstPrefix path -> (CopyFlags (CopyPrefix path) verbose)
-	    DestDir path    -> (CopyFlags (CopyTo path) verbose)
+            DestDir path    -> (CopyFlags (CopyTo path) verbose)
             Verbose n       -> (CopyFlags copydest n)
             _               -> error $ "Unexpected flag!"
 
@@ -686,7 +686,7 @@ registerCmd = Cmd {
                "register the package in the build location, so it can be used without being installed",
            Option "" ["gen-script"] (NoArg GenScriptFlag)
                "Instead of performing the register command, generate a script to register later",
-	   cmd_with_hc_pkg
+     cmd_with_hc_pkg
            ],
         cmdAction      = RegisterCmd
         }
@@ -699,8 +699,8 @@ parseRegisterArgs = parseArgs registerCmd updateCfg
             GlobalFlag      -> reg { regUser=MaybeUserGlobal }
             Verbose n       -> reg { regVerbose=n }
             GenScriptFlag   -> reg { regGenScript=True }
-	    InPlaceFlag     -> reg { regInPlace=True }
-	    WithHcPkg f	    -> reg { regWithHcPkg=Just f }
+            InPlaceFlag     -> reg { regInPlace=True }
+            WithHcPkg f	    -> reg { regWithHcPkg=Just f }
             _               -> error $ "Unexpected flag!"
 
 unregisterCmd :: Cmd a
diff --git a/packages/Cabal/Distribution/Simple.hs b/packages/Cabal/Distribution/Simple.hs
index 5e47801..e6f8d53 100644
--- a/packages/Cabal/Distribution/Simple.hs
+++ b/packages/Cabal/Distribution/Simple.hs
@@ -48,13 +48,13 @@ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. -}
 
 module Distribution.Simple (
-	module Distribution.Package,
-	module Distribution.Version,
-	module Distribution.License,
-	module Distribution.Compiler,
-	module Language.Haskell.Extension,
+    module Distribution.Package,
+    module Distribution.Version,
+    module Distribution.License,
+    module Distribution.Compiler,
+    module Language.Haskell.Extension,
         -- * Simple interface
-	defaultMain, defaultMainNoRead, defaultMainArgs,
+    defaultMain, defaultMainNoRead, defaultMainArgs,
         -- * Customization
         UserHooks(..), Args,
         defaultMainWithHooks, defaultUserHooks, emptyUserHooks,
@@ -277,20 +277,20 @@ defaultMainWorker pkg_descr_in action args hooks
     = do case action of
             ConfigCmd flags -> do
                 (flags, optFns, args) <-
-			parseConfigureArgs (allPrograms hooks) flags args [buildDirOpt]
+                    parseConfigureArgs (allPrograms hooks) flags args [buildDirOpt]
                 pkg_descr <- hookOrInArgs preConf args flags
                 (warns, ers) <- sanityCheckPackage pkg_descr
                 errorOut warns ers
 
                 let c = maybe (confHook defaultUserHooks) confHook hooks
-		localbuildinfo <- c pkg_descr flags
-		writePersistBuildConfig (foldr id localbuildinfo optFns)
+                localbuildinfo <- c pkg_descr flags
+                writePersistBuildConfig (foldr id localbuildinfo optFns)
                 postHook postConf args flags pkg_descr localbuildinfo
 
             BuildCmd -> do
                 (flags, _, args) <- parseBuildArgs args []
                 pkg_descr <- hookOrInArgs preBuild args flags
-		localbuildinfo <- getPersistBuildConfig
+                localbuildinfo <- getPersistBuildConfig
 
                 cmdHook buildHook pkg_descr localbuildinfo flags
                 postHook postBuild args flags pkg_descr localbuildinfo
@@ -298,7 +298,7 @@ defaultMainWorker pkg_descr_in action args hooks
             HaddockCmd -> do
                 (verbose, _, args) <- parseHaddockArgs emptyHaddockFlags args []
                 pkg_descr <- hookOrInArgs preHaddock args verbose
-		localbuildinfo <- getPersistBuildConfig
+                localbuildinfo <- getPersistBuildConfig
 
                 cmdHook haddockHook pkg_descr localbuildinfo verbose
                 postHook postHaddock args verbose pkg_descr localbuildinfo
@@ -314,7 +314,7 @@ defaultMainWorker pkg_descr_in action args hooks
             CleanCmd -> do
                 (verbose,_, args) <- parseCleanArgs args []
                 pkg_descr <- hookOrInArgs preClean args verbose
-		maybeLocalbuildinfo <- maybeGetPersistBuildConfig
+                maybeLocalbuildinfo <- maybeGetPersistBuildConfig
 
                 cmdHook cleanHook pkg_descr maybeLocalbuildinfo verbose
                 postHook postClean args verbose pkg_descr maybeLocalbuildinfo
@@ -322,7 +322,7 @@ defaultMainWorker pkg_descr_in action args hooks
             CopyCmd mprefix -> do
                 (flags, _, args) <- parseCopyArgs (CopyFlags mprefix 0) args []
                 pkg_descr <- hookOrInArgs preCopy args flags
-		localbuildinfo <- getPersistBuildConfig
+                localbuildinfo <- getPersistBuildConfig
 
                 cmdHook copyHook pkg_descr localbuildinfo flags
                 postHook postCopy args flags pkg_descr localbuildinfo
@@ -330,7 +330,7 @@ defaultMainWorker pkg_descr_in action args hooks
             InstallCmd -> do
                 (flags, _, args) <- parseInstallArgs emptyInstallFlags args []
                 pkg_descr <- hookOrInArgs preInst args flags
-		localbuildinfo <- getPersistBuildConfig
+                localbuildinfo <- getPersistBuildConfig
 
                 cmdHook instHook pkg_descr localbuildinfo flags
                 postHook postInst args flags pkg_descr localbuildinfo
@@ -347,15 +347,16 @@ defaultMainWorker pkg_descr_in action args hooks
                 (verbose,_, args) <- parseTestArgs args []
                 case hooks of
                  Nothing -> return ExitSuccess
-                 Just h  -> do localbuildinfo <- getPersistBuildConfig
-                               out <- (runTests h) args False pkg_descr_in localbuildinfo
-                               when (isFailure out) (exitWith out)
-                               return out
+                 Just h  -> do 
+                    localbuildinfo <- getPersistBuildConfig
+                    out <- (runTests h) args False pkg_descr_in localbuildinfo
+                    when (isFailure out) (exitWith out)
+                    return out
 
             RegisterCmd  -> do
                 (flags, _, args) <- parseRegisterArgs emptyRegisterFlags args []
                 pkg_descr <- hookOrInArgs preReg args flags
-		localbuildinfo <- getPersistBuildConfig
+                localbuildinfo <- getPersistBuildConfig
 
                 cmdHook regHook pkg_descr localbuildinfo flags 
                 postHook postReg args flags pkg_descr localbuildinfo
@@ -363,7 +364,7 @@ defaultMainWorker pkg_descr_in action args hooks
             UnregisterCmd -> do
                 (flags,_, args) <- parseUnregisterArgs emptyRegisterFlags args []
                 pkg_descr <- hookOrInArgs preUnreg args flags
-		localbuildinfo <- getPersistBuildConfig
+                localbuildinfo <- getPersistBuildConfig
 
                 cmdHook unregHook pkg_descr localbuildinfo flags
                 postHook postUnreg args flags pkg_descr localbuildinfo
@@ -377,8 +378,9 @@ defaultMainWorker pkg_descr_in action args hooks
         hookOrInArgs f a i
                  = case hooks of
                     Nothing -> no_extra_flags a >> return pkg_descr_in
-                    Just h -> do pbi <- f h a i
-                                 return (updatePackageDescription pbi pkg_descr_in)
+                    Just h -> do 
+                        pbi <- f h a i
+                        return (updatePackageDescription pbi pkg_descr_in)
         cmdHook f desc lbi = (maybe (f defaultUserHooks) f hooks) desc lbi hooks
         postHook f args flags pkg_descr localbuildinfo
                  = case hooks of
@@ -549,7 +551,7 @@ no_extra_flags extra_flags  =
 
 buildDirOpt :: OptDescr (LocalBuildInfo -> LocalBuildInfo)
 buildDirOpt = Option "b" ["scratchdir"] (reqDirArg setBuildDir)
-		"directory to receive the built package [dist/build]"
+        "directory to receive the built package [dist/build]"
   where setBuildDir dir lbi = lbi { buildDir = dir }
 
 -- |Empty 'UserHooks' which do nothing.
@@ -661,7 +663,7 @@ defaultUserHooks
                       readHookedBuildInfo infoFile
 
 defaultInstallHook :: PackageDescription -> LocalBuildInfo
-	-> Maybe UserHooks ->InstallFlags -> IO ()
+    -> Maybe UserHooks ->InstallFlags -> IO ()
 defaultInstallHook pkg_descr localbuildinfo _ (InstallFlags uInstFlag verbose) = do
   install pkg_descr localbuildinfo (CopyFlags NoCopyDest verbose)
   when (hasLibs pkg_descr) $
@@ -669,14 +671,14 @@ defaultInstallHook pkg_descr localbuildinfo _ (InstallFlags uInstFlag verbose) =
            emptyRegisterFlags{ regUser=uInstFlag, regVerbose=verbose }
 
 defaultBuildHook :: PackageDescription -> LocalBuildInfo
-	-> Maybe UserHooks -> BuildFlags -> IO ()
+    -> Maybe UserHooks -> BuildFlags -> IO ()
 defaultBuildHook pkg_descr localbuildinfo hooks flags = do
   build pkg_descr localbuildinfo flags (allSuffixHandlers hooks)
   when (hasLibs pkg_descr) $
       writeInstalledConfig pkg_descr localbuildinfo False
 
 defaultRegHook :: PackageDescription -> LocalBuildInfo
-	-> Maybe UserHooks -> RegisterFlags -> IO ()
+    -> Maybe UserHooks -> RegisterFlags -> IO ()
 defaultRegHook pkg_descr localbuildinfo _ flags =
     if hasLibs pkg_descr
     then register pkg_descr localbuildinfo flags
diff --git a/packages/Cabal/Distribution/Simple/Build.hs b/packages/Cabal/Distribution/Simple/Build.hs
index 6433c81..3cb8408 100644
--- a/packages/Cabal/Distribution/Simple/Build.hs
+++ b/packages/Cabal/Distribution/Simple/Build.hs
@@ -41,7 +41,7 @@ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. -}
 
 module Distribution.Simple.Build (
-	build
+  build
 #ifdef DEBUG        
         ,hunitTests
 #endif
@@ -49,24 +49,24 @@ module Distribution.Simple.Build (
 
 import Distribution.Compiler	( Compiler(..), CompilerFlavor(..) )
 import Distribution.PackageDescription 
-				( PackageDescription(..), BuildInfo(..),
-				  setupMessage, Executable(..), Library(..), 
+        ( PackageDescription(..), BuildInfo(..),
+          setupMessage, Executable(..), Library(..), 
                                   autogenModuleName )
 import Distribution.Package 	( PackageIdentifier(..), showPackageId )
 import Distribution.Setup	 (CopyDest(..), BuildFlags(..) )
 import Distribution.PreProcess  ( preprocessSources, PPSuffixHandler )
 import Distribution.Simple.LocalBuildInfo
-				( LocalBuildInfo(..), mkBinDir, mkBinDirRel,
-				  mkLibDir, mkLibDirRel, mkDataDir,mkDataDirRel,
-				  mkLibexecDir, mkLibexecDirRel )
+        ( LocalBuildInfo(..), mkBinDir, mkBinDirRel,
+          mkLibDir, mkLibDirRel, mkDataDir,mkDataDirRel,
+          mkLibexecDir, mkLibexecDirRel )
 import Distribution.Simple.Configure
-				( localBuildInfoFile )
+        ( localBuildInfoFile )
 import Distribution.Simple.Utils( die )
 
 import Distribution.Compat.Directory
-				( createDirectoryIfMissing )
+        ( createDirectoryIfMissing )
 import Distribution.Compat.FilePath
-				( joinFileName, pathSeparator )
+        ( joinFileName, pathSeparator )
 
 import Data.Maybe		( maybeToList, fromJust )
 import Control.Monad 		( unless )
@@ -127,97 +127,98 @@ autogenModulesDir lbi = buildDir lbi `joinFileName` "autogen"
 buildPathsModule :: PackageDescription -> LocalBuildInfo -> IO ()
 buildPathsModule pkg_descr lbi =
    let pragmas
-	| absolute = ""
-	| otherwise =
-	  "{-# OPTIONS_GHC -fffi #-}\n"++
-	  "{-# LANGUAGE ForeignFunctionInterface #-}\n"
+        | absolute = ""
+        | otherwise =
+          "{-# OPTIONS_GHC -fffi #-}\n"++
+          "{-# LANGUAGE ForeignFunctionInterface #-}\n"
 
        foreign_imports
-	| absolute = ""
-	| otherwise =
-	  "import Foreign\n"++
-	  "import Foreign.C\n"++
-	  "import Data.Maybe\n"
-
+         | absolute = ""
+         | otherwise =
+           "import Foreign\n"++
+           "import Foreign.C\n"++
+           "import Data.Maybe\n"
+ 
        header =
-	pragmas++
-	"module " ++ paths_modulename ++ " (\n"++
-	"\tversion,\n"++
-	"\tgetBinDir, getLibDir, getDataDir, getLibexecDir,\n"++
-	"\tgetDataFileName\n"++
-	"\t) where\n"++
-	"\n"++
-	foreign_imports++
-	"import Data.Version"++
-	"\n"++
-	"\nversion = " ++ show (pkgVersion (package pkg_descr))++
-	"\n"
-
+         pragmas++
+         "module " ++ paths_modulename ++ " (\n"++
+         "\tversion,\n"++
+         "\tgetBinDir, getLibDir, getDataDir, getLibexecDir,\n"++
+         "\tgetDataFileName\n"++
+         "\t) where\n"++
+         "\n"++
+         foreign_imports++
+         "import Data.Version"++
+         "\n"++
+         "\nversion = " ++ show (pkgVersion (package pkg_descr))++
+         "\n"
+ 
        body
-	| absolute =
-	  "\nbindir     = " ++ show flat_bindir ++
-	  "\nlibdir     = " ++ show flat_libdir ++
-	  "\ndatadir    = " ++ show flat_datadir ++
-	  "\nlibexecdir = " ++ show flat_libexecdir ++
-	  "\n"++
-	  "\ngetBinDir, getLibDir, getDataDir, getLibexecDir :: IO FilePath\n"++
-	  "getBinDir = return bindir\n"++
-	  "getLibDir = return libdir\n"++
-	  "getDataDir = return datadir\n"++
-	  "getLibexecDir = return libexecdir\n" ++
-	  "\n"++
-	  "getDataFileName :: FilePath -> IO FilePath\n"++
-	  "getDataFileName name = return (datadir ++ "++path_sep++" ++ name)\n"
-	| otherwise =
-	  "\nprefix        = " ++ show (prefix lbi) ++
-	  "\nbindirrel     = " ++ show (fromJust flat_bindirrel) ++
-	  "\n"++
-	  "\ngetBinDir :: IO FilePath\n"++
-	  "getBinDir = getPrefixDirRel bindirrel\n\n"++
-	  "getLibDir :: IO FilePath\n"++
-	  "getLibDir = "++mkGetDir flat_libdir flat_libdirrel++"\n\n"++
-	  "getDataDir :: IO FilePath\n"++
-	  "getDataDir =  "++mkGetDir flat_datadir flat_datadirrel++"\n\n"++
-	  "getLibexecDir :: IO FilePath\n"++
-	  "getLibexecDir = "++mkGetDir flat_libexecdir flat_libexecdirrel++"\n\n"++
-	  "getDataFileName :: FilePath -> IO FilePath\n"++
-	  "getDataFileName name = do\n"++
-	  "  dir <- getDataDir\n"++
-	  "  return (dir `joinFileName` name)\n"++
-	  "\n"++
-	  get_prefix_stuff
-   in do btime <- getModificationTime localBuildInfoFile
-   	 exists <- doesFileExist paths_filepath
-   	 ptime <- if exists
-   	            then getModificationTime paths_filepath
-   	            else return btime
-	 if btime >= ptime
-	   then writeFile paths_filepath (header++body)
-	   else return ()
+         | absolute =
+           "\nbindir     = " ++ show flat_bindir ++
+           "\nlibdir     = " ++ show flat_libdir ++
+           "\ndatadir    = " ++ show flat_datadir ++
+           "\nlibexecdir = " ++ show flat_libexecdir ++
+           "\n"++
+           "\ngetBinDir, getLibDir, getDataDir, getLibexecDir :: IO FilePath\n"++
+           "getBinDir = return bindir\n"++
+           "getLibDir = return libdir\n"++
+           "getDataDir = return datadir\n"++
+           "getLibexecDir = return libexecdir\n" ++
+           "\n"++
+           "getDataFileName :: FilePath -> IO FilePath\n"++
+           "getDataFileName name = return (datadir ++ "++path_sep++" ++ name)\n"
+         | otherwise =
+           "\nprefix        = " ++ show (prefix lbi) ++
+           "\nbindirrel     = " ++ show (fromJust flat_bindirrel) ++
+           "\n"++
+           "\ngetBinDir :: IO FilePath\n"++
+           "getBinDir = getPrefixDirRel bindirrel\n\n"++
+           "getLibDir :: IO FilePath\n"++
+           "getLibDir = "++mkGetDir flat_libdir flat_libdirrel++"\n\n"++
+           "getDataDir :: IO FilePath\n"++
+           "getDataDir =  "++mkGetDir flat_datadir flat_datadirrel++"\n\n"++
+           "getLibexecDir :: IO FilePath\n"++
+           "getLibexecDir = "++mkGetDir flat_libexecdir flat_libexecdirrel++"\n\n"++
+           "getDataFileName :: FilePath -> IO FilePath\n"++
+           "getDataFileName name = do\n"++
+           "  dir <- getDataDir\n"++
+           "  return (dir `joinFileName` name)\n"++
+           "\n"++
+           get_prefix_stuff
+   in do 
+    btime <- getModificationTime localBuildInfoFile
+    exists <- doesFileExist paths_filepath
+    ptime <- if exists
+              then getModificationTime paths_filepath
+              else return btime
+    if btime >= ptime
+      then writeFile paths_filepath (header++body)
+      else return ()
  where
-	flat_bindir        = mkBinDir pkg_descr lbi NoCopyDest
-	flat_bindirrel     = mkBinDirRel pkg_descr lbi NoCopyDest
-	flat_libdir        = mkLibDir pkg_descr lbi NoCopyDest
-	flat_libdirrel     = mkLibDirRel pkg_descr lbi NoCopyDest
-	flat_datadir       = mkDataDir pkg_descr lbi NoCopyDest
-	flat_datadirrel    = mkDataDirRel pkg_descr lbi NoCopyDest
-	flat_libexecdir    = mkLibexecDir pkg_descr lbi NoCopyDest
-	flat_libexecdirrel = mkLibexecDirRel pkg_descr lbi NoCopyDest
-	
-	mkGetDir dir (Just dirrel) = "getPrefixDirRel " ++ show dirrel
-	mkGetDir dir Nothing       = "return " ++ show dir
+  flat_bindir        = mkBinDir pkg_descr lbi NoCopyDest
+  flat_bindirrel     = mkBinDirRel pkg_descr lbi NoCopyDest
+  flat_libdir        = mkLibDir pkg_descr lbi NoCopyDest
+  flat_libdirrel     = mkLibDirRel pkg_descr lbi NoCopyDest
+  flat_datadir       = mkDataDir pkg_descr lbi NoCopyDest
+  flat_datadirrel    = mkDataDirRel pkg_descr lbi NoCopyDest
+  flat_libexecdir    = mkLibexecDir pkg_descr lbi NoCopyDest
+  flat_libexecdirrel = mkLibexecDirRel pkg_descr lbi NoCopyDest
+  
+  mkGetDir dir (Just dirrel) = "getPrefixDirRel " ++ show dirrel
+  mkGetDir dir Nothing       = "return " ++ show dir
 
 #if mingw32_HOST_OS
-	absolute = hasLibs pkg_descr || flat_bindirrel == Nothing
+  absolute = hasLibs pkg_descr || flat_bindirrel == Nothing
 #else
-	absolute = True
+  absolute = True
 #endif
 
-  	paths_modulename = autogenModuleName pkg_descr
-	paths_filename = paths_modulename ++ ".hs"
-	paths_filepath = autogenModulesDir lbi `joinFileName` paths_filename
+  paths_modulename = autogenModuleName pkg_descr
+  paths_filename = paths_modulename ++ ".hs"
+  paths_filepath = autogenModulesDir lbi `joinFileName` paths_filename
 
-	path_sep = show [pathSeparator]
+  path_sep = show [pathSeparator]
 
 get_prefix_stuff :: String
 get_prefix_stuff =
diff --git a/packages/Cabal/Distribution/Simple/Configure.hs b/packages/Cabal/Distribution/Simple/Configure.hs
index c4c1b01..b7669ea 100644
--- a/packages/Cabal/Distribution/Simple/Configure.hs
+++ b/packages/Cabal/Distribution/Simple/Configure.hs
@@ -44,11 +44,11 @@ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. -}
 module Distribution.Simple.Configure (writePersistBuildConfig,
                                       getPersistBuildConfig,
                                       maybeGetPersistBuildConfig,
- 			  	      configure,
+                 configure,
                                       localBuildInfoFile,
                                       findProgram,
                                       getInstalledPackages,
-				      configDependency,
+              configDependency,
                                       configCompiler, configCompilerAux,
 #ifdef DEBUG
                                       hunitTests
@@ -68,16 +68,16 @@ import Distribution.Simple.LocalBuildInfo
 import Distribution.Simple.Register (removeInstalledConfig)
 import Distribution.Setup(ConfigFlags(..), CopyDest(..))
 import Distribution.Compiler(CompilerFlavor(..), Compiler(..),
-			     compilerBinaryName, extensionsToFlags)
+           compilerBinaryName, extensionsToFlags)
 import Distribution.Package (PackageIdentifier(..), showPackageId, 
-			     parsePackageId)
+           parsePackageId)
 import Distribution.PackageDescription(
- 	PackageDescription(..), Library(..),
-	BuildInfo(..), Executable(..), setupMessage )
+   PackageDescription(..), Library(..),
+  BuildInfo(..), Executable(..), setupMessage )
 import Distribution.Simple.Utils (die, warn, withTempFile,maybeExit)
 import Distribution.Version (Version(..), Dependency(..), VersionRange(ThisVersion),
-			     parseVersion, showVersion, withinRange,
-			     showVersionRange)
+           parseVersion, showVersion, withinRange,
+           showVersionRange)
 
 import Data.List (intersperse, nub, maximumBy, isPrefixOf)
 import Data.Char (isSpace)
@@ -137,77 +137,73 @@ localBuildInfoFile = "./.setup-config"
 configure :: PackageDescription -> ConfigFlags -> IO LocalBuildInfo
 configure pkg_descr cfg
   = do
-	setupMessage "Configuring" pkg_descr
-	removeInstalledConfig
-        let lib = library pkg_descr
-	-- detect compiler
-	comp@(Compiler f' ver p' pkg) <- configCompilerAux cfg
-
-	-- installation directories
-	defPrefix <- default_prefix
-	defDataDir <- default_datadir pkg_descr
-        let 
-		pref = fromMaybe defPrefix (configPrefix cfg)
-		my_bindir = fromMaybe default_bindir 
-				  (configBinDir cfg)
-		my_libdir = fromMaybe (default_libdir comp)
-				  (configLibDir cfg)
-		my_libsubdir = fromMaybe (default_libsubdir comp)
-				  (configLibSubDir cfg)
-		my_libexecdir = fromMaybe default_libexecdir
-				  (configLibExecDir cfg)
-		my_datadir = fromMaybe defDataDir
-				  (configDataDir cfg)
-		my_datasubdir = fromMaybe default_datasubdir
-				  (configDataSubDir cfg)
-
-        -- check extensions
-        let extlist = nub $ maybe [] (extensions . libBuildInfo) lib ++
-                      concat [ extensions exeBi | Executable _ _ exeBi <- executables pkg_descr ]
-        let exts = fst $ extensionsToFlags f' extlist
-        unless (null exts) $ warn $ -- Just warn, FIXME: Should this be an error?
-            show f' ++ " does not support the following extensions:\n " ++
-            concat (intersperse ", " (map show exts))
-
-        foundPrograms <- lookupPrograms (configPrograms cfg)
-
-        happy     <- findProgram "happy"     (configHappy cfg)
-        alex      <- findProgram "alex"      (configAlex cfg)
-        hsc2hs    <- findProgram "hsc2hs"    (configHsc2hs cfg)
-        c2hs      <- findProgram "c2hs"      (configC2hs cfg)
-        cpphs     <- findProgram "cpphs"     (configCpphs cfg)
-        greencard <- findProgram "greencard" (configGreencard cfg)
-
-        let newConfig = foldr (\(_, p) c -> updateProgram p c) (configPrograms cfg) foundPrograms
-
-        -- FIXME: currently only GHC has hc-pkg
-        dep_pkgs <- case f' of
-                      GHC | ver >= Version [6,3] [] -> do
-                        ipkgs <-  getInstalledPackagesAux comp cfg
-	                mapM (configDependency ipkgs) (buildDepends pkg_descr)
-                      JHC                           -> do
-                        ipkgs <-  getInstalledPackagesJHC comp cfg
-	                mapM (configDependency ipkgs) (buildDepends pkg_descr)
-                      _                             -> do
-                        return $ map setDepByVersion (buildDepends pkg_descr)
-
-	split_objs <- 
-	   if not (configSplitObjs cfg)
-		then return False
-		else case f' of
-			    GHC | ver >= Version [6,5] [] -> return True
-	    		    _ -> do warn ("this compiler does not support " ++
-					    "--enable-split-objs; ignoring")
-				    return False
-
-	let lbi = LocalBuildInfo{prefix=pref, compiler=comp,
-			      buildDir="dist" `joinFileName` "build",
-			      bindir=my_bindir,
-			      libdir=my_libdir,
-			      libsubdir=my_libsubdir,
-			      libexecdir=my_libexecdir,
-			      datadir=my_datadir,
-			      datasubdir=my_datasubdir,
+  setupMessage "Configuring" pkg_descr
+  removeInstalledConfig
+  let lib = library pkg_descr
+  -- detect compiler
+  comp@(Compiler f' ver p' pkg) <- configCompilerAux cfg
+
+  -- installation directories
+  defPrefix <- default_prefix
+  defDataDir <- default_datadir pkg_descr
+  let 
+      pref = fromMaybe defPrefix (configPrefix cfg)
+      my_bindir = fromMaybe default_bindir 
+            (configBinDir cfg)
+      my_libdir = fromMaybe (default_libdir comp)
+            (configLibDir cfg)
+      my_libsubdir = fromMaybe (default_libsubdir comp)
+            (configLibSubDir cfg)
+      my_libexecdir = fromMaybe default_libexecdir
+            (configLibExecDir cfg)
+      my_datadir = fromMaybe defDataDir
+            (configDataDir cfg)
+      my_datasubdir = fromMaybe default_datasubdir
+            (configDataSubDir cfg)
+
+  -- check extensions
+  let extlist = nub $ maybe [] (extensions . libBuildInfo) lib ++
+                concat [ extensions exeBi | Executable _ _ exeBi <- executables pkg_descr ]
+  let exts = fst $ extensionsToFlags f' extlist
+  unless (null exts) $ warn $ -- Just warn, FIXME: Should this be an error?
+      show f' ++ " does not support the following extensions:\n " ++
+      concat (intersperse ", " (map show exts))
+  foundPrograms <- lookupPrograms (configPrograms cfg)
+  happy     <- findProgram "happy"     (configHappy cfg)
+  alex      <- findProgram "alex"      (configAlex cfg)
+  hsc2hs    <- findProgram "hsc2hs"    (configHsc2hs cfg)
+  c2hs      <- findProgram "c2hs"      (configC2hs cfg)
+  cpphs     <- findProgram "cpphs"     (configCpphs cfg)
+  greencard <- findProgram "greencard" (configGreencard cfg)
+  let newConfig = foldr (\(_, p) c -> updateProgram p c) (configPrograms cfg) foundPrograms
+  -- FIXME: currently only GHC has hc-pkg
+  dep_pkgs <- case f' of
+                GHC | ver >= Version [6,3] [] -> do
+                  ipkgs <-  getInstalledPackagesAux comp cfg
+                  mapM (configDependency ipkgs) (buildDepends pkg_descr)
+                JHC                           -> do
+                  ipkgs <-  getInstalledPackagesJHC comp cfg
+                  mapM (configDependency ipkgs) (buildDepends pkg_descr)
+                _                             -> do
+                  return $ map setDepByVersion (buildDepends pkg_descr)
+
+  split_objs <- 
+    if not (configSplitObjs cfg)
+    then return False
+    else case f' of
+          GHC | ver >= Version [6,5] [] -> return True
+          _ -> do 
+            warn ("this compiler does not support " ++ "--enable-split-objs; ignoring")
+            return False
+
+  let lbi = LocalBuildInfo{prefix=pref, compiler=comp,
+            buildDir="dist" `joinFileName` "build",
+            bindir=my_bindir,
+            libdir=my_libdir,
+            libsubdir=my_libsubdir,
+            libexecdir=my_libexecdir,
+            datadir=my_datadir,
+            datasubdir=my_datasubdir,
                               packageDeps=dep_pkgs,
                               withPrograms=newConfig,
                               withHappy=happy, withAlex=alex,
@@ -217,39 +213,36 @@ configure pkg_descr cfg
                               withVanillaLib=configVanillaLib cfg,
                               withProfLib=configProfLib cfg,
                               withProfExe=configProfExe cfg,
-			      withGHCiLib=configGHCiLib cfg,
-			      splitObjs=split_objs,
+            withGHCiLib=configGHCiLib cfg,
+            splitObjs=split_objs,
                               userConf=configUser cfg
                              }
 
-        -- FIXME: maybe this should only be printed when verbose?
-        message $ "Using install prefix: " ++ pref
-
-        messageDir pkg_descr lbi "Binaries" mkBinDir mkBinDirRel
-        messageDir pkg_descr lbi "Libraries" mkLibDir mkLibDirRel
-        messageDir pkg_descr lbi "Private binaries" mkLibexecDir mkLibexecDirRel
-        messageDir pkg_descr lbi "Data files" mkDataDir mkDataDirRel
-        
-        message $ "Using compiler: " ++ p'
-        message $ "Compiler flavor: " ++ (show f')
-        message $ "Compiler version: " ++ showVersion ver
-        message $ "Using package tool: " ++ pkg
-
-        mapM (\(s,p) -> reportProgram' s p) foundPrograms
-
-        reportProgram "happy"     happy
-        reportProgram "alex"      alex
-        reportProgram "hsc2hs"    hsc2hs
-        reportProgram "c2hs"      c2hs
-        reportProgram "cpphs"     cpphs
-        reportProgram "greencard" greencard
-
-	return lbi
+  -- FIXME: maybe this should only be printed when verbose?
+  message $ "Using install prefix: " ++ pref
+  messageDir pkg_descr lbi "Binaries" mkBinDir mkBinDirRel
+  messageDir pkg_descr lbi "Libraries" mkLibDir mkLibDirRel
+  messageDir pkg_descr lbi "Private binaries" mkLibexecDir mkLibexecDirRel
+  messageDir pkg_descr lbi "Data files" mkDataDir mkDataDirRel
+  
+  message $ "Using compiler: " ++ p'
+  message $ "Compiler flavor: " ++ (show f')
+  message $ "Compiler version: " ++ showVersion ver
+  message $ "Using package tool: " ++ pkg
+  mapM (\(s,p) -> reportProgram' s p) foundPrograms
+  reportProgram "happy"     happy
+  reportProgram "alex"      alex
+  reportProgram "hsc2hs"    hsc2hs
+  reportProgram "c2hs"      c2hs
+  reportProgram "cpphs"     cpphs
+  reportProgram "greencard" greencard
+
+  return lbi
 
 messageDir :: PackageDescription -> LocalBuildInfo -> String
-	-> (PackageDescription -> LocalBuildInfo -> CopyDest -> FilePath)
-	-> (PackageDescription -> LocalBuildInfo -> CopyDest -> Maybe FilePath)
-	-> IO ()
+  -> (PackageDescription -> LocalBuildInfo -> CopyDest -> FilePath)
+  -> (PackageDescription -> LocalBuildInfo -> CopyDest -> Maybe FilePath)
+  -> IO ()
 messageDir pkg_descr lbi name mkDir mkDirRel = 
   message (name ++ " installed in: " ++ mkDir pkg_descr lbi NoCopyDest ++ rel_note)
   where
@@ -304,17 +297,17 @@ reportProgram' name Nothing = message ("No " ++ name ++ " found")
 configDependency :: [PackageIdentifier] -> Dependency -> IO PackageIdentifier
 configDependency ps (Dependency pkgname vrange) = do
   let
-	ok p = pkgName p == pkgname && pkgVersion p `withinRange` vrange
+   ok p = pkgName p == pkgname && pkgVersion p `withinRange` vrange
   --
   case filter ok ps of
     [] -> die ("cannot satisfy dependency " ++ 
-			pkgname ++ showVersionRange vrange)
+      pkgname ++ showVersionRange vrange)
     qs -> let 
-	    pkg = maximumBy versions qs
-	    versions a b = pkgVersion a `compare` pkgVersion b
-	  in do message ("Dependency " ++ pkgname ++ showVersionRange vrange ++
-			 ": using " ++ showPackageId pkg)
-		return pkg
+      pkg = maximumBy versions qs
+      versions a b = pkgVersion a `compare` pkgVersion b
+      in do 
+        message ("Dependency " ++ pkgname ++ showVersionRange vrange ++ ": using " ++ showPackageId pkg)
+        return pkg
 
 getInstalledPackagesJHC :: Compiler -> ConfigFlags -> IO [PackageIdentifier]
 getInstalledPackagesJHC comp cfg = do
@@ -351,9 +344,10 @@ systemCaptureStdout verbose cmd = do
       res <- system cmd_line
       case res of
         ExitFailure _ -> die ("executing external program failed: "++cmd_line)
-        ExitSuccess   -> do str <- readFile tmp
-                            let ev [] = ' '; ev xs = last xs
-                            ev str `seq` return str
+        ExitSuccess   -> do 
+          str <- readFile tmp
+          let ev [] = ' '; ev xs = last xs
+          ev str `seq` return str
 
 -- -----------------------------------------------------------------------------
 -- Determining the compiler details
@@ -366,25 +360,26 @@ configCompilerAux cfg = configCompiler (configHcFlavor cfg)
 
 configCompiler :: Maybe CompilerFlavor -> Maybe FilePath -> Maybe FilePath -> Int -> IO Compiler
 configCompiler hcFlavor hcPath hcPkg verbose
-  = do let flavor = case hcFlavor of
+  = do 
+      let flavor = case hcFlavor of
                       Just f  -> f
                       Nothing -> error "Unknown compiler"
-       comp <- 
-	 case hcPath of
-	   Just path -> return path
-	   Nothing   -> findCompiler verbose flavor
+      comp <- 
+        case hcPath of
+          Just path -> return path
+          Nothing   -> findCompiler verbose flavor
 
-       ver <- configCompilerVersion flavor comp verbose
+      ver <- configCompilerVersion flavor comp verbose
 
-       pkgtool <-
-	 case hcPkg of
-	   Just path -> return path
-	   Nothing   -> guessPkgToolFromHCPath verbose flavor comp
+      pkgtool <-
+        case hcPkg of
+          Just path -> return path
+          Nothing   -> guessPkgToolFromHCPath verbose flavor comp
 
-       return (Compiler{compilerFlavor=flavor,
-			compilerVersion=ver,
-			compilerPath=comp,
-			compilerPkgTool=pkgtool})
+      return (Compiler{compilerFlavor=flavor,
+        compilerVersion=ver,
+        compilerPath=comp,
+        compilerPkgTool=pkgtool})
 
 findCompiler :: Int -> CompilerFlavor -> IO FilePath
 findCompiler verbose flavor = do
@@ -393,8 +388,9 @@ findCompiler verbose flavor = do
   res <- findExecutable prog
   case res of
    Nothing   -> die ("Cannot find compiler for " ++ prog)
-   Just path -> do when (verbose > 0) $ message ("found " ++ prog ++ " at "++ path)
-		   return path
+   Just path -> do 
+      when (verbose > 0) $ message ("found " ++ prog ++ " at "++ path)
+      return path
    -- ToDo: check that compiler works?
 
 compilerPkgToolName :: CompilerFlavor -> String
@@ -434,15 +430,16 @@ pCheck rs = [ r | (r,s) <- rs, all isSpace s ]
 
 guessPkgToolFromHCPath :: Int -> CompilerFlavor -> FilePath -> IO FilePath
 guessPkgToolFromHCPath verbose flavor path
-  = do let pkgToolName     = compilerPkgToolName flavor
-           (dir,_)         = splitFileName path
-           pkgtool         = dir `joinFileName` pkgToolName `joinFileExt` exeExtension
-       when (verbose > 0) $ message $ "looking for package tool: " ++ pkgToolName ++ " near compiler in " ++ path
-       exists <- doesFileExist pkgtool
-       when (not exists) $
-	  die ("Cannot find package tool: " ++ pkgtool)
-       when (verbose > 0) $ message $ "found package tool in " ++ pkgtool
-       return pkgtool
+  = do 
+      let pkgToolName     = compilerPkgToolName flavor
+          (dir,_)         = splitFileName path
+          pkgtool         = dir `joinFileName` pkgToolName `joinFileExt` exeExtension
+      when (verbose > 0) $ message $ "looking for package tool: " ++ pkgToolName ++ " near compiler in " ++ path
+      exists <- doesFileExist pkgtool
+      when (not exists) $
+        die ("Cannot find package tool: " ++ pkgtool)
+      when (verbose > 0) $ message $ "found package tool in " ++ pkgtool
+      return pkgtool
 
 message :: String -> IO ()
 message s = putStrLn $ "configure: " ++ s
@@ -460,12 +457,12 @@ packageID = PackageIdentifier "Foo" (Version [1] [])
        do let simonMarGHCLoc = "/usr/bin/ghc"
           simonMarGHC <- configure emptyPackageDescription {package=packageID}
                                        (Just GHC,
-				       Just simonMarGHCLoc,
-				       Nothing, Nothing)
-	  assertEqual "finding ghc, etc on simonMar's machine failed"
+               Just simonMarGHCLoc,
+               Nothing, Nothing)
+    assertEqual "finding ghc, etc on simonMar's machine failed"
              (LocalBuildInfo "/usr" (Compiler GHC 
-	                    (Version [6,2,2] []) simonMarGHCLoc 
- 			    (simonMarGHCLoc ++ "-pkg")) [] [])
+                      (Version [6,2,2] []) simonMarGHCLoc 
+           (simonMarGHCLoc ++ "-pkg")) [] [])
              simonMarGHC
       ]
 -}
diff --git a/packages/Cabal/Distribution/Simple/GHC.hs b/packages/Cabal/Distribution/Simple/GHC.hs
index de26bca..a1e3188 100644
--- a/packages/Cabal/Distribution/Simple/GHC.hs
+++ b/packages/Cabal/Distribution/Simple/GHC.hs
@@ -41,45 +41,45 @@ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. -}
 
 module Distribution.Simple.GHC (
-	build, installLib, installExe
+  build, installLib, installExe
  ) where
 
 import Distribution.PackageDescription
-				( PackageDescription(..), BuildInfo(..),
-				  withLib, setupMessage,
-				  Executable(..), withExe, Library(..),
-				  libModules, hcOptions )
+        ( PackageDescription(..), BuildInfo(..),
+          withLib, setupMessage,
+          Executable(..), withExe, Library(..),
+          libModules, hcOptions )
 import Distribution.Simple.LocalBuildInfo
-				( LocalBuildInfo(..), autogenModulesDir,
-				  mkLibDir, mkIncludeDir )
+        ( LocalBuildInfo(..), autogenModulesDir,
+          mkLibDir, mkIncludeDir )
 import Distribution.Simple.Utils( rawSystemExit, rawSystemPath,
-				  rawSystemVerbose, maybeExit, xargs,
-				  die, dirOf, moduleToFilePath,
-				  smartCopySources, findFile, copyFileVerbose,
+          rawSystemVerbose, maybeExit, xargs,
+          die, dirOf, moduleToFilePath,
+          smartCopySources, findFile, copyFileVerbose,
                                   mkLibName, mkProfLibName, dotToSep )
 import Distribution.Package  	( PackageIdentifier(..), showPackageId )
 import Distribution.Program	( rawSystemProgram, ranlibProgram,
-				  Program(..), ProgramConfiguration(..),
-				  ProgramLocation(..),
-				  lookupProgram, arProgram )
+          Program(..), ProgramConfiguration(..),
+          ProgramLocation(..),
+          lookupProgram, arProgram )
 import Distribution.Compiler 	( Compiler(..), CompilerFlavor(..),
-				  extensionsToGHCFlag )
+          extensionsToGHCFlag )
 import Distribution.Version	( Version(..) )
 import Distribution.Compat.FilePath
-				( joinFileName, exeExtension, joinFileExt,
-				  splitFilePath, objExtension, joinPaths,
+        ( joinFileName, exeExtension, joinFileExt,
+          splitFilePath, objExtension, joinPaths,
                                   isAbsolutePath, splitFileExt )
 import Distribution.Compat.Directory 
-				( createDirectoryIfMissing )
+        ( createDirectoryIfMissing )
 import qualified Distribution.Simple.GHCPackageConfig as GHC
-				( localPackageConfig,
-				  canReadLocalPackageConfig )
+        ( localPackageConfig,
+          canReadLocalPackageConfig )
 import Language.Haskell.Extension (Extension(..))
 
 import Control.Monad		( unless, when )
 import Data.List		( isSuffixOf, nub )
 import System.Directory		( removeFile, renameFile,
-				  getDirectoryContents, doesFileExist )
+          getDirectoryContents, doesFileExist )
 import System.Exit              (ExitCode(..))
 
 #ifdef mingw32_HOST_OS
@@ -108,20 +108,21 @@ build pkg_descr lbi verbose = do
   -- GHC versions prior to 6.4 didn't have the user package database,
   -- so we fake it.  TODO: This can go away in due course.
   pkg_conf <- if versionBranch (compilerVersion (compiler lbi)) >= [6,4]
-		then return []
-		else do  pkgConf <- GHC.localPackageConfig
-			 pkgConfReadable <- GHC.canReadLocalPackageConfig
-			 if pkgConfReadable 
-				then return ["-package-conf", pkgConf]
-				else return []
-	       
+    then return []
+    else do  
+        pkgConf <- GHC.localPackageConfig
+        pkgConfReadable <- GHC.canReadLocalPackageConfig
+        if pkgConfReadable 
+          then return ["-package-conf", pkgConf]
+          else return []
+         
   -- Build lib
   withLib pkg_descr () $ \lib -> do
       when (verbose > 3) (putStrLn "Building library...")
       let libBi = libBuildInfo lib
           libTargetDir = pref
-	  forceVanillaLib = TemplateHaskell `elem` extensions libBi
-	  -- TH always needs vanilla libs, even when building for profiling
+          forceVanillaLib = TemplateHaskell `elem` extensions libBi
+      -- TH always needs vanilla libs, even when building for profiling
 
       createDirectoryIfMissing True libTargetDir
       -- put hi-boot files into place for mutually recurive modules
@@ -130,7 +131,7 @@ build pkg_descr lbi verbose = do
       let ghcArgs = 
                  pkg_conf
               ++ ["-package-name", showPackageId (package pkg_descr) ]
-	      ++ (if splitObjs lbi then ["-split-objs"] else [])
+              ++ (if splitObjs lbi then ["-split-objs"] else [])
               ++ constructGHCCmdLine lbi libBi libTargetDir verbose
               ++ (libModules pkg_descr)
           ghcArgsProf = ghcArgs
@@ -140,25 +141,26 @@ build pkg_descr lbi verbose = do
                  ]
               ++ ghcProfOptions libBi
       unless (null (libModules pkg_descr)) $
-        do ifVanillaLib forceVanillaLib (rawSystemExit verbose ghcPath ghcArgs)
-           ifProfLib (rawSystemExit verbose ghcPath ghcArgsProf)
+        do 
+          ifVanillaLib forceVanillaLib (rawSystemExit verbose ghcPath ghcArgs)
+          ifProfLib (rawSystemExit verbose ghcPath ghcArgsProf)
 
       -- build any C sources
       unless (null (cSources libBi)) $ do
          when (verbose > 3) (putStrLn "Building C Sources...")
          -- FIX: similar 'versionBranch' logic duplicated below. refactor for code sharing
-         sequence_ [do let ghc_vers = compilerVersion (compiler lbi)
-			   odir | versionBranch ghc_vers >= [6,4,1] = pref
-				| otherwise = pref `joinFileName` dirOf c
-				-- ghc 6.4.1 fixed a bug in -odir handling
-				-- for C compilations.
-                       createDirectoryIfMissing True odir
-		       let cArgs = ["-I" ++ dir | dir <- includeDirs libBi]
-			       ++ ["-optc" ++ opt | opt <- ccOptions libBi]
-			       ++ ["-odir", odir, "-hidir", pref, "-c"]
-			       ++ (if verbose > 4 then ["-v"] else [])
-                       rawSystemExit verbose ghcPath (cArgs ++ [c])
-                                   | c <- cSources libBi]
+         sequence_ [do 
+          let ghc_vers = compilerVersion (compiler lbi)
+              odir | versionBranch ghc_vers >= [6,4,1] = pref
+                   | otherwise = pref `joinFileName` dirOf c
+          -- ghc 6.4.1 fixed a bug in -odir handling
+          -- for C compilations.
+          createDirectoryIfMissing True odir
+          let cArgs = ["-I" ++ dir | dir <- includeDirs libBi]
+                ++ ["-optc" ++ opt | opt <- ccOptions libBi]
+                ++ ["-odir", odir, "-hidir", pref, "-c"]
+                ++ (if verbose > 4 then ["-v"] else [])
+          rawSystemExit verbose ghcPath (cArgs ++ [c]) | c <- cSources libBi]
 
       -- link:
       when (verbose > 3) (putStrLn "cabal-linking...")
@@ -166,44 +168,42 @@ build pkg_descr lbi verbose = do
                   | (path, file, _) <- (map splitFilePath (cSources libBi)) ]
           libName  = mkLibName pref (showPackageId (package pkg_descr))
           profLibName  = mkProfLibName pref (showPackageId (package pkg_descr))
-	  ghciLibName = mkGHCiLibName pref (showPackageId (package pkg_descr))
+          ghciLibName = mkGHCiLibName pref (showPackageId (package pkg_descr))
 
       stubObjs <- sequence [moduleToFilePath [libTargetDir] (x ++"_stub") [objExtension]
                            |  x <- libModules pkg_descr ]  >>= return . concat
       stubProfObjs <- sequence [moduleToFilePath [libTargetDir] (x ++"_stub") ["p_" ++ objExtension]
                            |  x <- libModules pkg_descr ]  >>= return . concat
 
-      hObjs     <- getHaskellObjects pkg_descr libBi lbi
-			pref objExtension
+      hObjs     <- getHaskellObjects pkg_descr libBi lbi pref objExtension
       hProfObjs <- 
-	if (withProfLib lbi)
-		then getHaskellObjects pkg_descr libBi lbi
-			pref ("p_" ++ objExtension)
-		else return []
+        if (withProfLib lbi)
+          then getHaskellObjects pkg_descr libBi lbi pref ("p_" ++ objExtension)
+          else return []
 
       unless (null hObjs && null cObjs && null stubObjs) $ do
         try (removeFile libName) -- first remove library if it exists
         try (removeFile profLibName) -- first remove library if it exists
-	try (removeFile ghciLibName) -- first remove library if it exists
+        try (removeFile ghciLibName) -- first remove library if it exists
         let arArgs = ["q"++ (if verbose > 4 then "v" else "")]
-                ++ [libName]
+                  ++ [libName]
             arObjArgs =
-		   hObjs
-                ++ map (pref `joinFileName`) cObjs
-                ++ stubObjs
+              hObjs
+                  ++ map (pref `joinFileName`) cObjs
+                  ++ stubObjs
             arProfArgs = ["q"++ (if verbose > 4 then "v" else "")]
                 ++ [profLibName]
             arProfObjArgs =
-		   hProfObjs
-                ++ map (pref `joinFileName`) cObjs
-                ++ stubProfObjs
-	    ldArgs = ["-r"]
-                ++ ["-x"] -- FIXME: only some systems's ld support the "-x" flag
-	        ++ ["-o", ghciLibName `joinFileExt` "tmp"]
+              hProfObjs
+                        ++ map (pref `joinFileName`) cObjs
+                        ++ stubProfObjs
+            ldArgs = ["-r"]
+                      ++ ["-x"] -- FIXME: only some systems's ld support the "-x" flag
+                ++ ["-o", ghciLibName `joinFileExt` "tmp"]
             ldObjArgs =
-		   hObjs
+              hObjs
                 ++ map (pref `joinFileName`) cObjs
-		++ stubObjs
+                ++ stubObjs
 
 #if defined(mingw32_TARGET_OS) || defined(mingw32_HOST_OS)
             (compilerDir, _) = splitFileName $ compilerPath (compiler lbi)
@@ -214,7 +214,7 @@ build pkg_descr lbi verbose = do
 #else
             ld = "ld"
             rawSystemLd = rawSystemPath
-             --TODO: discover this at configure time on unix
+              --TODO: discover this at configure time on unix
             maxCommandLineSize = 30 * 1024
 #endif
             runLd ld args = do
@@ -222,7 +222,7 @@ build pkg_descr lbi verbose = do
               status <- rawSystemLd verbose ld
                           (args ++ if exists then [ghciLibName] else [])
               when (status == ExitSuccess)
-                   (renameFile (ghciLibName `joinFileExt` "tmp") ghciLibName)
+                    (renameFile (ghciLibName `joinFileExt` "tmp") ghciLibName)
               return status
 
         ifVanillaLib False $ maybeExit $ xargs maxCommandLineSize
@@ -236,95 +236,95 @@ build pkg_descr lbi verbose = do
 
   -- build any executables
   withExe pkg_descr $ \ (Executable exeName' modPath exeBi) -> do
-                 when (verbose > 3)
-                      (putStrLn $ "Building executable: " ++ exeName' ++ "...")
-
-                 -- exeNameReal, the name that GHC really uses (with .exe on Windows)
-                 let exeNameReal = exeName' `joinFileExt`
-                                   (if null $ snd $ splitFileExt exeName' then exeExtension else "")
-
-		 let targetDir = pref `joinFileName` exeName'
-                 let exeDir = joinPaths targetDir (exeName' ++ "-tmp")
-                 createDirectoryIfMissing True targetDir
-                 createDirectoryIfMissing True exeDir
-                 -- put hi-boot files into place for mutually recursive modules
-                 -- FIX: what about exeName.hi-boot?
-                 smartCopySources verbose (hsSourceDirs exeBi)
-                                  exeDir (otherModules exeBi) ["hi-boot"] False False
-
-                 -- build executables
-                 unless (null (cSources exeBi)) $ do
-                  when (verbose > 3) (putStrLn "Building C Sources.")
-                  sequence_ [do let cSrcODir |versionBranch (compilerVersion (compiler lbi))
-                                                    >= [6,4,1] = exeDir
-                                             | otherwise 
-                                                 = exeDir `joinFileName` (dirOf c)
-                                createDirectoryIfMissing True cSrcODir
-		                let cArgs = ["-I" ++ dir | dir <- includeDirs exeBi]
-			                    ++ ["-optc" ++ opt | opt <- ccOptions exeBi]
-			                    ++ ["-odir", cSrcODir, "-hidir", pref, "-c"]
-			                    ++ (if verbose > 4 then ["-v"] else [])
-                                rawSystemExit verbose ghcPath (cArgs ++ [c])
-                                    | c <- cSources exeBi]
-                 srcMainFile <- findFile (hsSourceDirs exeBi) modPath
-
-                 let cObjs = [ path `joinFileName` file `joinFileExt` objExtension
-                                   | (path, file, _) <- (map splitFilePath (cSources exeBi)) ]
-                 let binArgs linkExe profExe =
-                            pkg_conf
-                         ++ ["-I"++pref]
-			 ++ (if linkExe
-			        then ["-o", targetDir `joinFileName` exeNameReal]
-                                else ["-c"])
-                         ++ constructGHCCmdLine lbi exeBi exeDir verbose
-                         ++ [exeDir `joinFileName` x | x <- cObjs]
-                         ++ [srcMainFile]
-			 ++ ldOptions exeBi
-			 ++ ["-l"++lib | lib <- extraLibs exeBi]
-			 ++ ["-L"++libDir | libDir <- extraLibDirs exeBi]
-                         ++ if profExe
-                               then "-prof":ghcProfOptions exeBi
-                               else []
-
-		 -- For building exe's for profiling that use TH we actually
-		 -- have to build twice, once without profiling and the again
-		 -- with profiling. This is because the code that TH needs to
-		 -- run at compile time needs to be the vanilla ABI so it can
-		 -- be loaded up and run by the compiler.
-		 when (withProfExe lbi && TemplateHaskell `elem` extensions exeBi)
-		    (rawSystemExit verbose ghcPath (binArgs False False))
-
-		 rawSystemExit verbose ghcPath (binArgs True (withProfExe lbi))
+    when (verbose > 3)
+        (putStrLn $ "Building executable: " ++ exeName' ++ "...")
+
+    -- exeNameReal, the name that GHC really uses (with .exe on Windows)
+    let exeNameReal = exeName' `joinFileExt`
+                      (if null $ snd $ splitFileExt exeName' then exeExtension else "")
+
+    let targetDir = pref `joinFileName` exeName'
+    let exeDir = joinPaths targetDir (exeName' ++ "-tmp")
+    createDirectoryIfMissing True targetDir
+    createDirectoryIfMissing True exeDir
+    -- put hi-boot files into place for mutually recursive modules
+    -- FIX: what about exeName.hi-boot?
+    smartCopySources verbose (hsSourceDirs exeBi)
+                    exeDir (otherModules exeBi) ["hi-boot"] False False
+
+    -- build executables
+    unless (null (cSources exeBi)) $ do
+      when (verbose > 3) (putStrLn "Building C Sources.")
+      sequence_ [do 
+        let cSrcODir  |versionBranch (compilerVersion (compiler lbi))
+                                        >= [6,4,1] = exeDir
+                      | otherwise 
+                          = exeDir `joinFileName` (dirOf c)
+        createDirectoryIfMissing True cSrcODir
+        let cArgs = ["-I" ++ dir | dir <- includeDirs exeBi]
+                    ++ ["-optc" ++ opt | opt <- ccOptions exeBi]
+                    ++ ["-odir", cSrcODir, "-hidir", pref, "-c"]
+                    ++ (if verbose > 4 then ["-v"] else [])
+        rawSystemExit verbose ghcPath (cArgs ++ [c]) | c <- cSources exeBi]
+      srcMainFile <- findFile (hsSourceDirs exeBi) modPath
+
+      let cObjs = [ path `joinFileName` file `joinFileExt` objExtension
+                        | (path, file, _) <- (map splitFilePath (cSources exeBi)) ]
+      let binArgs linkExe profExe =
+                pkg_conf
+              ++ ["-I"++pref]
+              ++ (if linkExe
+                      then ["-o", targetDir `joinFileName` exeNameReal]
+                                        else ["-c"])
+              ++ constructGHCCmdLine lbi exeBi exeDir verbose
+              ++ [exeDir `joinFileName` x | x <- cObjs]
+              ++ [srcMainFile]
+              ++ ldOptions exeBi
+              ++ ["-l"++lib | lib <- extraLibs exeBi]
+              ++ ["-L"++libDir | libDir <- extraLibDirs exeBi]
+              ++ if profExe
+                    then "-prof":ghcProfOptions exeBi
+                    else []
+
+      -- For building exe's for profiling that use TH we actually
+      -- have to build twice, once without profiling and the again
+      -- with profiling. This is because the code that TH needs to
+      -- run at compile time needs to be the vanilla ABI so it can
+      -- be loaded up and run by the compiler.
+      when (withProfExe lbi && TemplateHaskell `elem` extensions exeBi)
+        (rawSystemExit verbose ghcPath (binArgs False False))
+
+      rawSystemExit verbose ghcPath (binArgs True (withProfExe lbi))
 
 
 -- when using -split-objs, we need to search for object files in the
 -- Module_split directory for each module.
 getHaskellObjects :: PackageDescription -> BuildInfo -> LocalBuildInfo
- 	-> FilePath -> String -> IO [FilePath]
+   -> FilePath -> String -> IO [FilePath]
 getHaskellObjects pkg_descr libBi lbi pref obj_ext
   | splitObjs lbi = do
-	let dirs = [ pref `joinFileName` (dotToSep x ++ "_split") 
-		   | x <- libModules pkg_descr ]
-	objss <- mapM getDirectoryContents dirs
-	let objs = [ dir `joinFileName` obj
-		   | (objs,dir) <- zip objss dirs, obj <- objs,
-		     obj_ext `isSuffixOf` obj ]
-	return objs
+      let dirs = [ pref `joinFileName` (dotToSep x ++ "_split") 
+                  | x <- libModules pkg_descr ]
+      objss <- mapM getDirectoryContents dirs
+      let objs = [ dir `joinFileName` obj
+                  | (objs,dir) <- zip objss dirs, obj <- objs,
+                    obj_ext `isSuffixOf` obj ]
+      return objs
   | otherwise  = 
-	return [ pref `joinFileName` (dotToSep x) `joinFileExt` obj_ext
-               | x <- libModules pkg_descr ]
+      return [ pref `joinFileName` (dotToSep x) `joinFileExt` obj_ext
+                  | x <- libModules pkg_descr ]
 
 
 constructGHCCmdLine
-	:: LocalBuildInfo
+  :: LocalBuildInfo
         -> BuildInfo
-	-> FilePath
-	-> Int				-- verbosity level
+  -> FilePath
+  -> Int				-- verbosity level
         -> [String]
 constructGHCCmdLine lbi bi odir verbose = 
         ["--make"]
      ++ (if verbose > 4 then ["-v"] else [])
-	    -- Unsupported extensions have already been checked by configure
+      -- Unsupported extensions have already been checked by configure
      ++ (if compilerVersion (compiler lbi) > Version [6,4] []
             then ["-hide-all-packages"]
             else [])
@@ -359,47 +359,51 @@ installExe verbose pref buildPref pkg_descr
              copyFileVerbose verbose (buildPref `joinFileName` e `joinFileName` exeName) (pref `joinFileName` exeName)
 
 -- |Install for ghc, .hi, .a and, if --with-ghci given, .o
-installLib    :: Int      -- ^verbose
+installLib :: Int -- ^verbose
               -> ProgramConfiguration
-              -> Bool     -- ^has vanilla library
-              -> Bool     -- ^has profiling library
-	      -> Bool     -- ^has GHCi libs
+              -> Bool -- ^has vanilla library
+              -> Bool -- ^has profiling library
+       -> Bool -- ^has GHCi libs
               -> FilePath -- ^install location
               -> FilePath -- ^Build location
               -> PackageDescription -> IO ()
 installLib verbose programConf hasVanilla hasProf hasGHCi pref buildPref
               pd@PackageDescription{library=Just l,
                                     package=p}
-    = do ifVanilla $ smartCopySources verbose [buildPref] pref (libModules pd) ["hi"] True False
-         ifProf $ smartCopySources verbose [buildPref] pref (libModules pd) ["p_hi"] True False
-         let libTargetLoc = mkLibName pref (showPackageId p)
-             profLibTargetLoc = mkProfLibName pref (showPackageId p)
-	     libGHCiTargetLoc = mkGHCiLibName pref (showPackageId p)
-         ifVanilla $ copyFileVerbose verbose (mkLibName buildPref (showPackageId p)) libTargetLoc
-         ifProf $ copyFileVerbose verbose (mkProfLibName buildPref (showPackageId p)) profLibTargetLoc
-	 ifGHCi $ copyFileVerbose verbose (mkGHCiLibName buildPref (showPackageId p)) libGHCiTargetLoc
-
-	 installIncludeFiles verbose pd pref
-
-         -- use ranlib or ar -s to build an index. this is necessary
-         -- on some systems like MacOS X.  If we can't find those,
-         -- don't worry too much about it.
-         let progName = programName $ ranlibProgram
-         mProg <- lookupProgram progName programConf
-         case foundProg mProg of
-           Just rl  -> do ifVanilla $ rawSystemProgram verbose rl [libTargetLoc]
-                          ifProf $ rawSystemProgram verbose rl [profLibTargetLoc]
-
-           Nothing -> do let progName = programName $ arProgram
-                         mProg <- lookupProgram progName programConf
-                         case mProg of
-                          Just ar  -> do ifVanilla $ rawSystemProgram verbose ar ["-s", libTargetLoc]
-                                         ifProf $ rawSystemProgram verbose ar ["-s", profLibTargetLoc]
-                          Nothing -> setupMessage  "Warning: Unable to generate index for library (missing ranlib and ar)" pd
-         return ()
+    = do 
+      ifVanilla $ smartCopySources verbose [buildPref] pref (libModules pd) ["hi"] True False
+      ifProf $ smartCopySources verbose [buildPref] pref (libModules pd) ["p_hi"] True False
+      let libTargetLoc = mkLibName pref (showPackageId p)
+          profLibTargetLoc = mkProfLibName pref (showPackageId p)
+          libGHCiTargetLoc = mkGHCiLibName pref (showPackageId p)
+      ifVanilla $ copyFileVerbose verbose (mkLibName buildPref (showPackageId p)) libTargetLoc
+      ifProf $ copyFileVerbose verbose (mkProfLibName buildPref (showPackageId p)) profLibTargetLoc
+      ifGHCi $ copyFileVerbose verbose (mkGHCiLibName buildPref (showPackageId p)) libGHCiTargetLoc
+
+      installIncludeFiles verbose pd pref
+
+      -- use ranlib or ar -s to build an index. this is necessary
+      -- on some systems like MacOS X. If we can't find those,
+      -- don't worry too much about it.
+      let progName = programName $ ranlibProgram
+      mProg <- lookupProgram progName programConf
+      case foundProg mProg of
+        Just rl -> do 
+          ifVanilla $ rawSystemProgram verbose rl [libTargetLoc]
+          ifProf $ rawSystemProgram verbose rl [profLibTargetLoc]
+
+        Nothing -> do 
+          let progName = programName $ arProgram
+          mProg <- lookupProgram progName programConf
+          case mProg of
+            Just ar -> do 
+              ifVanilla $ rawSystemProgram verbose ar ["-s", libTargetLoc]
+              ifProf $ rawSystemProgram verbose ar ["-s", profLibTargetLoc]
+            Nothing -> setupMessage "Warning: Unable to generate index for library (missing ranlib and ar)" pd
+      return ()
     where ifVanilla action = when hasVanilla (action >> return ())
           ifProf action = when hasProf (action >> return ())
-	  ifGHCi action = when hasGHCi (action >> return ())
+          ifGHCi action = when hasGHCi (action >> return ())
 installLib _ _ _ _ _ _ _ PackageDescription{library=Nothing}
     = die $ "Internal Error. installLibGHC called with no library."
 
@@ -410,7 +414,7 @@ installIncludeFiles verbose pkg_descr@PackageDescription{library=Just l} libdir
    createDirectoryIfMissing True incdir
    incs <- mapM (findInc relincdirs) (installIncludes lbi)
    sequence_ [ copyFileVerbose verbose path (incdir `joinFileName` f)
-	     | (f,path) <- incs ]
+       | (f,path) <- incs ]
   where
    relincdirs = filter (not.isAbsolutePath) (includeDirs lbi)
    lbi = libBuildInfo l
diff --git a/packages/Cabal/Distribution/Simple/Hugs.hs b/packages/Cabal/Distribution/Simple/Hugs.hs
index 0c18c26..5e1e74b 100644
--- a/packages/Cabal/Distribution/Simple/Hugs.hs
+++ b/packages/Cabal/Distribution/Simple/Hugs.hs
@@ -41,34 +41,34 @@ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. -}
 
 module Distribution.Simple.Hugs (
-	build, install,
-	hugsPackageDir
+  build, install,
+  hugsPackageDir
  ) where
 
 import Distribution.PackageDescription
-				( PackageDescription(..), BuildInfo(..),
-				  withLib,
-				  Executable(..), withExe, Library(..),
-				  libModules, hcOptions, autogenModuleName )
+        ( PackageDescription(..), BuildInfo(..),
+          withLib,
+          Executable(..), withExe, Library(..),
+          libModules, hcOptions, autogenModuleName )
 import Distribution.Compiler 	( Compiler(..), CompilerFlavor(..) )
 import Distribution.Package  	( PackageIdentifier(..) )
 import Distribution.Setup 	( CopyDest(..) )
 import Distribution.PreProcess 	( ppCpp )
 import Distribution.PreProcess.Unlit
-				( unlit )
+        ( unlit )
 import Distribution.Simple.LocalBuildInfo
-				( LocalBuildInfo(..), 
-				  mkLibDir, autogenModulesDir )
+        ( LocalBuildInfo(..), 
+          mkLibDir, autogenModulesDir )
 import Distribution.Simple.Utils( rawSystemExit, die,
-				  dirOf, dotToSep, moduleToFilePath,
-				  smartCopySources, findFile )
+          dirOf, dotToSep, moduleToFilePath,
+          smartCopySources, findFile )
 import Language.Haskell.Extension
-				( Extension(..) )
+        ( Extension(..) )
 import Distribution.Compat.Directory
-				( copyFile,createDirectoryIfMissing,
-				  removeDirectoryRecursive )
+        ( copyFile,createDirectoryIfMissing,
+          removeDirectoryRecursive )
 import Distribution.Compat.FilePath
-				( joinFileName, splitFileExt, joinFileExt,
+        ( joinFileName, splitFileExt, joinFileExt,
                                   dllExtension, searchPathSeparator,
                                   platformPath )
 
@@ -83,7 +83,7 @@ import IO			( try )
 #endif
 import Data.List		( nub, sort, isSuffixOf )
 import System.Directory		( Permissions(..), getPermissions,
-				  setPermissions )
+          setPermissions )
 
 -- -----------------------------------------------------------------------------
 
@@ -92,124 +92,121 @@ build :: PackageDescription -> LocalBuildInfo -> Int -> IO ()
 build pkg_descr lbi verbose = do
     let pref = buildDir lbi
     withLib pkg_descr () $ \ l -> do
-	copyFile (autogenModulesDir lbi `joinFileName` paths_modulename)
-		(pref `joinFileName` paths_modulename)
-	compileBuildInfo pref [] (libModules pkg_descr) (libBuildInfo l)
+     copyFile (autogenModulesDir lbi `joinFileName` paths_modulename)
+       (pref `joinFileName` paths_modulename)
+     compileBuildInfo pref [] (libModules pkg_descr) (libBuildInfo l)
     withExe pkg_descr $ compileExecutable (pref `joinFileName` "programs")
   where
-	paths_modulename = autogenModuleName pkg_descr ++ ".hs"
-
-	compileExecutable :: FilePath -> Executable -> IO ()
-	compileExecutable destDir (exe@Executable {modulePath=mainPath, buildInfo=bi}) = do
-            let exeMods = otherModules bi
-	    srcMainFile <- findFile (hsSourceDirs bi) mainPath
-	    let exeDir = destDir `joinFileName` exeName exe
-	    let destMainFile = exeDir `joinFileName` hugsMainFilename exe
-	    copyModule (CPP `elem` extensions bi) bi srcMainFile destMainFile
-	    let destPathsFile = exeDir `joinFileName` paths_modulename
-	    copyFile (autogenModulesDir lbi `joinFileName` paths_modulename)
-		     destPathsFile
-	    compileBuildInfo exeDir (maybe [] (hsSourceDirs . libBuildInfo) (library pkg_descr)) exeMods bi
-	    compileFiles bi exeDir [destMainFile, destPathsFile]
-	
-	compileBuildInfo :: FilePath
+  paths_modulename = autogenModuleName pkg_descr ++ ".hs"
+
+  compileExecutable :: FilePath -> Executable -> IO ()
+  compileExecutable destDir (exe@Executable {modulePath=mainPath, buildInfo=bi}) = do
+      let exeMods = otherModules bi
+      srcMainFile <- findFile (hsSourceDirs bi) mainPath
+      let exeDir = destDir `joinFileName` exeName exe
+      let destMainFile = exeDir `joinFileName` hugsMainFilename exe
+      copyModule (CPP `elem` extensions bi) bi srcMainFile destMainFile
+      let destPathsFile = exeDir `joinFileName` paths_modulename
+      copyFile (autogenModulesDir lbi `joinFileName` paths_modulename)
+         destPathsFile
+      compileBuildInfo exeDir (maybe [] (hsSourceDirs . libBuildInfo) (library pkg_descr)) exeMods bi
+      compileFiles bi exeDir [destMainFile, destPathsFile]
+  
+  compileBuildInfo :: FilePath
                          -> [FilePath] -- ^library source dirs, if building exes
                          -> [String] -- ^Modules
                          -> BuildInfo -> IO ()
-	compileBuildInfo destDir mLibSrcDirs mods bi = do
-	    -- Pass 1: copy or cpp files from src directory to build directory
-	    let useCpp = CPP `elem` extensions bi
-	    let srcDirs = nub $ hsSourceDirs bi ++ mLibSrcDirs
-            when (verbose > 3) (putStrLn $ "Source directories: " ++ show srcDirs)
-            flip mapM_ mods $ \ m -> do
-                fs <- moduleToFilePath srcDirs m suffixes
-                if null fs then
-                    die ("can't find source for module " ++ m)
-                  else do
-                    let srcFile = head fs
-                    let (_, ext) = splitFileExt srcFile
-                    copyModule useCpp bi srcFile
-                        (destDir `joinFileName` dotToSep m `joinFileExt` ext)
-	    -- Pass 2: compile foreign stubs in build directory
-	    stubsFileLists <- sequence [moduleToFilePath [destDir] modu suffixes |
-			modu <- mods]
-            compileFiles bi destDir (concat stubsFileLists)
-
-	suffixes = ["hs", "lhs"]
-
-	-- Copy or cpp a file from the source directory to the build directory.
-	copyModule :: Bool -> BuildInfo -> FilePath -> FilePath -> IO ()
-	copyModule cppAll bi srcFile destFile = do
-	    createDirectoryIfMissing True (dirOf destFile)
-	    (exts, opts, _) <- getOptionsFromSource srcFile
-	    let ghcOpts = hcOptions GHC opts
-	    if cppAll || CPP `elem` exts || "-cpp" `elem` ghcOpts then do
-	    	ppCpp bi lbi srcFile destFile verbose
-	    	return ()
-	      else
-	    	copyFile srcFile destFile
-
-        compileFiles :: BuildInfo -> FilePath -> [FilePath] -> IO ()
-        compileFiles bi modDir fileList = do
-	    ffiFileList <- filterM testFFI fileList
-            unless (null ffiFileList) $ do
-                when (verbose > 2) (putStrLn "Compiling FFI stubs")
-	        mapM_ (compileFFI bi modDir) ffiFileList
-
-        -- Only compile FFI stubs for a file if it contains some FFI stuff
-        testFFI :: FilePath -> IO Bool
-        testFFI file = do
-            inp <- readHaskellFile file
-            return ("foreign" `elem` symbols (stripComments False inp))
-
-        compileFFI :: BuildInfo -> FilePath -> FilePath -> IO ()
-        compileFFI bi modDir file = do
-            (_, opts, file_incs) <- getOptionsFromSource file
-            let ghcOpts = hcOptions GHC opts
-            let pkg_incs = ["\"" ++ inc ++ "\"" 
-			   | inc <- includes bi ++ installIncludes bi]
-            let incs = nub (sort (file_incs ++ includeOpts ghcOpts ++ pkg_incs))
-            let pathFlag = "-P" ++ modDir ++ [searchPathSeparator]
-            let hugsArgs = "-98" : pathFlag : map ("-i" ++) incs
-            cfiles <- getCFiles file
-            let cArgs =
-                    ["-I" ++ dir | dir <- includeDirs bi] ++
-                    ccOptions bi ++
-                    cfiles ++
-                    ["-L" ++ dir | dir <- extraLibDirs bi] ++
-                    ldOptions bi ++
-                    ["-l" ++ lib | lib <- extraLibs bi] ++
-                    concat [["-framework", f] | f <- frameworks bi]
-            rawSystemExit verbose ffihugs (hugsArgs ++ file : cArgs)
-
-	ffihugs = compilerPath (compiler lbi)
-
-	includeOpts :: [String] -> [String]
-	includeOpts [] = []
-	includeOpts ("-#include" : arg : opts) = arg : includeOpts opts
-	includeOpts (_ : opts) = includeOpts opts
-
-	-- get C file names from CFILES pragmas throughout the source file
-	getCFiles :: FilePath -> IO [String]
-	getCFiles file = do
-	    inp <- readHaskellFile file
-	    return [platformPath cfile |
-		"{-#" : "CFILES" : rest <-
-			map words $ lines $ stripComments True inp,
-		last rest == "#-}",
-		cfile <- init rest]
-
-	-- List of terminal symbols in a source file.
-	symbols :: String -> [String]
-	symbols cs = case lex cs of
-	    (sym, cs'):_ | not (null sym) -> sym : symbols cs'
-	    _ -> []
-
-	-- Get the non-literate source of a Haskell module.
-	readHaskellFile :: FilePath -> IO String
-	readHaskellFile file = do
-	    text <- readFile file
-	    return $ if ".lhs" `isSuffixOf` file then unlit file text else text
+  compileBuildInfo destDir mLibSrcDirs mods bi = do
+      -- Pass 1: copy or cpp files from src directory to build directory
+      let useCpp = CPP `elem` extensions bi
+      let srcDirs = nub $ hsSourceDirs bi ++ mLibSrcDirs
+      when (verbose > 3) (putStrLn $ "Source directories: " ++ show srcDirs)
+      flip mapM_ mods $ \ m -> do
+          fs <- moduleToFilePath srcDirs m suffixes
+          if null fs then
+              die ("can't find source for module " ++ m)
+            else do
+              let srcFile = head fs
+              let (_, ext) = splitFileExt srcFile
+              copyModule useCpp bi srcFile
+                  (destDir `joinFileName` dotToSep m `joinFileExt` ext)
+      -- Pass 2: compile foreign stubs in build directory
+      stubsFileLists <- sequence [moduleToFilePath [destDir] modu suffixes | modu <- mods]
+      compileFiles bi destDir (concat stubsFileLists)
+
+  suffixes = ["hs", "lhs"]
+
+  -- Copy or cpp a file from the source directory to the build directory.
+  copyModule :: Bool -> BuildInfo -> FilePath -> FilePath -> IO ()
+  copyModule cppAll bi srcFile destFile = do
+      createDirectoryIfMissing True (dirOf destFile)
+      (exts, opts, _) <- getOptionsFromSource srcFile
+      let ghcOpts = hcOptions GHC opts
+      if cppAll || CPP `elem` exts || "-cpp" `elem` ghcOpts then do
+       ppCpp bi lbi srcFile destFile verbose
+       return ()
+      else
+       copyFile srcFile destFile
+
+  compileFiles :: BuildInfo -> FilePath -> [FilePath] -> IO ()
+  compileFiles bi modDir fileList = do
+      ffiFileList <- filterM testFFI fileList
+      unless (null ffiFileList) $ do
+          when (verbose > 2) (putStrLn "Compiling FFI stubs")
+      mapM_ (compileFFI bi modDir) ffiFileList
+
+  -- Only compile FFI stubs for a file if it contains some FFI stuff
+  testFFI :: FilePath -> IO Bool
+  testFFI file = do
+      inp <- readHaskellFile file
+      return ("foreign" `elem` symbols (stripComments False inp))
+
+  compileFFI :: BuildInfo -> FilePath -> FilePath -> IO ()
+  compileFFI bi modDir file = do
+      (_, opts, file_incs) <- getOptionsFromSource file
+      let ghcOpts = hcOptions GHC opts
+      let pkg_incs = ["\"" ++ inc ++ "\"" | inc <- includes bi ++ installIncludes bi]
+      let incs = nub (sort (file_incs ++ includeOpts ghcOpts ++ pkg_incs))
+      let pathFlag = "-P" ++ modDir ++ [searchPathSeparator]
+      let hugsArgs = "-98" : pathFlag : map ("-i" ++) incs
+      cfiles <- getCFiles file
+      let cArgs =
+              ["-I" ++ dir | dir <- includeDirs bi] ++
+              ccOptions bi ++
+              cfiles ++
+              ["-L" ++ dir | dir <- extraLibDirs bi] ++
+              ldOptions bi ++
+              ["-l" ++ lib | lib <- extraLibs bi] ++
+              concat [["-framework", f] | f <- frameworks bi]
+      rawSystemExit verbose ffihugs (hugsArgs ++ file : cArgs)
+
+  ffihugs = compilerPath (compiler lbi)
+
+  includeOpts :: [String] -> [String]
+  includeOpts [] = []
+  includeOpts ("-#include" : arg : opts) = arg : includeOpts opts
+  includeOpts (_ : opts) = includeOpts opts
+
+  -- get C file names from CFILES pragmas throughout the source file
+  getCFiles :: FilePath -> IO [String]
+  getCFiles file = do
+      inp <- readHaskellFile file
+      return [platformPath cfile | "{-#" : "CFILES" : rest <-
+        map words $ lines $ stripComments True inp,
+        last rest == "#-}",
+        cfile <- init rest]
+
+  -- List of terminal symbols in a source file.
+  symbols :: String -> [String]
+  symbols cs = case lex cs of
+                (sym, cs'):_ | not (null sym) -> sym : symbols cs'
+                _ -> []
+
+  -- Get the non-literate source of a Haskell module.
+  readHaskellFile :: FilePath -> IO String
+  readHaskellFile file = do
+      text <- readFile file
+      return $ if ".lhs" `isSuffixOf` file then unlit file text else text
 
 -- ------------------------------------------------------------
 -- * options in source files
@@ -226,34 +223,34 @@ getOptionsFromSource
 getOptionsFromSource file = do
     text <- readFile file
     return $ foldr appendOptions ([],[],[]) $ map getOptions $
-	takeWhileJust $ map getPragma $
-	filter textLine $ map (dropWhile isSpace) $ lines $
-	stripComments True $
-	if ".lhs" `isSuffixOf` file then unlit file text else text
+     takeWhileJust $ map getPragma $
+     filter textLine $ map (dropWhile isSpace) $ lines $
+     stripComments True $
+     if ".lhs" `isSuffixOf` file then unlit file text else text
   where textLine [] = False
-	textLine ('#':_) = False
-	textLine _ = True
-
-	getPragma :: String -> Maybe [String]
-	getPragma line = case words line of
-	    ("{-#" : rest) | last rest == "#-}" -> Just (init rest)
-	    _ -> Nothing
-
-	getOptions ("OPTIONS":opts) = ([], [(GHC, opts)], [])
-	getOptions ("OPTIONS_GHC":opts) = ([], [(GHC, opts)], [])
-	getOptions ("OPTIONS_NHC98":opts) = ([], [(NHC, opts)], [])
-	getOptions ("OPTIONS_HUGS":opts) = ([], [(Hugs, opts)], [])
-	getOptions ("LANGUAGE":ws) = (mapMaybe readExtension ws, [], [])
-	  where	readExtension :: String -> Maybe Extension
-		readExtension w = case reads w of
-		    [(ext, "")] -> Just ext
-		    [(ext, ",")] -> Just ext
-		    _ -> Nothing
-	getOptions ("INCLUDE":ws) = ([], [], ws)
-	getOptions _ = ([], [], [])
-
-	appendOptions (exts, opts, incs) (exts', opts', incs')
-          = (exts++exts', opts++opts', incs++incs')
+        textLine ('#':_) = False
+        textLine _ = True
+
+        getPragma :: String -> Maybe [String]
+        getPragma line = case words line of
+                          ("{-#" : rest) | last rest == "#-}" -> Just (init rest)
+                          _ -> Nothing
+
+        getOptions ("OPTIONS":opts) = ([], [(GHC, opts)], [])
+        getOptions ("OPTIONS_GHC":opts) = ([], [(GHC, opts)], [])
+        getOptions ("OPTIONS_NHC98":opts) = ([], [(NHC, opts)], [])
+        getOptions ("OPTIONS_HUGS":opts) = ([], [(Hugs, opts)], [])
+        getOptions ("LANGUAGE":ws) = (mapMaybe readExtension ws, [], [])
+          where	readExtension :: String -> Maybe Extension
+                readExtension w = case reads w of
+                    [(ext, "")] -> Just ext
+                    [(ext, ",")] -> Just ext
+                    _ -> Nothing
+        getOptions ("INCLUDE":ws) = ([], [], ws)
+        getOptions _ = ([], [], [])
+      
+        appendOptions (exts, opts, incs) (exts', opts', incs')
+                = (exts++exts', opts++opts', incs++incs')
 
 -- takeWhileJust f = map fromJust . takeWhile isJust
 takeWhileJust :: [Maybe a] -> [a]
@@ -267,25 +264,25 @@ stripComments
     -> String
 stripComments keepPragmas = stripCommentsLevel 0
   where stripCommentsLevel :: Int -> String -> String
-	stripCommentsLevel 0 ('"':cs) = '"':copyString cs
-	stripCommentsLevel 0 ('-':'-':cs) =	-- FIX: symbols like -->
-	    stripCommentsLevel 0 (dropWhile (/= '\n') cs)
-	stripCommentsLevel 0 ('{':'-':'#':cs)
-	  | keepPragmas = '{' : '-' : '#' : copyPragma cs
-	stripCommentsLevel n ('{':'-':cs) = stripCommentsLevel (n+1) cs
-	stripCommentsLevel 0 (c:cs) = c : stripCommentsLevel 0 cs
-	stripCommentsLevel n ('-':'}':cs) = stripCommentsLevel (n-1) cs
-	stripCommentsLevel n (c:cs) = stripCommentsLevel n cs
-	stripCommentsLevel _ [] = []
-
-	copyString ('\\':c:cs) = '\\' : c : copyString cs
-	copyString ('"':cs) = '"' : stripCommentsLevel 0 cs
-	copyString (c:cs) = c : copyString cs
-	copyString [] = []
-
-	copyPragma ('#':'-':'}':cs) = '#' : '-' : '}' : stripCommentsLevel 0 cs
-	copyPragma (c:cs) = c : copyPragma cs
-	copyPragma [] = []
+        stripCommentsLevel 0 ('"':cs) = '"':copyString cs
+        stripCommentsLevel 0 ('-':'-':cs) =	-- FIX: symbols like -->
+            stripCommentsLevel 0 (dropWhile (/= '\n') cs)
+        stripCommentsLevel 0 ('{':'-':'#':cs)
+          | keepPragmas = '{' : '-' : '#' : copyPragma cs
+        stripCommentsLevel n ('{':'-':cs) = stripCommentsLevel (n+1) cs
+        stripCommentsLevel 0 (c:cs) = c : stripCommentsLevel 0 cs
+        stripCommentsLevel n ('-':'}':cs) = stripCommentsLevel (n-1) cs
+        stripCommentsLevel n (c:cs) = stripCommentsLevel n cs
+        stripCommentsLevel _ [] = []
+
+        copyString ('\\':c:cs) = '\\' : c : copyString cs
+        copyString ('"':cs) = '"' : stripCommentsLevel 0 cs
+        copyString (c:cs) = c : copyString cs
+        copyString [] = []
+      
+        copyPragma ('#':'-':'}':cs) = '#' : '-' : '}' : stripCommentsLevel 0 cs
+        copyPragma (c:cs) = c : copyPragma cs
+        copyPragma [] = []
 
 -- -----------------------------------------------------------------------------
 -- Install for Hugs
@@ -345,7 +342,7 @@ hugsInstallSuffixes = ["hs", "lhs", dllExtension]
 hugsPackageDir :: PackageDescription -> LocalBuildInfo -> FilePath
 hugsPackageDir pkg_descr lbi =
     mkLibDir pkg_descr lbi NoCopyDest
-	`joinFileName` "packages" `joinFileName` pkgName (package pkg_descr)
+     `joinFileName` "packages" `joinFileName` pkgName (package pkg_descr)
 
 -- |Filename used by Hugs for the main module of an executable.
 -- This is a simple filename, so that Hugs will look for any auxiliary
diff --git a/packages/Cabal/Distribution/Simple/Install.hs b/packages/Cabal/Distribution/Simple/Install.hs
index 240388e..e95e058 100644
--- a/packages/Cabal/Distribution/Simple/Install.hs
+++ b/packages/Cabal/Distribution/Simple/Install.hs
@@ -42,7 +42,7 @@ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. -}
 
 module Distribution.Simple.Install (
-	install,
+  install,
 #ifdef DEBUG        
         hunitTests
 #endif
@@ -57,8 +57,8 @@ module Distribution.Simple.Install (
 #endif
 
 import Distribution.PackageDescription (
-	PackageDescription(..),
-	setupMessage, hasLibs, withLib, withExe )
+  PackageDescription(..),
+  setupMessage, hasLibs, withLib, withExe )
 import Distribution.Simple.LocalBuildInfo (
         LocalBuildInfo(..), mkLibDir, mkBinDir, mkDataDir, mkProgDir, mkHaddockDir)
 import Distribution.Simple.Utils(copyFileVerbose, die, haddockPref,  copyDirectoryRecursiveVerbose)
@@ -109,13 +109,15 @@ install pkg_descr lbi (CopyFlags copydest verbose) = do
   let binPref = mkBinDir pkg_descr lbi copydest
   setupMessage ("Installing: " ++ libPref ++ " & " ++ binPref) pkg_descr
   case compilerFlavor (compiler lbi) of
-     GHC  -> do when (hasLibs pkg_descr)
-                     (GHC.installLib verbose (withPrograms lbi)
-                       (withVanillaLib lbi) (withProfLib lbi)
-                       (withGHCiLib lbi) libPref buildPref pkg_descr)
-                GHC.installExe verbose binPref buildPref pkg_descr
-     JHC  -> do withLib pkg_descr () $ JHC.installLib verbose libPref buildPref pkg_descr
-                withExe pkg_descr $ JHC.installExe verbose binPref buildPref pkg_descr
+     GHC  -> do 
+      when (hasLibs pkg_descr)
+            (GHC.installLib verbose (withPrograms lbi)
+              (withVanillaLib lbi) (withProfLib lbi)
+              (withGHCiLib lbi) libPref buildPref pkg_descr)
+      GHC.installExe verbose binPref buildPref pkg_descr
+     JHC  -> do 
+      withLib pkg_descr () $ JHC.installLib verbose libPref buildPref pkg_descr
+      withExe pkg_descr $ JHC.installExe verbose binPref buildPref pkg_descr
      Hugs -> do
        let progPref = mkProgDir pkg_descr lbi copydest
        let targetProgPref = mkProgDir pkg_descr lbi NoCopyDest
diff --git a/packages/Cabal/Distribution/Simple/LocalBuildInfo.hs b/packages/Cabal/Distribution/Simple/LocalBuildInfo.hs
index 9dd8341..34858fe 100644
--- a/packages/Cabal/Distribution/Simple/LocalBuildInfo.hs
+++ b/packages/Cabal/Distribution/Simple/LocalBuildInfo.hs
@@ -41,18 +41,18 @@ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. -}
 
 module Distribution.Simple.LocalBuildInfo ( 
-	LocalBuildInfo(..),
-	default_prefix,
-	default_bindir,
-	default_libdir,
-	default_libsubdir,
-	default_libexecdir,
-	default_datadir,
-	default_datasubdir,
-	mkLibDir, mkLibDirRel, mkBinDir, mkBinDirRel, mkLibexecDir, mkLibexecDirRel, mkDataDir, mkDataDirRel, mkHaddockDir, mkProgDir,
-	absolutePath, prefixRelPath,
-	substDir,
-	distPref, srcPref, autogenModulesDir, mkIncludeDir
+  LocalBuildInfo(..),
+  default_prefix,
+  default_bindir,
+  default_libdir,
+  default_libsubdir,
+  default_libexecdir,
+  default_datadir,
+  default_datasubdir,
+  mkLibDir, mkLibDirRel, mkBinDir, mkBinDirRel, mkLibexecDir, mkLibexecDirRel, mkDataDir, mkDataDirRel, mkHaddockDir, mkProgDir,
+  absolutePath, prefixRelPath,
+  substDir,
+  distPref, srcPref, autogenModulesDir, mkIncludeDir
   ) where
 
 
@@ -71,32 +71,32 @@ import Foreign.C
 
 -- |Data cached after configuration step.
 data LocalBuildInfo = LocalBuildInfo {
-  	prefix	      :: FilePath,
-		-- ^ The installation directory (eg. @/usr/local@, or
-		-- @C:/Program Files/foo-1.2@ on Windows.
-	bindir        :: FilePath,
-		-- ^ The bin directory
-	libdir        :: FilePath,
-		-- ^ The lib directory
-	libsubdir     :: FilePath,
-		-- ^ Subdirectory of libdir into which libraries are installed
-	libexecdir    :: FilePath,
-		-- ^ The lib directory
-	datadir       :: FilePath,
-		-- ^ The data directory
-	datasubdir    :: FilePath,
-		-- ^ Subdirectory of datadir into which data files are installed
-	compiler      :: Compiler,
-		-- ^ The compiler we're building with
-	buildDir      :: FilePath,
-		-- ^ Where to put the result of building.
-	packageDeps   :: [PackageIdentifier],
-		-- ^ Which packages we depend on, /exactly/.
-		-- The 'Distribution.PackageDescription.PackageDescription'
-		-- specifies a set of build dependencies
-		-- that must be satisfied in terms of version ranges.  This
-		-- field fixes those dependencies to the specific versions
-		-- available on this machine for this compiler.
+    prefix	      :: FilePath,
+    -- ^ The installation directory (eg. @/usr/local@, or
+    -- @C:/Program Files/foo-1.2@ on Windows.
+  bindir        :: FilePath,
+    -- ^ The bin directory
+  libdir        :: FilePath,
+    -- ^ The lib directory
+  libsubdir     :: FilePath,
+    -- ^ Subdirectory of libdir into which libraries are installed
+  libexecdir    :: FilePath,
+    -- ^ The lib directory
+  datadir       :: FilePath,
+    -- ^ The data directory
+  datasubdir    :: FilePath,
+    -- ^ Subdirectory of datadir into which data files are installed
+  compiler      :: Compiler,
+    -- ^ The compiler we're building with
+  buildDir      :: FilePath,
+    -- ^ Where to put the result of building.
+  packageDeps   :: [PackageIdentifier],
+    -- ^ Which packages we depend on, /exactly/.
+    -- The 'Distribution.PackageDescription.PackageDescription'
+    -- specifies a set of build dependencies
+    -- that must be satisfied in terms of version ranges.  This
+    -- field fixes those dependencies to the specific versions
+    -- available on this machine for this compiler.
         withPrograms  :: ProgramConfiguration, -- location and args for all programs
         userConf      :: Bool,           -- ^Was this package configured with --user?
         withHappy     :: Maybe FilePath, -- ^Might be the location of the Happy executable.
@@ -109,7 +109,7 @@ data LocalBuildInfo = LocalBuildInfo {
         withProfLib   :: Bool,  -- ^Whether to build profiling versions of libs.
         withProfExe   :: Bool,  -- ^Whether to build executables for profiling.
         withGHCiLib   :: Bool,  -- ^Whether to build libs suitable for use with GHCi.
-	splitObjs     :: Bool	-- ^Use -split-objs with GHC, if available
+  splitObjs     :: Bool	-- ^Use -split-objs with GHC, if available
   } deriving (Read, Show)
 
 -- ------------------------------------------------------------
@@ -137,23 +137,23 @@ mkIncludeDir = (`joinFileName` "include")
 The defaults are as follows:
 
 Windows:
-	prefix	   = C:\Program Files
-	bindir     = $prefix\$pkgid
-	libdir     = $prefix\Haskell
-	libsubdir  = $pkgid\$compiler
-	datadir    = $prefix			(for an executable)
-	           = $prefix\Common Files	(for a library)
-	datasubdir = $pkgid
-	libexecdir = $prefix\$pkgid
+  prefix	   = C:\Program Files
+  bindir     = $prefix\$pkgid
+  libdir     = $prefix\Haskell
+  libsubdir  = $pkgid\$compiler
+  datadir    = $prefix			(for an executable)
+             = $prefix\Common Files	(for a library)
+  datasubdir = $pkgid
+  libexecdir = $prefix\$pkgid
 
 Unix:
-	prefix	   = /usr/local
-	bindir	   = $prefix/bin
-	libdir	   = $prefix/lib/$pkgid/$compiler
-	libsubdir  = $pkgid/$compiler
-	datadir	   = $prefix/share/$pkgid
-	datasubdir = $pkgid
-	libexecdir = $prefix/libexec
+  prefix	   = /usr/local
+  bindir	   = $prefix/bin
+  libdir	   = $prefix/lib/$pkgid/$compiler
+  libsubdir  = $pkgid/$compiler
+  datadir	   = $prefix/share/$pkgid
+  datasubdir = $pkgid
+  libexecdir = $prefix/libexec
 -}
 
 default_prefix :: IO String
@@ -182,8 +182,8 @@ shGetFolderPath id =
   allocaBytes long_path_size $ \pPath -> do
      r <- c_SHGetFolderPath nullPtr id nullPtr 0 pPath
      if (r /= 0) 
-	then return Nothing
-	else do s <- peekCString pPath; return (Just s)
+     then return Nothing
+     else do s <- peekCString pPath; return (Just s)
   where
     long_path_size      = 1024
 
@@ -202,9 +202,9 @@ foreign import stdcall unsafe "shlobj.h SHGetFolderPathA"
 default_bindir :: FilePath
 default_bindir = "$prefix" `joinFileName`
 #if mingw32_HOST_OS || mingw32_TARGET_OS
-	"Haskell" `joinFileName` "bin"
+  "Haskell" `joinFileName` "bin"
 #else
-	"bin"
+  "bin"
 #endif
 
 default_libdir :: Compiler -> FilePath
@@ -218,25 +218,25 @@ default_libdir hc = "$prefix" `joinFileName`
 default_libsubdir :: Compiler -> FilePath
 default_libsubdir hc =
   case compilerFlavor hc of
-	Hugs -> "hugs" `joinFileName` "packages" `joinFileName` "$pkg"
+        Hugs -> "hugs" `joinFileName` "packages" `joinFileName` "$pkg"
         JHC  -> "$compiler"
-	_    -> "$pkgid" `joinFileName` "$compiler"
+        _    -> "$pkgid" `joinFileName` "$compiler"
 
 default_libexecdir :: FilePath
 default_libexecdir = "$prefix" `joinFileName`
 #if mingw32_HOST_OS || mingw32_TARGET_OS
-	"$pkgid"
+  "$pkgid"
 #else
-	"libexec"
+  "libexec"
 #endif
 
 default_datadir :: PackageDescription -> IO FilePath
 default_datadir pkg_descr
 #if mingw32_HOST_OS || mingw32_TARGET_OS
-	| hasLibs pkg_descr = getCommonFilesDir
-	| otherwise = return ("$prefix" `joinFileName` "Haskell")
+  | hasLibs pkg_descr = getCommonFilesDir
+  | otherwise = return ("$prefix" `joinFileName` "Haskell")
 #else
-	= return  ("$prefix" `joinFileName` "share")
+  = return  ("$prefix" `joinFileName` "share")
 #endif
 
 default_datasubdir :: FilePath
@@ -299,7 +299,7 @@ prefixRelPath pkg_descr lbi0 copydest ('$':'p':'r':'e':'f':'i':'x':s) = Just $
 prefixRelPath pkg_descr lbi copydest s = Nothing
 
 absolutePath :: PackageDescription -> LocalBuildInfo -> CopyDest -> FilePath
-	-> FilePath
+  -> FilePath
 absolutePath pkg_descr lbi copydest s =
   case copydest of
     NoCopyDest   -> substDir pkg_descr lbi s
@@ -311,14 +311,14 @@ substDir pkg_descr lbi s = loop s
  where
   loop "" = ""
   loop ('$':'p':'r':'e':'f':'i':'x':s) 
-	= prefix lbi ++ loop s
+   = prefix lbi ++ loop s
   loop ('$':'c':'o':'m':'p':'i':'l':'e':'r':s) 
-	= showCompilerId (compiler lbi) ++ loop s
+   = showCompilerId (compiler lbi) ++ loop s
   loop ('$':'p':'k':'g':'i':'d':s) 
-	= showPackageId (package pkg_descr) ++ loop s
+   = showPackageId (package pkg_descr) ++ loop s
   loop ('$':'p':'k':'g':s) 
-	= pkgName (package pkg_descr) ++ loop s
+   = pkgName (package pkg_descr) ++ loop s
   loop ('$':'v':'e':'r':'s':'i':'o':'n':s) 
-	= show (pkgVersion (package pkg_descr)) ++ loop s
+   = show (pkgVersion (package pkg_descr)) ++ loop s
   loop ('$':'$':s) = '$' : loop s
   loop (c:s) = c : loop s
diff --git a/packages/Cabal/Distribution/Simple/Register.hs b/packages/Cabal/Distribution/Simple/Register.hs
index a745c68..e631b27 100644
--- a/packages/Cabal/Distribution/Simple/Register.hs
+++ b/packages/Cabal/Distribution/Simple/Register.hs
@@ -43,10 +43,10 @@ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. -}
 
 module Distribution.Simple.Register (
-	register,
-	unregister,
+  register,
+  unregister,
         writeInstalledConfig,
-	removeInstalledConfig,
+  removeInstalledConfig,
         installedPkgConfigFile,
         regScriptLocation,
         unregScriptLocation,
@@ -64,16 +64,16 @@ module Distribution.Simple.Register (
 #endif
 
 import Distribution.Simple.LocalBuildInfo (LocalBuildInfo(..), mkLibDir, mkHaddockDir,
-					   mkIncludeDir)
+             mkIncludeDir)
 import Distribution.Compiler (CompilerFlavor(..), Compiler(..))
 import Distribution.Setup (RegisterFlags(..), CopyDest(..), userOverride)
 import Distribution.PackageDescription (setupMessage, PackageDescription(..),
-					BuildInfo(..), Library(..), haddockName)
+          BuildInfo(..), Library(..), haddockName)
 import Distribution.Package (PackageIdentifier(..), showPackageId)
 import Distribution.Version (Version(..))
 import Distribution.InstalledPackageInfo
-	(InstalledPackageInfo, showInstalledPackageInfo, 
-	 emptyInstalledPackageInfo)
+  (InstalledPackageInfo, showInstalledPackageInfo, 
+   emptyInstalledPackageInfo)
 import qualified Distribution.InstalledPackageInfo as IPI
 import Distribution.Simple.Utils (rawSystemExit, copyFileVerbose, die)
 import Distribution.Simple.Hugs (hugsPackageDir)
@@ -86,7 +86,7 @@ import Distribution.Compat.Directory
        )
 
 import Distribution.Compat.FilePath (joinFileName, joinPaths, splitFileName,
-				     isAbsolutePath)
+             isAbsolutePath)
 
 import System.Directory(doesFileExist, removeFile, getCurrentDirectory)
 import System.IO.Error (try)
@@ -128,76 +128,77 @@ register pkg_descr lbi regFlags
         genScript = regGenScript regFlags
         verbose = regVerbose regFlags
         user = regUser regFlags `userOverride` userConf lbi
-	inplace = regInPlace regFlags
+        inplace = regInPlace regFlags
     setupMessage (if genScript
                      then ("Writing registration script: " ++ regScriptLocation)
                      else "Registering")
                  pkg_descr
     case compilerFlavor (compiler lbi) of
       GHC -> do 
-	config_flags <-
-	   if user
-		then if ghc_63_plus
-			then return ["--user"]
-			else do 
-			  GHC.maybeCreateLocalPackageConfig
-		          localConf <- GHC.localPackageConfig
-			  pkgConfWriteable <- GHC.canWriteLocalPackageConfig
-		          when (not pkgConfWriteable && not genScript)
-                                   $ userPkgConfErr localConf
-			  return ["--config-file=" ++ localConf]
-		else return []
-
-	let instConf = if inplace then inplacePkgConfigFile 
-				  else installedPkgConfigFile
-
-        instConfExists <- doesFileExist instConf
-        when (not instConfExists && not genScript) $ do
-          when (verbose > 0) $
-            putStrLn ("create " ++ instConf)
-          writeInstalledConfig pkg_descr lbi inplace
-
-	let register_flags
-		| ghc_63_plus = "update":
+       config_flags <-
+        if user
+        then if ghc_63_plus
+         then return ["--user"]
+         else do 
+           GHC.maybeCreateLocalPackageConfig
+           localConf <- GHC.localPackageConfig
+           pkgConfWriteable <- GHC.canWriteLocalPackageConfig
+           when (not pkgConfWriteable && not genScript)
+                                $ userPkgConfErr localConf
+           return ["--config-file=" ++ localConf]
+        else return []
+  
+       let instConf = if inplace then inplacePkgConfigFile 
+             else installedPkgConfigFile
+   
+       instConfExists <- doesFileExist instConf
+       when (not instConfExists && not genScript) $ do
+         when (verbose > 0) $
+           putStrLn ("create " ++ instConf)
+         writeInstalledConfig pkg_descr lbi inplace
+   
+       let register_flags
+            | ghc_63_plus = "update":
 #if !(mingw32_HOST_OS || mingw32_TARGET_OS)
-		                 if genScript
+                     if genScript
                                     then []
                                     else 
 #endif
                                       [instConf]
-		| otherwise   = "--update-package":
+            | otherwise   = "--update-package":
 #if !(mingw32_HOST_OS || mingw32_TARGET_OS)
-				 if genScript
+               if genScript
                                     then []
                                     else
 #endif
                                       ["--input-file="++instConf]
         
-	let allFlags = register_flags
+       let allFlags = register_flags
                        ++ config_flags
                        ++ if ghc_63_plus && genScript then ["-"] else []
-        let pkgTool = case regWithHcPkg regFlags of
-			 Just f  -> f
-			 Nothing -> compilerPkgTool (compiler lbi)
+       let pkgTool = case regWithHcPkg regFlags of
+            Just f  -> f
+            Nothing -> compilerPkgTool (compiler lbi)
 
-        if genScript
-         then do cfg <- showInstalledConfig pkg_descr lbi inplace
-	         rawSystemPipe regScriptLocation verbose cfg
-                           pkgTool allFlags
-         else rawSystemExit verbose pkgTool allFlags
+       if genScript
+        then do 
+          cfg <- showInstalledConfig pkg_descr lbi inplace
+          rawSystemPipe regScriptLocation verbose cfg
+                          pkgTool allFlags
+        else rawSystemExit verbose pkgTool allFlags
 
       Hugs -> do
-	when inplace $ die "--inplace is not supported with Hugs"
-	createDirectoryIfMissing True (hugsPackageDir pkg_descr lbi)
-	copyFileVerbose verbose installedPkgConfigFile
-	    (hugsPackageDir pkg_descr lbi `joinFileName` "package.conf")
+       when inplace $ die "--inplace is not supported with Hugs"
+       createDirectoryIfMissing True (hugsPackageDir pkg_descr lbi)
+       copyFileVerbose verbose installedPkgConfigFile
+           (hugsPackageDir pkg_descr lbi `joinFileName` "package.conf")
       JHC -> when (verbose > 0) $ putStrLn "registering for JHC (nothing to do)"
       _   -> die ("only registering with GHC is implemented")
 
 userPkgConfErr :: String -> IO a
 userPkgConfErr local_conf = 
   die ("--user flag passed, but cannot write to local package config: "
-    	++ local_conf )
+      ++ local_conf )
 
 -- -----------------------------------------------------------------------------
 -- The installed package config
@@ -208,7 +209,7 @@ writeInstalledConfig :: PackageDescription -> LocalBuildInfo -> Bool -> IO ()
 writeInstalledConfig pkg_descr lbi inplace = do
   pkg_config <- showInstalledConfig pkg_descr lbi inplace
   writeFile (if inplace then inplacePkgConfigFile else installedPkgConfigFile)
-	    (pkg_config ++ "\n")
+      (pkg_config ++ "\n")
 
 -- |Create a string suitable for writing out to the package config file
 showInstalledConfig :: PackageDescription -> LocalBuildInfo -> Bool
@@ -217,14 +218,14 @@ showInstalledConfig pkg_descr lbi inplace
   | (case compilerFlavor hc of GHC -> True; _ -> False) &&
     compilerVersion hc < Version [6,3] [] 
     = if inplace then
-	  error "--inplace not supported for GHC < 6.3"
+    error "--inplace not supported for GHC < 6.3"
       else
-	  return (showGHCPackageConfig (mkGHCPackageConfig pkg_descr lbi))
+    return (showGHCPackageConfig (mkGHCPackageConfig pkg_descr lbi))
   | otherwise 
     = do cfg <- mkInstalledPackageInfo pkg_descr lbi inplace
          return (showInstalledPackageInfo cfg)
   where
-  	hc = compiler lbi
+    hc = compiler lbi
 
 removeInstalledConfig :: IO ()
 removeInstalledConfig = do
@@ -241,55 +242,53 @@ inplacePkgConfigFile = ".inplace-pkg-config"
 -- Making the InstalledPackageInfo
 
 mkInstalledPackageInfo
-	:: PackageDescription
-	-> LocalBuildInfo
-	-> Bool
-	-> IO InstalledPackageInfo
+  :: PackageDescription
+  -> LocalBuildInfo
+  -> Bool
+  -> IO InstalledPackageInfo
 mkInstalledPackageInfo pkg_descr lbi inplace = do 
   pwd <- getCurrentDirectory
-  let 
-	lib = fromJust (library pkg_descr) -- checked for Nothing earlier
-        bi = libBuildInfo lib
-	build_dir = pwd `joinFileName` buildDir lbi
-	libdir = mkLibDir pkg_descr lbi NoCopyDest
-	incdir = mkIncludeDir libdir
-	(absinc,relinc) = partition isAbsolutePath (includeDirs bi)
-        haddockDir = mkHaddockDir pkg_descr lbi NoCopyDest
-        haddockFile = joinPaths haddockDir (haddockName pkg_descr)
-    in
-    return emptyInstalledPackageInfo{
+  let lib = fromJust (library pkg_descr) -- checked for Nothing earlier
+      bi = libBuildInfo lib
+      build_dir = pwd `joinFileName` buildDir lbi
+      libdir = mkLibDir pkg_descr lbi NoCopyDest
+      incdir = mkIncludeDir libdir
+      (absinc,relinc) = partition isAbsolutePath (includeDirs bi)
+      haddockDir = mkHaddockDir pkg_descr lbi NoCopyDest
+      haddockFile = joinPaths haddockDir (haddockName pkg_descr)
+  return emptyInstalledPackageInfo{
         IPI.package           = package pkg_descr,
         IPI.license           = license pkg_descr,
         IPI.copyright         = copyright pkg_descr,
         IPI.maintainer        = maintainer pkg_descr,
-	IPI.author	      = author pkg_descr,
+  IPI.author	      = author pkg_descr,
         IPI.stability         = stability pkg_descr,
-	IPI.homepage	      = homepage pkg_descr,
-	IPI.pkgUrl	      = pkgUrl pkg_descr,
-	IPI.description	      = description pkg_descr,
-	IPI.category	      = category pkg_descr,
+  IPI.homepage	      = homepage pkg_descr,
+  IPI.pkgUrl	      = pkgUrl pkg_descr,
+  IPI.description	      = description pkg_descr,
+  IPI.category	      = category pkg_descr,
         IPI.exposed           = True,
-	IPI.exposedModules    = exposedModules lib,
-	IPI.hiddenModules     = otherModules bi,
+  IPI.exposedModules    = exposedModules lib,
+  IPI.hiddenModules     = otherModules bi,
         IPI.importDirs        = [if inplace then build_dir else libdir],
         IPI.libraryDirs       = (if inplace then build_dir else libdir)
-				: extraLibDirs bi,
+        : extraLibDirs bi,
         IPI.hsLibraries       = ["HS" ++ showPackageId (package pkg_descr)],
         IPI.extraLibraries    = extraLibs bi,
         IPI.includeDirs       = absinc 
-				 ++ if inplace 
-					then map (pwd `joinFileName`) relinc
-					else [incdir],
+         ++ if inplace 
+          then map (pwd `joinFileName`) relinc
+          else [incdir],
         IPI.includes	      = includes bi ++ map (snd.splitFileName)
-						   (installIncludes bi),
+               (installIncludes bi),
         IPI.depends           = packageDeps lbi,
         IPI.hugsOptions       = concat [opts | (Hugs,opts) <- options bi],
         IPI.ccOptions         = ccOptions bi,
         IPI.ldOptions         = ldOptions bi,
         IPI.frameworkDirs     = [],
         IPI.frameworks        = frameworks bi,
-	IPI.haddockInterfaces = [haddockFile],
-	IPI.haddockHTMLs      = [haddockDir]
+  IPI.haddockInterfaces = [haddockFile],
+  IPI.haddockHTMLs      = [haddockDir]
         }
 
 -- -----------------------------------------------------------------------------
@@ -304,29 +303,29 @@ unregister pkg_descr lbi regFlags = do
       user = regUser regFlags `userOverride` userConf lbi
   case compilerFlavor (compiler lbi) of
     GHC -> do
-	config_flags <-
-	   if user
-		then if ghc_63_plus
-			then return ["--user"]
-			else do
-                          instConfExists <- doesFileExist installedPkgConfigFile
-		          localConf <- GHC.localPackageConfig
-		          unless instConfExists (userPkgConfErr localConf)
-			  return ["--config-file=" ++ localConf]
-		else return []
-        let removeCmd = if ghc_63_plus
-                        then ["unregister",showPackageId (package pkg_descr)]
-                        else ["--remove-package="++(pkgName $ package pkg_descr)]
-        let pkgTool = case regWithHcPkg regFlags of
-			 Just f  -> f
-			 Nothing -> compilerPkgTool (compiler lbi)
-	rawSystemEmit unregScriptLocation genScript verbose pkgTool
-	    (removeCmd++config_flags)
+     config_flags <-
+      if user
+      then if ghc_63_plus
+       then return ["--user"]
+       else do
+         instConfExists <- doesFileExist installedPkgConfigFile
+         localConf <- GHC.localPackageConfig
+         unless instConfExists (userPkgConfErr localConf)
+         return ["--config-file=" ++ localConf]
+      else return []
+     let removeCmd = if ghc_63_plus
+                     then ["unregister",showPackageId (package pkg_descr)]
+                     else ["--remove-package="++(pkgName $ package pkg_descr)]
+     let pkgTool = case regWithHcPkg regFlags of
+          Just f  -> f
+          Nothing -> compilerPkgTool (compiler lbi)
+     rawSystemEmit unregScriptLocation genScript verbose pkgTool
+         (removeCmd++config_flags)
     Hugs -> do
         try $ removeDirectoryRecursive (hugsPackageDir pkg_descr lbi)
-	return ()
+        return ()
     _ ->
-	die ("only unregistering with GHC and Hugs is implemented")
+     die ("only unregistering with GHC and Hugs is implemented")
 
 -- |Like rawSystemExit, but optionally emits to a script instead of
 -- exiting. FIX: chmod +x?
diff --git a/packages/Cabal/Distribution/Simple/Utils.hs b/packages/Cabal/Distribution/Simple/Utils.hs
index 7f64604..0228074 100644
--- a/packages/Cabal/Distribution/Simple/Utils.hs
+++ b/packages/Cabal/Distribution/Simple/Utils.hs
@@ -42,16 +42,16 @@ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. -}
 
 module Distribution.Simple.Utils (
-	die,
-	dieWithLocation,
-	warn,
-	rawSystemPath,
+  die,
+  dieWithLocation,
+  warn,
+  rawSystemPath,
         rawSystemVerbose,
-	rawSystemExit,
+  rawSystemExit,
         maybeExit,
         xargs,
         matchesDescFile,
-	rawSystemPathExit,
+  rawSystemPathExit,
         smartCopySources,
         copyFileVerbose,
         copyDirectoryRecursiveVerbose,
@@ -59,14 +59,14 @@ module Distribution.Simple.Utils (
         mkLibName,
         mkProfLibName,
         currentDir,
-	dirOf,
+  dirOf,
         dotToSep,
-	withTempFile,
-	findFile,
+  withTempFile,
+  findFile,
         defaultPackageDesc,
         findPackageDesc,
-	defaultHookedPackageDesc,
-	findHookedPackageDesc,
+  defaultHookedPackageDesc,
+  findHookedPackageDesc,
         distPref,
         haddockPref,
         srcPref,
@@ -97,11 +97,11 @@ import System.Posix.Internals (c_getpid)
 #endif
 
 import Distribution.Compat.FilePath
-	(splitFileName, splitFileExt, joinFileName, joinFileExt, joinPaths,
-	pathSeparator,splitFilePath)
+  (splitFileName, splitFileExt, joinFileName, joinFileExt, joinPaths,
+  pathSeparator,splitFilePath)
 import System.Directory (getDirectoryContents, getCurrentDirectory
-			, doesDirectoryExist, doesFileExist, removeFile, getPermissions
-			, Permissions(executable))
+      , doesDirectoryExist, doesFileExist, removeFile, getPermissions
+      , Permissions(executable))
 
 import Distribution.Compat.Directory
            (copyFile, findExecutable, createDirectoryIfMissing,
@@ -155,8 +155,8 @@ maybeExit :: IO ExitCode -> IO ()
 maybeExit cmd = do
   res <- cmd
   if res /= ExitSuccess
-	then exitWith res  
-	else return ()
+  then exitWith res  
+  else return ()
 
 -- Exit with the same exitcode if the subcommand fails
 rawSystemExit :: Int -> FilePath -> [String] -> IO ()
@@ -284,12 +284,12 @@ smartCopySources verbose srcDirs targetDir sources searchSuffixes exitIfNone pre
                           then targetDir `joinFileName` srcDir `joinFileName` name
                           else targetDir `joinFileName` name) |
                        (srcDir, name) <- concat allLocations]
-	 -- Create parent directories for everything:
-	 mapM_ (createDirectoryIfMissing True) $ nub $
-             [fst (splitFileName targetFile) | (_, targetFile) <- copies]
-	 -- Put sources into place:
-	 sequence_ [copyFileVerbose verbose srcFile destFile |
-                    (srcFile, destFile) <- copies]
+         -- Create parent directories for everything:
+         mapM_ (createDirectoryIfMissing True) $ nub $
+                   [fst (splitFileName targetFile) | (_, targetFile) <- copies]
+         -- Put sources into place:
+         sequence_ [copyFileVerbose verbose srcFile destFile |
+                           (srcFile, destFile) <- copies]
     where moduleToFPErr m
               = do p <- moduleToFilePath2 srcDirs m searchSuffixes
                    when (null p && exitIfNone)
@@ -312,15 +312,18 @@ copyDirectoryRecursiveVerbose verbose srcDir destDir = do
          let cp :: FilePath -> IO ()
              cp f = let srcFile  = joinPaths src  f
                         destFile = joinPaths dest f
-                    in  do success <- try (copyFileVerbose verbose srcFile destFile)
-                           case success of
-                              Left e  -> do isDir <- doesDirectoryExist srcFile
-                                            -- If f is not a directory, re-throw the error
-                                            unless isDir $ ioError e
-                                            aux srcFile destFile
-                              Right _ -> return ()
-         in  do createDirectoryIfMissing False dest
-                getDirectoryContentsWithoutSpecial src >>= mapM_ cp
+                    in do 
+                          success <- try (copyFileVerbose verbose srcFile destFile)
+                          case success of
+                            Left e  -> do 
+                                isDir <- doesDirectoryExist srcFile
+                                -- If f is not a directory, re-throw the error
+                                unless isDir $ ioError e
+                                aux srcFile destFile
+                            Right _ -> return ()
+         in do 
+              createDirectoryIfMissing False dest
+              getDirectoryContentsWithoutSpecial src >>= mapM_ cp
    in aux srcDir destDir
 
 
@@ -370,14 +373,14 @@ withTempFile tmp_dir extn action
   where 
     findTempName x
       = do let filename = ("tmp" ++ show x) `joinFileExt` extn
-	       path = tmp_dir `joinFileName` filename
-  	   b  <- doesFileExist path
-	   if b then findTempName (x+1)
-		else action path `finally` try (removeFile path)
+               path = tmp_dir `joinFileName` filename
+           b  <- doesFileExist path
+           if b then findTempName (x+1)
+           else action path `finally` try (removeFile path)
 
 #if mingw32_HOST_OS || mingw32_TARGET_OS
 foreign import ccall unsafe "_getpid" getProcessID :: IO Int
-		 -- relies on Int == Int32 on Windows
+     -- relies on Int == Int32 on Windows
 #elif __GLASGOW_HASKELL__ || __HUGS__
 getProcessID :: IO Int
 getProcessID = System.Posix.Internals.c_getpid >>= return . fromIntegral
@@ -455,11 +458,10 @@ findHookedPackageDesc
     -> IO (Maybe FilePath)	-- ^/dir/@\/@/pkgname/@.buildinfo@, if present
 findHookedPackageDesc dir = do
     ns <- getDirectoryContents dir
-    case [dir `joinFileName`  n |
-		n <- ns, snd (splitFileExt n) == buildInfoExt] of
-	[] -> return Nothing
-	[f] -> return (Just f)
-	_ -> die ("Multiple files with extension " ++ buildInfoExt)
+    case [dir `joinFileName`  n | n <- ns, snd (splitFileExt n) == buildInfoExt] of
+     [] -> return Nothing
+     [f] -> return (Just f)
+     _ -> die ("Multiple files with extension " ++ buildInfoExt)
 
 -- ------------------------------------------------------------
 -- * Testing
diff --git a/packages/Cabal/tests/HSQL/config.mk b/packages/Cabal/tests/HSQL/config.mk
deleted file mode 100644
index f9e12b1..0000000
--- a/packages/Cabal/tests/HSQL/config.mk
+++ /dev/null
@@ -1,28 +0,0 @@
-WithODBC=NO
-WithPostgreSQL=NO
-WithMySQL=NO
-WithSQLite=NO
-
-SO_EXT = so
-
-WIN32=NO
-
-AR = /usr/bin/ar
-LD = /usr/bin/ld
-INSTALL = /usr/bin/install -c
-
-CPPFLAGS = 
-LDFLAGS =  
-
-HSC2HS = /usr/bin/hsc2hs
-
-HADDOCK = /usr/bin/haddock
-DOC_DIR = /tmp/doc/HSQL
-
-GHC     = /usr/bin/ghc
-GHC_DIR = /tmp/lib/HSQL/GHC
-GHC_PKG = /usr/bin/ghc-pkg
-
-HUGS     = /usr/bin/hugs
-HUGS_DIR = /tmp/lib/HSQL/Hugs
-FFIHUGS  = /usr/bin/ffihugs
diff --git a/packages/base/Control/Applicative.hs b/packages/base/Control/Applicative.hs
index c22c55d..36a75c3 100644
--- a/packages/base/Control/Applicative.hs
+++ b/packages/base/Control/Applicative.hs
@@ -23,24 +23,24 @@
 -- 'Data.Traversable.Traversable' class.
 
 module Control.Applicative (
-	-- * Applicative functors
-	Applicative(..),
-	-- * Alternatives
-	Alternative(..),
-	-- * Instances
-	Const(..), WrappedMonad(..), WrappedArrow(..), ZipList(..),
-	-- * Utility functions
-	(<$>), (<$), (*>), (<*), (<**>),
-	liftA, liftA2, liftA3,
-	optional, some, many
-	) where
+  -- * Applicative functors
+  Applicative(..),
+  -- * Alternatives
+  Alternative(..),
+  -- * Instances
+  Const(..), WrappedMonad(..), WrappedArrow(..), ZipList(..),
+  -- * Utility functions
+  (<$>), (<$), (*>), (<*), (<**>),
+  liftA, liftA2, liftA3,
+  optional, some, many
+  ) where
 
 #ifdef __HADDOCK__
 import Prelude
 #endif
 
 import Control.Arrow
-	(Arrow(arr, (>>>), (&&&)), ArrowZero(zeroArrow), ArrowPlus((<+>)))
+  (Arrow(arr, (>>>), (&&&)), ArrowZero(zeroArrow), ArrowPlus((<+>)))
 import Control.Monad (liftM, ap, MonadPlus(..))
 import Control.Monad.Instances ()
 import Data.Monoid (Monoid(..))
@@ -74,86 +74,86 @@ infixl 4 <*>, <*, *>, <**>
 -- If @f@ is also a 'Monad', define @'pure' = 'return'@ and @('<*>') = 'ap'@.
 
 class Functor f => Applicative f where
-	-- | Lift a value.
-	pure :: a -> f a
+  -- | Lift a value.
+  pure :: a -> f a
 
         -- | Sequential application.
-	(<*>) :: f (a -> b) -> f a -> f b
+  (<*>) :: f (a -> b) -> f a -> f b
 
 -- | A monoid on applicative functors.
 class Applicative f => Alternative f where
-	-- | The identity of '<|>'
-	empty :: f a
-	-- | An associative binary operation
-	(<|>) :: f a -> f a -> f a
+  -- | The identity of '<|>'
+  empty :: f a
+  -- | An associative binary operation
+  (<|>) :: f a -> f a -> f a
 
 -- instances for Prelude types
 
 instance Applicative Maybe where
-	pure = return
-	(<*>) = ap
+  pure = return
+  (<*>) = ap
 
 instance Alternative Maybe where
-	empty = Nothing
-	Nothing <|> p = p
-	Just x <|> _ = Just x
+  empty = Nothing
+  Nothing <|> p = p
+  Just x <|> _ = Just x
 
 instance Applicative [] where
-	pure = return
-	(<*>) = ap
+  pure = return
+  (<*>) = ap
 
 instance Alternative [] where
-	empty = []
-	(<|>) = (++)
+  empty = []
+  (<|>) = (++)
 
 instance Applicative IO where
-	pure = return
-	(<*>) = ap
+  pure = return
+  (<*>) = ap
 
 instance Applicative ((->) a) where
-	pure = const
-	(<*>) f g x = f x (g x)
+  pure = const
+  (<*>) f g x = f x (g x)
 
 instance Monoid a => Applicative ((,) a) where
-	pure x = (mempty, x)
-	(u, f) <*> (v, x) = (u `mappend` v, f x)
+  pure x = (mempty, x)
+  (u, f) <*> (v, x) = (u `mappend` v, f x)
 
 -- new instances
 
 newtype Const a b = Const { getConst :: a }
 
 instance Functor (Const m) where
-	fmap _ (Const v) = Const v
+  fmap _ (Const v) = Const v
 
 instance Monoid m => Applicative (Const m) where
-	pure _ = Const mempty
-	Const f <*> Const v = Const (f `mappend` v)
+  pure _ = Const mempty
+  Const f <*> Const v = Const (f `mappend` v)
 
 newtype WrappedMonad m a = WrapMonad { unwrapMonad :: m a }
 
 instance Monad m => Functor (WrappedMonad m) where
-	fmap f (WrapMonad v) = WrapMonad (liftM f v)
+  fmap f (WrapMonad v) = WrapMonad (liftM f v)
 
 instance Monad m => Applicative (WrappedMonad m) where
-	pure = WrapMonad . return
-	WrapMonad f <*> WrapMonad v = WrapMonad (f `ap` v)
+  pure = WrapMonad . return
+  WrapMonad f <*> WrapMonad v = WrapMonad (f `ap` v)
 
 instance MonadPlus m => Alternative (WrappedMonad m) where
-	empty = WrapMonad mzero
-	WrapMonad u <|> WrapMonad v = WrapMonad (u `mplus` v)
+  empty = WrapMonad mzero
+  WrapMonad u <|> WrapMonad v = WrapMonad (u `mplus` v)
 
 newtype WrappedArrow a b c = WrapArrow { unwrapArrow :: a b c }
 
 instance Arrow a => Functor (WrappedArrow a b) where
-	fmap f (WrapArrow a) = WrapArrow (a >>> arr f)
+  fmap f (WrapArrow a) = WrapArrow (a >>> arr f)
 
 instance Arrow a => Applicative (WrappedArrow a b) where
-	pure x = WrapArrow (arr (const x))
-	WrapArrow f <*> WrapArrow v = WrapArrow (f &&& v >>> arr (uncurry id))
+  pure x = WrapArrow (arr (const x))
+  WrapArrow f <*> WrapArrow v = WrapArrow (f &&& v >>> arr (uncurry id))
 
 instance (ArrowZero a, ArrowPlus a) => Alternative (WrappedArrow a b) where
-	empty = WrapArrow zeroArrow
-	WrapArrow u <|> WrapArrow v = WrapArrow (u <+> v)
+  empty = WrapArrow zeroArrow
+  WrapArrow u <|> WrapArrow v = WrapArrow (u <+> v)
 
 -- | Lists, but with an 'Applicative' functor based on zipping, so that
 --
@@ -162,11 +162,11 @@ instance (ArrowZero a, ArrowPlus a) => Alternative (WrappedArrow a b) where
 newtype ZipList a = ZipList { getZipList :: [a] }
 
 instance Functor ZipList where
-	fmap f (ZipList xs) = ZipList (map f xs)
+  fmap f (ZipList xs) = ZipList (map f xs)
 
 instance Applicative ZipList where
-	pure x = ZipList (repeat x)
-	ZipList fs <*> ZipList xs = ZipList (zipWith id fs xs)
+  pure x = ZipList (repeat x)
+  ZipList fs <*> ZipList xs = ZipList (zipWith id fs xs)
 
 -- extra functions
 
@@ -211,10 +211,10 @@ optional v = Just <$> v <|> pure Nothing
 some :: Alternative f => f a -> f [a]
 some v = some_v
   where many_v = some_v <|> pure []
-	some_v = (:) <$> v <*> many_v
+        some_v = (:) <$> v <*> many_v
 
 -- | Zero or more.
 many :: Alternative f => f a -> f [a]
 many v = many_v
   where many_v = some_v <|> pure []
-	some_v = (:) <$> v <*> many_v
+        some_v = (:) <$> v <*> many_v
diff --git a/packages/base/Control/Arrow.hs b/packages/base/Control/Arrow.hs
index 2710be6..1cc708e 100644
--- a/packages/base/Control/Arrow.hs
+++ b/packages/base/Control/Arrow.hs
@@ -19,22 +19,22 @@
 -- <http://www.haskell.org/arrows/>.
 
 module Control.Arrow (
-		-- * Arrows
-		Arrow(..), Kleisli(..),
-		-- ** Derived combinators
-		returnA,
-		(^>>), (>>^),
-		-- ** Right-to-left variants
-		(<<<), (<<^), (^<<),
-		-- * Monoid operations
-		ArrowZero(..), ArrowPlus(..),
-		-- * Conditionals
-		ArrowChoice(..),
-		-- * Arrow application
-		ArrowApply(..), ArrowMonad(..), leftApp,
-		-- * Feedback
-		ArrowLoop(..)
-	) where
+    -- * Arrows
+    Arrow(..), Kleisli(..),
+    -- ** Derived combinators
+    returnA,
+    (^>>), (>>^),
+    -- ** Right-to-left variants
+    (<<<), (<<^), (^<<),
+    -- * Monoid operations
+    ArrowZero(..), ArrowPlus(..),
+    -- * Conditionals
+    ArrowChoice(..),
+    -- * Arrow application
+    ArrowApply(..), ArrowMonad(..), leftApp,
+    -- * Feedback
+    ArrowLoop(..)
+  ) where
 
 import Prelude
 
@@ -56,83 +56,82 @@ infixr 1 <<<, ^<<, <<^
 
 class Arrow a where
 
-	-- | Lift a function to an arrow: you must define either this
-	--   or 'pure'.
-	arr :: (b -> c) -> a b c
-	arr = pure
-
-	-- | A synonym for 'arr': you must define one or other of them.
-	pure :: (b -> c) -> a b c
-	pure = arr
-
-	-- | Left-to-right composition of arrows.
-	(>>>) :: a b c -> a c d -> a b d
-
-	-- | Send the first component of the input through the argument
-	--   arrow, and copy the rest unchanged to the output.
-	first :: a b c -> a (b,d) (c,d)
-
-	-- | A mirror image of 'first'.
-	--
-	--   The default definition may be overridden with a more efficient
-	--   version if desired.
-	second :: a b c -> a (d,b) (d,c)
-	second f = arr swap >>> first f >>> arr swap
-			where	swap ~(x,y) = (y,x)
-
-	-- | Split the input between the two argument arrows and combine
-	--   their output.  Note that this is in general not a functor.
-	--
-	--   The default definition may be overridden with a more efficient
-	--   version if desired.
-	(***) :: a b c -> a b' c' -> a (b,b') (c,c')
-	f *** g = first f >>> second g
-
-	-- | Fanout: send the input to both argument arrows and combine
-	--   their output.
-	--
-	--   The default definition may be overridden with a more efficient
-	--   version if desired.
-	(&&&) :: a b c -> a b c' -> a b (c,c')
-	f &&& g = arr (\b -> (b,b)) >>> f *** g
+  -- | Lift a function to an arrow: you must define either this
+  --   or 'pure'.
+  arr :: (b -> c) -> a b c
+  arr = pure
+
+  -- | A synonym for 'arr': you must define one or other of them.
+  pure :: (b -> c) -> a b c
+  pure = arr
+
+  -- | Left-to-right composition of arrows.
+  (>>>) :: a b c -> a c d -> a b d
+
+  -- | Send the first component of the input through the argument
+  --   arrow, and copy the rest unchanged to the output.
+  first :: a b c -> a (b,d) (c,d)
+
+  -- | A mirror image of 'first'.
+  --
+  --   The default definition may be overridden with a more efficient
+  --   version if desired.
+  second :: a b c -> a (d,b) (d,c)
+  second f = arr swap >>> first f >>> arr swap
+      where	swap ~(x,y) = (y,x)
+
+  -- | Split the input between the two argument arrows and combine
+  --   their output.  Note that this is in general not a functor.
+  --
+  --   The default definition may be overridden with a more efficient
+  --   version if desired.
+  (***) :: a b c -> a b' c' -> a (b,b') (c,c')
+  f *** g = first f >>> second g
+
+  -- | Fanout: send the input to both argument arrows and combine
+  --   their output.
+  --
+  --   The default definition may be overridden with a more efficient
+  --   version if desired.
+  (&&&) :: a b c -> a b c' -> a b (c,c')
+  f &&& g = arr (\b -> (b,b)) >>> f *** g
 
 {-# RULES
 "compose/arr"	forall f g .
-		arr f >>> arr g = arr (f >>> g)
+    arr f >>> arr g = arr (f >>> g)
 "first/arr"	forall f .
-		first (arr f) = arr (first f)
+    first (arr f) = arr (first f)
 "second/arr"	forall f .
-		second (arr f) = arr (second f)
+    second (arr f) = arr (second f)
 "product/arr"	forall f g .
-		arr f *** arr g = arr (f *** g)
+    arr f *** arr g = arr (f *** g)
 "fanout/arr"	forall f g .
-		arr f &&& arr g = arr (f &&& g)
+    arr f &&& arr g = arr (f &&& g)
 "compose/first"	forall f g .
-		first f >>> first g = first (f >>> g)
+    first f >>> first g = first (f >>> g)
 "compose/second" forall f g .
-		second f >>> second g = second (f >>> g)
- #-}
+    second f >>> second g = second (f >>> g) #-}
 
 -- Ordinary functions are arrows.
 
 instance Arrow (->) where
-	arr f = f
-	f >>> g = g . f
-	first f = f *** id
-	second f = id *** f
+  arr f = f
+  f >>> g = g . f
+  first f = f *** id
+  second f = id *** f
 --	(f *** g) ~(x,y) = (f x, g y)
 --	sorry, although the above defn is fully H'98, nhc98 can't parse it.
-	(***) f g ~(x,y) = (f x, g y)
+  (***) f g ~(x,y) = (f x, g y)
 
 -- | Kleisli arrows of a monad.
 
 newtype Kleisli m a b = Kleisli { runKleisli :: a -> m b }
 
 instance Monad m => Arrow (Kleisli m) where
-	arr f = Kleisli (return . f)
-	Kleisli f >>> Kleisli g = Kleisli (\b -> f b >>= g)
-	first (Kleisli f) = Kleisli (\ ~(b,d) -> f b >>= \c -> return (c,d))
-	second (Kleisli f) = Kleisli (\ ~(d,b) -> f b >>= \c -> return (d,c))
+  arr f = Kleisli (return . f)
+  Kleisli f >>> Kleisli g = Kleisli (\b -> f b >>= g)
+  first (Kleisli f) = Kleisli (\ ~(b,d) -> f b >>= \c -> return (c,d))
+  second (Kleisli f) = Kleisli (\ ~(d,b) -> f b >>= \c -> return (d,c))
 
 -- | The identity arrow, which plays the role of 'return' in arrow notation.
 
@@ -160,16 +159,16 @@ a <<^ f = a <<< arr f
 f ^<< a = arr f <<< a
 
 class Arrow a => ArrowZero a where
-	zeroArrow :: a b c
+  zeroArrow :: a b c
 
 instance MonadPlus m => ArrowZero (Kleisli m) where
-	zeroArrow = Kleisli (\x -> mzero)
+  zeroArrow = Kleisli (\x -> mzero)
 
 class ArrowZero a => ArrowPlus a where
-	(<+>) :: a b c -> a b c -> a b c
+  (<+>) :: a b c -> a b c -> a b c
 
 instance MonadPlus m => ArrowPlus (Kleisli m) where
-	Kleisli f <+> Kleisli g = Kleisli (\x -> f x `mplus` g x)
+  Kleisli f <+> Kleisli g = Kleisli (\x -> f x `mplus` g x)
 
 -- | Choice, for arrows that support it.  This class underlies the
 --   @if@ and @case@ constructs in arrow notation.
@@ -188,7 +187,8 @@ class Arrow a => ArrowChoice a where
 	--   version if desired.
 	right :: a b c -> a (Either d b) (Either d c)
 	right f = arr mirror >>> left f >>> arr mirror
-			where	mirror (Left x) = Right x
+			where	
+				mirror (Left x) = Right x
 				mirror (Right y) = Left y
 
 	-- | Split the input between the two argument arrows, retagging
@@ -207,7 +207,8 @@ class Arrow a => ArrowChoice a where
 	--   version if desired.
 	(|||) :: a b d -> a c d -> a (Either b c) d
 	f ||| g = f +++ g >>> arr untag
-			where	untag (Left x) = x
+			where	
+				untag (Left x) = x
 				untag (Right y) = y
 
 {-# RULES
@@ -254,28 +255,28 @@ instance Monad m => ArrowApply (Kleisli m) where
 newtype ArrowApply a => ArrowMonad a b = ArrowMonad (a () b)
 
 instance ArrowApply a => Monad (ArrowMonad a) where
-	return x = ArrowMonad (arr (\z -> x))
-	ArrowMonad m >>= f = ArrowMonad (m >>>
-			arr (\x -> let ArrowMonad h = f x in (h, ())) >>>
-			app)
+  return x = ArrowMonad (arr (\z -> x))
+  ArrowMonad m >>= f = ArrowMonad (m >>>
+      arr (\x -> let ArrowMonad h = f x in (h, ())) >>>
+      app)
 
 -- | Any instance of 'ArrowApply' can be made into an instance of
 --   'ArrowChoice' by defining 'left' = 'leftApp'.
 
 leftApp :: ArrowApply a => a b c -> a (Either b d) (Either c d)
 leftApp f = arr ((\b -> (arr (\() -> b) >>> f >>> arr Left, ())) |||
-		 (\d -> (arr (\() -> d) >>> arr Right, ()))) >>> app
+     (\d -> (arr (\() -> d) >>> arr Right, ()))) >>> app
 
 -- | The 'loop' operator expresses computations in which an output value is
 --   fed back as input, even though the computation occurs only once.
 --   It underlies the @rec@ value recursion construct in arrow notation.
 
 class Arrow a => ArrowLoop a where
-	loop :: a (b,d) (c,d) -> a b c
+  loop :: a (b,d) (c,d) -> a b c
 
 instance ArrowLoop (->) where
-	loop f b = let (c,d) = f (b,d) in c
+  loop f b = let (c,d) = f (b,d) in c
 
 instance MonadFix m => ArrowLoop (Kleisli m) where
-	loop (Kleisli f) = Kleisli (liftM fst . mfix . f')
-		where	f' x y = f (x, snd y)
+  loop (Kleisli f) = Kleisli (liftM fst . mfix . f')
+    where	f' x y = f (x, snd y)
diff --git a/packages/base/Control/Concurrent.hs b/packages/base/Control/Concurrent.hs
index a99bc37..1e956fb 100644
--- a/packages/base/Control/Concurrent.hs
+++ b/packages/base/Control/Concurrent.hs
@@ -406,7 +406,7 @@ runInUnboundThread action = do
 
 {- $osthreads
 
-      #osthreads# In GHC, threads created by 'forkIO' are lightweight threads, and
+{--}      #osthreads# In GHC, threads created by 'forkIO' are lightweight threads, and
       are managed entirely by the GHC runtime.  Typically Haskell
       threads are an order of magnitude or two more efficient (in
       terms of both time and space) than operating system threads.
diff --git a/packages/base/Control/Exception.hs b/packages/base/Control/Exception.hs
index d789f06..5f9f108 100644
--- a/packages/base/Control/Exception.hs
+++ b/packages/base/Control/Exception.hs
@@ -27,101 +27,101 @@
 
 module Control.Exception (
 
-	-- * The Exception type
-	Exception(..),		-- instance Eq, Ord, Show, Typeable
-	IOException,		-- instance Eq, Ord, Show, Typeable
-	ArithException(..),	-- instance Eq, Ord, Show, Typeable
-	ArrayException(..),	-- instance Eq, Ord, Show, Typeable
-	AsyncException(..),	-- instance Eq, Ord, Show, Typeable
-
-	-- * Throwing exceptions
-	throwIO,	-- :: Exception -> IO a
-	throw,		-- :: Exception -> a
-	ioError,	-- :: IOError -> IO a
+  -- * The Exception type
+  Exception(..),		-- instance Eq, Ord, Show, Typeable
+  IOException,		-- instance Eq, Ord, Show, Typeable
+  ArithException(..),	-- instance Eq, Ord, Show, Typeable
+  ArrayException(..),	-- instance Eq, Ord, Show, Typeable
+  AsyncException(..),	-- instance Eq, Ord, Show, Typeable
+
+  -- * Throwing exceptions
+  throwIO,	-- :: Exception -> IO a
+  throw,		-- :: Exception -> a
+  ioError,	-- :: IOError -> IO a
 #ifdef __GLASGOW_HASKELL__
-	throwTo,	-- :: ThreadId -> Exception -> a
+  throwTo,	-- :: ThreadId -> Exception -> a
 #endif
 
-	-- * Catching Exceptions
+  -- * Catching Exceptions
 
-	-- |There are several functions for catching and examining
-    	-- exceptions; all of them may only be used from within the
-    	-- 'IO' monad.
+  -- |There are several functions for catching and examining
+      -- exceptions; all of them may only be used from within the
+      -- 'IO' monad.
 
-	-- ** The @catch@ functions
-	catch,     -- :: IO a -> (Exception -> IO a) -> IO a
-	catchJust, -- :: (Exception -> Maybe b) -> IO a -> (b -> IO a) -> IO a
+  -- ** The @catch@ functions
+  catch,     -- :: IO a -> (Exception -> IO a) -> IO a
+  catchJust, -- :: (Exception -> Maybe b) -> IO a -> (b -> IO a) -> IO a
 
-	-- ** The @handle@ functions
-	handle,	   -- :: (Exception -> IO a) -> IO a -> IO a
-	handleJust,-- :: (Exception -> Maybe b) -> (b -> IO a) -> IO a -> IO a
+  -- ** The @handle@ functions
+  handle,	   -- :: (Exception -> IO a) -> IO a -> IO a
+  handleJust,-- :: (Exception -> Maybe b) -> (b -> IO a) -> IO a -> IO a
 
-	-- ** The @try@ functions
-	try,       -- :: IO a -> IO (Either Exception a)
-	tryJust,   -- :: (Exception -> Maybe b) -> a    -> IO (Either b a)
+  -- ** The @try@ functions
+  try,       -- :: IO a -> IO (Either Exception a)
+  tryJust,   -- :: (Exception -> Maybe b) -> a    -> IO (Either b a)
 
-	-- ** The @evaluate@ function
-	evaluate,  -- :: a -> IO a
+  -- ** The @evaluate@ function
+  evaluate,  -- :: a -> IO a
 
-	-- ** The @mapException@ function
-	mapException,		-- :: (Exception -> Exception) -> a -> a
+  -- ** The @mapException@ function
+  mapException,		-- :: (Exception -> Exception) -> a -> a
 
-	-- ** Exception predicates
-	
-	-- $preds
+  -- ** Exception predicates
+  
+  -- $preds
 
-	ioErrors,		-- :: Exception -> Maybe IOError
-	arithExceptions, 	-- :: Exception -> Maybe ArithException
-	errorCalls,		-- :: Exception -> Maybe String
-	dynExceptions,		-- :: Exception -> Maybe Dynamic
-	assertions,		-- :: Exception -> Maybe String
-	asyncExceptions, 	-- :: Exception -> Maybe AsyncException
-	userErrors,		-- :: Exception -> Maybe String
+  ioErrors,		-- :: Exception -> Maybe IOError
+  arithExceptions, 	-- :: Exception -> Maybe ArithException
+  errorCalls,		-- :: Exception -> Maybe String
+  dynExceptions,		-- :: Exception -> Maybe Dynamic
+  assertions,		-- :: Exception -> Maybe String
+  asyncExceptions, 	-- :: Exception -> Maybe AsyncException
+  userErrors,		-- :: Exception -> Maybe String
 
-	-- * Dynamic exceptions
+  -- * Dynamic exceptions
 
-	-- $dynamic
-	throwDyn, 	-- :: Typeable ex => ex -> b
+  -- $dynamic
+  throwDyn, 	-- :: Typeable ex => ex -> b
 #ifdef __GLASGOW_HASKELL__
-	throwDynTo, 	-- :: Typeable ex => ThreadId -> ex -> b
+  throwDynTo, 	-- :: Typeable ex => ThreadId -> ex -> b
 #endif
-	catchDyn, 	-- :: Typeable ex => IO a -> (ex -> IO a) -> IO a
-	
-	-- * Asynchronous Exceptions
+  catchDyn, 	-- :: Typeable ex => IO a -> (ex -> IO a) -> IO a
+  
+  -- * Asynchronous Exceptions
 
-	-- $async
+  -- $async
 
-	-- ** Asynchronous exception control
+  -- ** Asynchronous exception control
 
-	-- |The following two functions allow a thread to control delivery of
-	-- asynchronous exceptions during a critical region.
+  -- |The following two functions allow a thread to control delivery of
+  -- asynchronous exceptions during a critical region.
 
         block,          -- :: IO a -> IO a
         unblock,        -- :: IO a -> IO a
 
-	-- *** Applying @block@ to an exception handler
+  -- *** Applying @block@ to an exception handler
 
-	-- $block_handler
+  -- $block_handler
 
-	-- *** Interruptible operations
+  -- *** Interruptible operations
 
-	-- $interruptible
+  -- $interruptible
 
-	-- * Assertions
+  -- * Assertions
 
-	assert,		-- :: Bool -> a -> a
+  assert,		-- :: Bool -> a -> a
 
-	-- * Utilities
+  -- * Utilities
 
-	bracket,  	-- :: IO a -> (a -> IO b) -> (a -> IO c) -> IO ()
-	bracket_, 	-- :: IO a -> IO b -> IO c -> IO ()
-	bracketOnError,
+  bracket,  	-- :: IO a -> (a -> IO b) -> (a -> IO c) -> IO ()
+  bracket_, 	-- :: IO a -> IO b -> IO c -> IO ()
+  bracketOnError,
 
-	finally, 	-- :: IO a -> IO b -> IO a
-	
+  finally, 	-- :: IO a -> IO b -> IO a
+  
 #ifdef __GLASGOW_HASKELL__
-	setUncaughtExceptionHandler,      -- :: (Exception -> IO ()) -> IO ()
-	getUncaughtExceptionHandler       -- :: IO (Exception -> IO ())
+  setUncaughtExceptionHandler,      -- :: (Exception -> IO ()) -> IO ()
+  getUncaughtExceptionHandler       -- :: IO (Exception -> IO ())
 #endif
   ) where
 
@@ -193,8 +193,8 @@ import Data.Dynamic
 --
 
 catch  	:: IO a 		-- ^ The computation to run
-  	-> (Exception -> IO a)	-- ^ Handler to invoke if an exception is raised
-  	-> IO a			
+    -> (Exception -> IO a)	-- ^ Handler to invoke if an exception is raised
+    -> IO a			
 catch =  ExceptionBase.catchException
 
 -- | The function 'catchJust' is like 'catch', but it takes an extra
@@ -210,14 +210,14 @@ catch =  ExceptionBase.catchException
 -- are re-raised, and may be caught by an enclosing
 -- 'catch' or 'catchJust'.
 catchJust
-	:: (Exception -> Maybe b) -- ^ Predicate to select exceptions
-	-> IO a		 	  -- ^ Computation to run
-	-> (b -> IO a)		  -- ^ Handler
-	-> IO a
+  :: (Exception -> Maybe b) -- ^ Predicate to select exceptions
+  -> IO a		 	  -- ^ Computation to run
+  -> (b -> IO a)		  -- ^ Handler
+  -> IO a
 catchJust p a handler = catch a handler'
   where handler' e = case p e of 
-			Nothing -> throw e
-			Just b  -> handler b
+         Nothing -> throw e
+         Just b  -> handler b
 
 -- | A version of 'catch' with the arguments swapped around; useful in
 -- situations where the code for the handler is shorter.  For example:
@@ -272,10 +272,10 @@ tryJust :: (Exception -> Maybe b) -> IO a -> IO (Either b a)
 tryJust p a = do
   r <- try a
   case r of
-	Right v -> return (Right v)
-	Left  e -> case p e of
-			Nothing -> throw e
-			Just b  -> return (Left b)
+   Right v -> return (Right v)
+   Left  e -> case p e of
+       Nothing -> throw e
+       Just b  -> return (Left b)
 
 -----------------------------------------------------------------------------
 -- Dynamic exceptions
@@ -309,11 +309,11 @@ throwDynTo t exception = throwTo t (DynException (toDyn exception))
 catchDyn :: Typeable exception => IO a -> (exception -> IO a) -> IO a
 catchDyn m k = catchException m handle
   where handle ex = case ex of
-  			   (DynException dyn) ->
-		  	  	case fromDynamic dyn of
-				    Just exception  -> k exception
-				    Nothing -> throw ex
-			   _ -> throw ex
+         (DynException dyn) ->
+             case fromDynamic dyn of
+               Just exception  -> k exception
+               Nothing -> throw ex
+         _ -> throw ex
 
 -----------------------------------------------------------------------------
 -- Exception Predicates
@@ -375,16 +375,16 @@ userErrors _ = Nothing
 -- > withFile name = bracket (openFile name) hClose
 --
 bracket 
-	:: IO a		-- ^ computation to run first (\"acquire resource\")
-	-> (a -> IO b)  -- ^ computation to run last (\"release resource\")
-	-> (a -> IO c)	-- ^ computation to run in-between
-	-> IO c		-- returns the value from the in-between computation
+  :: IO a		-- ^ computation to run first (\"acquire resource\")
+  -> (a -> IO b)  -- ^ computation to run last (\"release resource\")
+  -> (a -> IO c)	-- ^ computation to run in-between
+  -> IO c		-- returns the value from the in-between computation
 bracket before after thing =
   block (do
     a <- before 
     r <- catch 
-	   (unblock (thing a))
-	   (\e -> do { after a; throw e })
+          (unblock (thing a))
+          (\e -> do { after a; throw e })
     after a
     return r
  )
@@ -394,14 +394,14 @@ bracket before after thing =
 -- afterward.
 -- 
 finally :: IO a		-- ^ computation to run first
-	-> IO b		-- ^ computation to run afterward (even if an exception 
-			-- was raised)
-	-> IO a		-- returns the value from the first computation
+  -> IO b		-- ^ computation to run afterward (even if an exception 
+      -- was raised)
+  -> IO a		-- returns the value from the first computation
 a `finally` sequel =
   block (do
     r <- catch 
-	     (unblock a)
-	     (\e -> do { sequel; throw e })
+          (unblock a)
+          (\e -> do { sequel; throw e })
     sequel
     return r
   )
@@ -414,16 +414,16 @@ bracket_ before after thing = bracket before (const after) (const thing)
 -- | Like bracket, but only performs the final action if there was an 
 -- exception raised by the in-between computation.
 bracketOnError
-	:: IO a		-- ^ computation to run first (\"acquire resource\")
-	-> (a -> IO b)  -- ^ computation to run last (\"release resource\")
-	-> (a -> IO c)	-- ^ computation to run in-between
-	-> IO c		-- returns the value from the in-between computation
+  :: IO a		-- ^ computation to run first (\"acquire resource\")
+  -> (a -> IO b)  -- ^ computation to run last (\"release resource\")
+  -> (a -> IO c)	-- ^ computation to run in-between
+  -> IO c		-- returns the value from the in-between computation
 bracketOnError before after thing =
   block (do
     a <- before 
     catch 
-	(unblock (thing a))
-	(\e -> do { after a; throw e })
+     (unblock (thing a))
+     (\e -> do { after a; throw e })
  )
 
 -- -----------------------------------------------------------------------------
@@ -431,7 +431,7 @@ bracketOnError before after thing =
 
 {- $async
 
- #AsynchronousExceptions# Asynchronous exceptions are so-called because they arise due to
+{--} #AsynchronousExceptions# Asynchronous exceptions are so-called because they arise due to
 external influences, and can be raised at any point during execution.
 'StackOverflow' and 'HeapOverflow' are two examples of
 system-generated asynchronous exceptions.
diff --git a/packages/base/Data/Array/Base.hs b/packages/base/Data/Array/Base.hs
index 08a748a..6b953f0 100644
--- a/packages/base/Data/Array/Base.hs
+++ b/packages/base/Data/Array/Base.hs
@@ -181,7 +181,7 @@ listArrayST (l,u) es = do
 {-# RULES
 "listArray/Array" listArray =
     \lu es -> runST (listArrayST lu es >>= ArrST.unsafeFreezeSTArray)
-    #-}
+{--}    #-}
 
 {-# INLINE listUArrayST #-}
 listUArrayST :: (MArray (STUArray s) e (ST s), Ix i)
@@ -252,8 +252,7 @@ type ListUArray e = forall i . Ix i => (i,i) -> [e] -> UArray i e
 "listArray/UArray/Word32"    listArray
    = (\lu es -> runST (listUArrayST lu es >>= unsafeFreezeSTUArray)) :: ListUArray Word32
 "listArray/UArray/Word64"    listArray
-   = (\lu es -> runST (listUArrayST lu es >>= unsafeFreezeSTUArray)) :: ListUArray Word64
-    #-}
+   = (\lu es -> runST (listUArrayST lu es >>= unsafeFreezeSTUArray)) :: ListUArray Word64    #-}
 #endif
 
 {-# INLINE (!) #-}
@@ -481,7 +480,7 @@ cmpIntUArray arr1@(UArray l1 u1 _) arr2@(UArray l2 u2 _) =
 {-# SPECIALISE 
     showsIArray :: (IArray UArray e, Ix i, Show i, Show e) => 
 		   Int -> UArray i e -> ShowS
-  #-}
+{--}  #-}
 
 showsIArray :: (IArray a e, Ix i, Show i, Show e) => Int -> a i e -> ShowS
 showsIArray p a =
@@ -1525,8 +1524,7 @@ freezeSTUArray (STUArray l u marr#) = ST $ \s1# ->
 
 {-# RULES
 "freeze/STArray"  freeze = ArrST.freezeSTArray
-"freeze/STUArray" freeze = freezeSTUArray
-    #-}
+"freeze/STUArray" freeze = freezeSTUArray    #-}
 #endif /* __GLASGOW_HASKELL__ */
 
 -- In-place conversion of mutable arrays to immutable ones places
@@ -1568,7 +1566,7 @@ unsafeFreeze = freeze
 {-# RULES
 "unsafeFreeze/STArray"  unsafeFreeze = ArrST.unsafeFreezeSTArray
 "unsafeFreeze/STUArray" unsafeFreeze = unsafeFreezeSTUArray
-    #-}
+{--}    #-}
 
 -----------------------------------------------------------------------------
 -- Thawing
@@ -1597,8 +1595,7 @@ foreign import ccall unsafe "memcpy"
 
 {-# RULES
 "thaw/STArray"  thaw = ArrST.thawSTArray
-"thaw/STUArray" thaw = thawSTUArray
-    #-}
+"thaw/STUArray" thaw = thawSTUArray    #-}
 #endif /* __GLASGOW_HASKELL__ */
 
 #ifdef __HUGS__
@@ -1658,8 +1655,7 @@ unsafeThawSTUArray (UArray l u marr#) =
 
 {-# RULES
 "unsafeThaw/STArray"    unsafeThaw = ArrST.unsafeThawSTArray
-"unsafeThaw/STUArray"   unsafeThaw = unsafeThawSTUArray
-    #-}
+"unsafeThaw/STUArray"   unsafeThaw = unsafeThawSTUArray    #-}
 #endif /* __GLASGOW_HASKELL__ */
 
 -- | Casts an 'STUArray' with one element type into one with a
diff --git a/packages/base/Data/Array/Diff.hs b/packages/base/Data/Array/Diff.hs
index 3e86f89..77e4b28 100644
--- a/packages/base/Data/Array/Diff.hs
+++ b/packages/base/Data/Array/Diff.hs
@@ -365,7 +365,7 @@ freezeDiffArray a = do
 
 {-# RULES
 "freeze/DiffArray" freeze = freezeDiffArray
-    #-}
+{--}    #-}
 
 -- unsafeFreezeDiffArray is really unsafe. Better don't use the old
 -- array at all after freezing. The contents of the source array will
@@ -380,7 +380,7 @@ unsafeFreezeDiffArray a = do
 
 {-# RULES
 "unsafeFreeze/DiffArray" unsafeFreeze = unsafeFreezeDiffArray
-    #-}
+{--}    #-}
 
 thawDiffArray :: (MArray a e IO, Ix ix)
               => IOToDiffArray a ix e
@@ -400,7 +400,7 @@ thawDiffArray a = do
 
 {-# RULES
 "thaw/DiffArray" thaw = thawDiffArray
-    #-}
+{--}    #-}
 
 -- unsafeThawDiffArray is really unsafe. Better don't use the old
 -- array at all after thawing. The contents of the resulting array
@@ -420,4 +420,4 @@ unsafeThawDiffArray a = do
 
 {-# RULES
 "unsafeThaw/DiffArray" unsafeThaw = unsafeThawDiffArray
-    #-}
+{--}    #-}
diff --git a/packages/base/Data/Array/IO.hs b/packages/base/Data/Array/IO.hs
index a476a32..ed8c40c 100644
--- a/packages/base/Data/Array/IO.hs
+++ b/packages/base/Data/Array/IO.hs
@@ -63,8 +63,7 @@ freezeIOUArray (IOUArray marr) = stToIO (freezeSTUArray marr)
 
 {-# RULES
 "freeze/IOArray"  freeze = freezeIOArray
-"freeze/IOUArray" freeze = freezeIOUArray
-    #-}
+"freeze/IOUArray" freeze = freezeIOUArray    #-}
 
 {-# INLINE unsafeFreezeIOArray #-}
 unsafeFreezeIOArray :: Ix ix => IOArray ix e -> IO (Array ix e)
@@ -76,8 +75,7 @@ unsafeFreezeIOUArray (IOUArray marr) = stToIO (unsafeFreezeSTUArray marr)
 
 {-# RULES
 "unsafeFreeze/IOArray"  unsafeFreeze = unsafeFreezeIOArray
-"unsafeFreeze/IOUArray" unsafeFreeze = unsafeFreezeIOUArray
-    #-}
+"unsafeFreeze/IOUArray" unsafeFreeze = unsafeFreezeIOUArray    #-}
 
 -----------------------------------------------------------------------------
 -- Thawing
@@ -94,8 +92,7 @@ thawIOUArray arr = stToIO $ do
 
 {-# RULES
 "thaw/IOArray"  thaw = thawIOArray
-"thaw/IOUArray" thaw = thawIOUArray
-    #-}
+"thaw/IOUArray" thaw = thawIOUArray    #-}
 
 {-# INLINE unsafeThawIOArray #-}
 unsafeThawIOArray :: Ix ix => Array ix e -> IO (IOArray ix e)
@@ -111,8 +108,7 @@ unsafeThawIOUArray arr = stToIO $ do
 
 {-# RULES
 "unsafeThaw/IOArray"  unsafeThaw = unsafeThawIOArray
-"unsafeThaw/IOUArray" unsafeThaw = unsafeThawIOUArray
-    #-}
+"unsafeThaw/IOUArray" unsafeThaw = unsafeThawIOUArray    #-}
 
 -- ---------------------------------------------------------------------------
 -- hGetArray
diff --git a/packages/base/Data/Bits.hs b/packages/base/Data/Bits.hs
index ded147a..a5b4321 100644
--- a/packages/base/Data/Bits.hs
+++ b/packages/base/Data/Bits.hs
@@ -230,12 +230,12 @@ instance Bits Int where
 #endif /* __NHC__ */
 
     x `rotate`  i
-	| i<0 && x<0       = let left = i+bitSize x in
+	    | i<0 && x<0       = let left = i+bitSize x in
                              ((x `shift` i) .&. complement ((-1) `shift` left))
                              .|. (x `shift` left)
-	| i<0              = (x `shift` i) .|. (x `shift` (i+bitSize x))
-	| i==0             = x
-	| i>0              = (x `shift` i) .|. (x `shift` (i-bitSize x))
+	    | i<0              = (x `shift` i) .|. (x `shift` (i+bitSize x))
+	    | i==0             = x
+	    | i>0              = (x `shift` i) .|. (x `shift` (i-bitSize x))
 
 #endif /* !__GLASGOW_HASKELL__ */
 
@@ -324,7 +324,7 @@ toInts n
     | n == 0 = []
     | otherwise = mkInt (n `mod` numInts):toInts (n `div` numInts)
   where mkInt n | n > toInteger(maxBound::Int) = fromInteger (n-numInts)
-		| otherwise = fromInteger n
+		                | otherwise = fromInteger n
 
 fromInts :: [Int] -> Integer
 fromInts = foldr catInt 0
diff --git a/packages/base/Data/ByteString.hs b/packages/base/Data/ByteString.hs
index 64554b8..4c3460a 100644
--- a/packages/base/Data/ByteString.hs
+++ b/packages/base/Data/ByteString.hs
@@ -447,8 +447,7 @@ unpackList (PS fp off len) = withPtr fp $ \p -> do
     loop (p `plusPtr` off) (len-1) []
 
 {-# RULES
-    "FPS unpack-list"  [1]  forall p  . unpackFoldr p (:) [] = unpackList p
- #-}
+    "FPS unpack-list"  [1]  forall p  . unpackFoldr p (:) [] = unpackList p #-}
 
 #endif
 
@@ -486,7 +485,7 @@ lengthU = foldl' (const . (+1)) (0::Int)
   length  (loopArr (loopWrapper loop s)) =
   lengthU (loopArr (loopWrapper loop s))
 
-  #-}
+{--}  #-}
 
 ------------------------------------------------------------------------
 
@@ -796,7 +795,7 @@ minimumU = foldl1' min
   maximum  (loopArr (loopWrapper loop s)) =
   maximumU (loopArr (loopWrapper loop s))
 
-  #-}
+{--}  #-}
 
 ------------------------------------------------------------------------
 
@@ -975,13 +974,12 @@ break p ps = case findIndexOrEnd p ps of n -> (unsafeTake n ps, unsafeDrop n ps)
 {-# RULES
 "FPS specialise break (x==)" forall x.
     break ((==) x) = breakByte x
-  #-}
+{--}  #-}
 
 #if __GLASGOW_HASKELL__ >= 605
 {-# RULES
 "FPS specialise break (==x)" forall x.
-    break (==x) = breakByte x
-  #-}
+    break (==x) = breakByte x  #-}
 #endif
 
 -- | 'breakByte' breaks its ByteString argument at the first occurence
@@ -1029,13 +1027,12 @@ spanByte c ps@(PS x s l) = inlinePerformIO $ withForeignPtr x $ \p ->
 {-# RULES
 "FPS specialise span (x==)" forall x.
     span ((==) x) = spanByte x
-  #-}
+{--}  #-}
 
 #if __GLASGOW_HASKELL__ >= 605
 {-# RULES
 "FPS specialise span (==x)" forall x.
-    span (==x) = spanByte x
-  #-}
+    span (==x) = spanByte x  #-}
 #endif
 
 -- | 'spanEnd' behaves like 'span' but from the end of the 'ByteString'.
@@ -1201,7 +1198,7 @@ join s = concat . (List.intersperse s)
 {-# RULES
 "FPS specialise join c -> joinByte" forall c s1 s2 .
     join (singleton c) (s1 : s2 : []) = joinWithByte c s1 s2
-  #-}
+{--}  #-}
 
 --
 -- | /O(n)/ joinWithByte. An efficient way to join to two ByteStrings
@@ -1403,13 +1400,13 @@ filterByte w ps = replicate (count w ps) w
 {-# RULES
   "FPS specialise filter (== x)" forall x.
       filter ((==) x) = filterByte x
-  #-}
+{--}  #-}
 
 #if __GLASGOW_HASKELL__ >= 605
 {-# RULES
   "FPS specialise filter (== x)" forall x.
      filter (== x) = filterByte x
-  #-}
+{--}  #-}
 #endif
 
 --
@@ -1427,13 +1424,13 @@ filterNotByte w = filter (/= w)
 {-# RULES
 "FPS specialise filter (x /=)" forall x.
     filter ((/=) x) = filterNotByte x
-  #-}
+{--}  #-}
 
 #if __GLASGOW_HASKELL__ >= 605
 {-# RULES
 "FPS specialise filter (/= x)" forall x.
     filter (/= x) = filterNotByte x
-  #-}
+{--}  #-}
 #endif
 
 -- | /O(n)/ The 'find' function takes a predicate and a ByteString,
@@ -1584,9 +1581,7 @@ zipWith' f (PS fp s l) (PS fq t m) = inlinePerformIO $
 {-# RULES
 
 "FPS specialise zipWith" forall (f :: Word8 -> Word8 -> Word8) p q .
-    zipWith f p q = unpack (zipWith' f p q)
-
-  #-}
+    zipWith f p q = unpack (zipWith' f p q)  #-}
 
 -- | /O(n)/ 'unzip' transforms a list of pairs of bytes into a pair of
 -- ByteStrings. Note that this performs two 'pack' operations.
diff --git a/packages/base/Data/ByteString/Char8.hs b/packages/base/Data/ByteString/Char8.hs
index 03b492d..0f74313 100644
--- a/packages/base/Data/ByteString/Char8.hs
+++ b/packages/base/Data/ByteString/Char8.hs
@@ -312,8 +312,7 @@ pack str = B.unsafeCreate (P.length str) $ \(Ptr p) -> stToIO (go p str)
 
 {-# RULES
     "FPS pack/packAddress" forall s .
-       pack (unpackCString# s) = B.packAddress s
- #-}
+       pack (unpackCString# s) = B.packAddress s #-}
 
 #endif
 
@@ -779,8 +778,7 @@ unsafeHead  = w2c . B.unsafeHead
 
 {-# RULES
     "FPS specialise break -> breakSpace"
-        break isSpace = breakSpace
-  #-}
+        break isSpace = breakSpace  #-}
 
 -- | 'breakSpace' returns the pair of ByteStrings when the argument is
 -- broken at the first whitespace byte. I.e.
@@ -806,8 +804,7 @@ firstspace ptr n m
 
 {-# RULES
     "FPS specialise dropWhile isSpace -> dropSpace"
-        dropWhile isSpace = dropSpace
-  #-}
+        dropWhile isSpace = dropSpace  #-}
 
 -- | 'dropSpace' efficiently returns the 'ByteString' argument with
 -- white space Chars removed from the front. It is more efficient than
diff --git a/packages/base/Data/ByteString/Fusion.hs b/packages/base/Data/ByteString/Fusion.hs
index d6c91ac..00c67d2 100644
--- a/packages/base/Data/ByteString/Fusion.hs
+++ b/packages/base/Data/ByteString/Fusion.hs
@@ -238,7 +238,7 @@ loopU f start (PS z s i) = unsafePerformIO $ withForeignPtr z $ \a -> do
   loopU em2 start2 (loopArr (loopU em1 start1 arr)) =
     loopSndAcc (loopU (em1 `fuseEFL` em2) (start1 :*: start2) arr)
 
-  #-}
+{--}  #-}
 
 --
 -- Functional list/array fusion for lazy ByteStrings.
@@ -265,7 +265,7 @@ loopL f = loop
   loopL em2 start2 (loopArr (loopL em1 start1 arr)) =
     loopSndAcc (loopL (em1 `fuseEFL` em2) (start1 :*: start2) arr)
 
-  #-}
+{--}  #-}
 
 
 {-
@@ -536,9 +536,7 @@ sequenceLoops loop1 loop2 src dest len0 = do
 
 "FPS down/noAcc loop fusion" forall f1 f2 acc1 acc2.
   sequenceLoops (doDownLoop f1 acc1) (doNoAccLoop f2 acc2) =
-    doDownLoop (f1 `fuseAccNoAccEFL` f2) (acc1 :*: acc2)
-
-  #-}
+    doDownLoop (f1 `fuseAccNoAccEFL` f2) (acc1 :*: acc2)  #-}
 
 {-
 
diff --git a/packages/base/Data/Dynamic.hs b/packages/base/Data/Dynamic.hs
index 933224c..6f8ae62 100644
--- a/packages/base/Data/Dynamic.hs
+++ b/packages/base/Data/Dynamic.hs
@@ -21,20 +21,20 @@
 module Data.Dynamic
   (
 
-	-- Module Data.Typeable re-exported for convenience
-	module Data.Typeable,
-
-	-- * The @Dynamic@ type
-	Dynamic,	-- abstract, instance of: Show, Typeable
-
-	-- * Converting to and from @Dynamic@
-	toDyn,		-- :: Typeable a => a -> Dynamic
-	fromDyn,	-- :: Typeable a => Dynamic -> a -> a
-	fromDynamic,	-- :: Typeable a => Dynamic -> Maybe a
-	
-	-- * Applying functions of dynamic type
-	dynApply,
-	dynApp,
+  -- Module Data.Typeable re-exported for convenience
+  module Data.Typeable,
+
+  -- * The @Dynamic@ type
+  Dynamic,	-- abstract, instance of: Show, Typeable
+
+  -- * Converting to and from @Dynamic@
+  toDyn,		-- :: Typeable a => a -> Dynamic
+  fromDyn,	-- :: Typeable a => Dynamic -> a -> a
+  fromDynamic,	-- :: Typeable a => Dynamic -> Maybe a
+  
+  -- * Applying functions of dynamic type
+  dynApply,
+  dynApp,
         dynTypeRep
 
   ) where
@@ -95,8 +95,8 @@ instance Show Dynamic where
    -- the instance just prints the type representation.
    showsPrec _ (Dynamic t _) = 
           showString "<<" . 
-	  showsPrec 0 t   . 
-	  showString ">>"
+          showsPrec 0 t   . 
+          showString ">>"
 
 #ifdef __GLASGOW_HASKELL__
 type Obj = forall a . a
@@ -128,11 +128,11 @@ toDyn v = Dynamic (typeOf v) (unsafeCoerce v)
 -- | Converts a 'Dynamic' object back into an ordinary Haskell value of
 -- the correct type.  See also 'fromDynamic'.
 fromDyn :: Typeable a
- 	=> Dynamic 	-- ^ the dynamically-typed object
-	-> a		-- ^ a default value 
-	-> a		-- ^ returns: the value of the first argument, if
-			-- it has the correct type, otherwise the value of
-			-- the second argument.
+   => Dynamic 	-- ^ the dynamically-typed object
+  -> a		-- ^ a default value 
+  -> a		-- ^ returns: the value of the first argument, if
+      -- it has the correct type, otherwise the value of
+      -- the second argument.
 fromDyn (Dynamic t v) def
   | typeOf def == t = unsafeCoerce v
   | otherwise       = def
@@ -140,11 +140,11 @@ fromDyn (Dynamic t v) def
 -- | Converts a 'Dynamic' object back into an ordinary Haskell value of
 -- the correct type.  See also 'fromDyn'.
 fromDynamic
-	:: Typeable a
-	=> Dynamic	-- ^ the dynamically-typed object
-	-> Maybe a	-- ^ returns: @'Just' a@, if the dynamically-typed
-			-- object has the correct type (and @a@ is its value), 
-			-- or 'Nothing' otherwise.
+  :: Typeable a
+  => Dynamic	-- ^ the dynamically-typed object
+  -> Maybe a	-- ^ returns: @'Just' a@, if the dynamically-typed
+      -- object has the correct type (and @a@ is its value), 
+      -- or 'Nothing' otherwise.
 fromDynamic (Dynamic t v) =
   case unsafeCoerce v of 
     r | t == typeOf r -> Just r
diff --git a/packages/base/Data/Foldable.hs b/packages/base/Data/Foldable.hs
index d245aa9..f807da0 100644
--- a/packages/base/Data/Foldable.hs
+++ b/packages/base/Data/Foldable.hs
@@ -17,47 +17,47 @@
 -- for this module.
 
 module Data.Foldable (
-	-- * Folds
-	Foldable(..),
-	-- ** Special biased folds
-	foldr',
-	foldl',
-	foldrM,
-	foldlM,
-	-- ** Folding actions
-	-- *** Applicative actions
-	traverse_,
-	for_,
-	sequenceA_,
-	asum,
-	-- *** Monadic actions
-	mapM_,
-	forM_,
-	sequence_,
-	msum,
-	-- ** Specialized folds
-	toList,
-	concat,
-	concatMap,
-	and,
-	or,
-	any,
-	all,
-	sum,
-	product,
-	maximum,
-	maximumBy,
-	minimum,
-	minimumBy,
-	-- ** Searches
-	elem,
-	notElem,
-	find
-	) where
+  -- * Folds
+  Foldable(..),
+  -- ** Special biased folds
+  foldr',
+  foldl',
+  foldrM,
+  foldlM,
+  -- ** Folding actions
+  -- *** Applicative actions
+  traverse_,
+  for_,
+  sequenceA_,
+  asum,
+  -- *** Monadic actions
+  mapM_,
+  forM_,
+  sequence_,
+  msum,
+  -- ** Specialized folds
+  toList,
+  concat,
+  concatMap,
+  and,
+  or,
+  any,
+  all,
+  sum,
+  product,
+  maximum,
+  maximumBy,
+  minimum,
+  minimumBy,
+  -- ** Searches
+  elem,
+  notElem,
+  find
+  ) where
 
 import Prelude hiding (foldl, foldr, foldl1, foldr1, mapM_, sequence_,
-		elem, notElem, concat, concatMap, and, or, any, all,
-		sum, product, maximum, minimum)
+    elem, notElem, concat, concatMap, and, or, any, all,
+    sum, product, maximum, minimum)
 import qualified Prelude (foldl, foldr, foldl1, foldr1)
 import Control.Applicative
 import Control.Monad (MonadPlus(..))
@@ -92,64 +92,64 @@ import GHC.Exts (build)
 -- to satisfy the monoid laws.
 --
 class Foldable t where
-	-- | Combine the elements of a structure using a monoid.
-	fold :: Monoid m => t m -> m
-	fold = foldMap id
-
-	-- | Map each element of the structure to a monoid,
-	-- and combine the results.
-	foldMap :: Monoid m => (a -> m) -> t a -> m
-	foldMap f = foldr (mappend . f) mempty
-
-	-- | Right-associative fold of a structure.
-	--
-	-- @'foldr' f z = 'Prelude.foldr' f z . 'toList'@
-	foldr :: (a -> b -> b) -> b -> t a -> b
-	foldr f z t = appEndo (foldMap (Endo . f) t) z
-
-	-- | Left-associative fold of a structure.
-	--
-	-- @'foldl' f z = 'Prelude.foldl' f z . 'toList'@
-	foldl :: (a -> b -> a) -> a -> t b -> a
-	foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z
-
-	-- | A variant of 'foldr' that has no base case,
-	-- and thus may only be applied to non-empty structures.
-	--
-	-- @'foldr1' f = 'Prelude.foldr1' f . 'toList'@
-	foldr1 :: (a -> a -> a) -> t a -> a
-	foldr1 f xs = fromMaybe (error "foldr1: empty structure")
-			(foldr mf Nothing xs)
-	  where mf x Nothing = Just x
-		mf x (Just y) = Just (f x y)
-
-	-- | A variant of 'foldl' that has no base case,
-	-- and thus may only be applied to non-empty structures.
-	--
-	-- @'foldl1' f = 'Prelude.foldl1' f . 'toList'@
-	foldl1 :: (a -> a -> a) -> t a -> a
-	foldl1 f xs = fromMaybe (error "foldl1: empty structure")
-			(foldl mf Nothing xs)
-	  where mf Nothing y = Just y
-		mf (Just x) y = Just (f x y)
+  -- | Combine the elements of a structure using a monoid.
+  fold :: Monoid m => t m -> m
+  fold = foldMap id
+
+  -- | Map each element of the structure to a monoid,
+  -- and combine the results.
+  foldMap :: Monoid m => (a -> m) -> t a -> m
+  foldMap f = foldr (mappend . f) mempty
+
+  -- | Right-associative fold of a structure.
+  --
+  -- @'foldr' f z = 'Prelude.foldr' f z . 'toList'@
+  foldr :: (a -> b -> b) -> b -> t a -> b
+  foldr f z t = appEndo (foldMap (Endo . f) t) z
+
+  -- | Left-associative fold of a structure.
+  --
+  -- @'foldl' f z = 'Prelude.foldl' f z . 'toList'@
+  foldl :: (a -> b -> a) -> a -> t b -> a
+  foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z
+
+  -- | A variant of 'foldr' that has no base case,
+  -- and thus may only be applied to non-empty structures.
+  --
+  -- @'foldr1' f = 'Prelude.foldr1' f . 'toList'@
+  foldr1 :: (a -> a -> a) -> t a -> a
+  foldr1 f xs = fromMaybe (error "foldr1: empty structure")
+      (foldr mf Nothing xs)
+    where mf x Nothing = Just x
+          mf x (Just y) = Just (f x y)
+
+  -- | A variant of 'foldl' that has no base case,
+  -- and thus may only be applied to non-empty structures.
+  --
+  -- @'foldl1' f = 'Prelude.foldl1' f . 'toList'@
+  foldl1 :: (a -> a -> a) -> t a -> a
+  foldl1 f xs = fromMaybe (error "foldl1: empty structure")
+      (foldl mf Nothing xs)
+    where mf Nothing y = Just y
+          mf (Just x) y = Just (f x y)
 
 -- instances for Prelude types
 
 instance Foldable Maybe where
-	foldr f z Nothing = z
-	foldr f z (Just x) = f x z
+  foldr f z Nothing = z
+  foldr f z (Just x) = f x z
 
-	foldl f z Nothing = z
-	foldl f z (Just x) = f z x
+  foldl f z Nothing = z
+  foldl f z (Just x) = f z x
 
 instance Foldable [] where
-	foldr = Prelude.foldr
-	foldl = Prelude.foldl
-	foldr1 = Prelude.foldr1
-	foldl1 = Prelude.foldl1
+  foldr = Prelude.foldr
+  foldl = Prelude.foldl
+  foldr1 = Prelude.foldr1
+  foldl1 = Prelude.foldl1
 
 instance Ix i => Foldable (Array i) where
-	foldr f z = Prelude.foldr f z . elems
+  foldr f z = Prelude.foldr f z . elems
 
 -- | Fold over the elements of a structure,
 -- associating to the right, but strictly.
@@ -271,8 +271,8 @@ maximum = foldr1 max
 maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
 maximumBy cmp = foldr1 max'
   where max' x y = case cmp x y of
-			GT -> x
-			_  -> y
+          GT -> x
+          _  -> y
 
 -- | The least element of a non-empty structure.
 minimum :: (Foldable t, Ord a) => t a -> a
@@ -283,8 +283,8 @@ minimum = foldr1 min
 minimumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
 minimumBy cmp = foldr1 min'
   where min' x y = case cmp x y of
-			GT -> y
-			_  -> x
+         GT -> y
+         _  -> x
 
 -- | Does the element occur in the structure?
 elem :: (Foldable t, Eq a) => a -> t a -> Bool
diff --git a/packages/base/Data/IORef.hs b/packages/base/Data/IORef.hs
index 7a6ec7d..a5ea4da 100644
--- a/packages/base/Data/IORef.hs
+++ b/packages/base/Data/IORef.hs
@@ -14,18 +14,18 @@
 
 module Data.IORef
   ( 
-	-- * IORefs
-	IORef,		      -- abstract, instance of: Eq, Typeable
-	newIORef,	      -- :: a -> IO (IORef a)
+  -- * IORefs
+  IORef,		      -- abstract, instance of: Eq, Typeable
+  newIORef,	      -- :: a -> IO (IORef a)
         readIORef,	      -- :: IORef a -> IO a
         writeIORef,	      -- :: IORef a -> a -> IO ()
-	modifyIORef,	      -- :: IORef a -> (a -> a) -> IO ()
-	atomicModifyIORef,    -- :: IORef a -> (a -> (a,b)) -> IO b
+  modifyIORef,	      -- :: IORef a -> (a -> a) -> IO ()
+  atomicModifyIORef,    -- :: IORef a -> (a -> (a,b)) -> IO b
 
 #if !defined(__PARALLEL_HASKELL__) && defined(__GLASGOW_HASKELL__)
-	mkWeakIORef,          -- :: IORef a -> IO () -> IO (Weak (IORef a))
+  mkWeakIORef,          -- :: IORef a -> IO () -> IO (Weak (IORef a))
 #endif
-	) where
+  ) where
 
 import Prelude	-- Explicit dependency helps 'make depend' do the right thing
 
@@ -81,8 +81,8 @@ atomicModifyIORef (IORef (STRef r#)) f = IO $ \s -> atomicModifyMutVar# r# f s
 #elif defined(__HUGS__)
 atomicModifyIORef = plainModifyIORef	-- Hugs has no preemption
   where plainModifyIORef r f = do
-		a <- readIORef r
-		case f a of (a',b) -> writeIORef r a' >> return b
+          a <- readIORef r
+          case f a of (a',b) -> writeIORef r a' >> return b
 #elif defined(__NHC__)
 atomicModifyIORef r f =
   excludeFinalisers $ do
diff --git a/packages/base/Data/List.hs b/packages/base/Data/List.hs
index 7c3cede..740c733 100644
--- a/packages/base/Data/List.hs
+++ b/packages/base/Data/List.hs
@@ -248,10 +248,10 @@ findIndices p xs = [ i | (x,i) <- zip xs [0..], p x]
 #else
 -- Efficient definition
 findIndices p ls = loop 0# ls
-		 where
-	 	   loop _ [] = []
-		   loop n (x:xs) | p x       = I# n : loop (n +# 1#) xs
-				 | otherwise = loop (n +# 1#) xs
+     where
+        loop _ [] = []
+       loop n (x:xs) | p x       = I# n : loop (n +# 1#) xs
+         | otherwise = loop (n +# 1#) xs
 #endif  /* USE_REPORT_PRELUDE */
 
 -- | The 'isPrefixOf' function takes two lists and returns 'True'
@@ -292,8 +292,8 @@ nub l                   = nub' l []		-- '
   where
     nub' [] _		= []			-- '
     nub' (x:xs) ls				-- '
-	| x `elem` ls   = nub' xs ls		-- '
-	| otherwise     = x : nub' xs (x:ls)	-- '
+        | x `elem` ls   = nub' xs ls		-- '
+        | otherwise     = x : nub' xs (x:ls)	-- '
 #endif
 
 -- | The 'nubBy' function behaves just like 'nub', except it uses a
@@ -425,30 +425,30 @@ select p x ~(ts,fs) | p x       = (x:ts,fs)
 -- an accumulating parameter from left to right, and returning a final
 -- value of this accumulator together with the new list.
 mapAccumL :: (acc -> x -> (acc, y)) -- Function of elt of input list
-				    -- and accumulator, returning new
-				    -- accumulator and elt of result list
-   	  -> acc	    -- Initial accumulator 
-	  -> [x]	    -- Input list
-	  -> (acc, [y])	    -- Final accumulator and result list
+            -- and accumulator, returning new
+            -- accumulator and elt of result list
+       -> acc	    -- Initial accumulator 
+    -> [x]	    -- Input list
+    -> (acc, [y])	    -- Final accumulator and result list
 mapAccumL _ s []     	=  (s, [])
 mapAccumL f s (x:xs) 	=  (s'',y:ys)
-		           where (s', y ) = f s x
-			         (s'',ys) = mapAccumL f s' xs
+               where (s', y ) = f s x
+                     (s'',ys) = mapAccumL f s' xs
 
 -- | The 'mapAccumR' function behaves like a combination of 'map' and
 -- 'foldr'; it applies a function to each element of a list, passing
 -- an accumulating parameter from right to left, and returning a final
 -- value of this accumulator together with the new list.
 mapAccumR :: (acc -> x -> (acc, y)) 	-- Function of elt of input list
-					-- and accumulator, returning new
-					-- accumulator and elt of result list
-	    -> acc 		-- Initial accumulator
-	    -> [x] 		-- Input list
-	    -> (acc, [y])		-- Final accumulator and result list
+          -- and accumulator, returning new
+          -- accumulator and elt of result list
+      -> acc 		-- Initial accumulator
+      -> [x] 		-- Input list
+      -> (acc, [y])		-- Final accumulator and result list
 mapAccumR _ s []     	=  (s, [])
 mapAccumR f s (x:xs)	=  (s'', y:ys)
-		           where (s'',y ) = f s' x
-			         (s', ys) = mapAccumR f s xs
+               where (s'',y ) = f s' x
+                     (s', ys) = mapAccumR f s xs
 
 -- | The 'insert' function takes an element and a list and inserts the
 -- element into the list at the last position where it is still less
@@ -514,10 +514,10 @@ strictMinimum xs        =  foldl1' min xs
 maximumBy		:: (a -> a -> Ordering) -> [a] -> a
 maximumBy _ []		=  error "List.maximumBy: empty list"
 maximumBy cmp xs	=  foldl1 max xs
-			where
-			   max x y = case cmp x y of
-					GT -> x
-					_  -> y
+      where
+         max x y = case cmp x y of
+          GT -> x
+          _  -> y
 
 -- | The 'minimumBy' function takes a comparison function and a list
 -- and returns the least element of the list by the comparison function.
@@ -525,10 +525,10 @@ maximumBy cmp xs	=  foldl1 max xs
 minimumBy		:: (a -> a -> Ordering) -> [a] -> a
 minimumBy _ []		=  error "List.minimumBy: empty list"
 minimumBy cmp xs	=  foldl1 min xs
-			where
-			   min x y = case cmp x y of
-					GT -> y
-					_  -> x
+      where
+         min x y = case cmp x y of
+          GT -> y
+          _  -> x
 
 -- | The 'genericLength' function is an overloaded version of 'length'.  In
 -- particular, instead of returning an 'Int', it returns any type which is
@@ -603,7 +603,7 @@ zip7			=  zipWith7 (,,,,,,)
 -- combination, analogous to 'zipWith'.
 zipWith4		:: (a->b->c->d->e) -> [a]->[b]->[c]->[d]->[e]
 zipWith4 z (a:as) (b:bs) (c:cs) (d:ds)
-			=  z a b c d : zipWith4 z as bs cs ds
+      =  z a b c d : zipWith4 z as bs cs ds
 zipWith4 _ _ _ _ _	=  []
 
 -- | The 'zipWith5' function takes a function which combines five
@@ -612,7 +612,7 @@ zipWith4 _ _ _ _ _	=  []
 zipWith5		:: (a->b->c->d->e->f) -> 
                            [a]->[b]->[c]->[d]->[e]->[f]
 zipWith5 z (a:as) (b:bs) (c:cs) (d:ds) (e:es)
-			=  z a b c d e : zipWith5 z as bs cs ds es
+      =  z a b c d e : zipWith5 z as bs cs ds es
 zipWith5 _ _ _ _ _ _	= []
 
 -- | The 'zipWith6' function takes a function which combines six
@@ -621,7 +621,7 @@ zipWith5 _ _ _ _ _ _	= []
 zipWith6		:: (a->b->c->d->e->f->g) ->
                            [a]->[b]->[c]->[d]->[e]->[f]->[g]
 zipWith6 z (a:as) (b:bs) (c:cs) (d:ds) (e:es) (f:fs)
-			=  z a b c d e f : zipWith6 z as bs cs ds es fs
+      =  z a b c d e f : zipWith6 z as bs cs ds es fs
 zipWith6 _ _ _ _ _ _ _	= []
 
 -- | The 'zipWith7' function takes a function which combines seven
@@ -630,36 +630,36 @@ zipWith6 _ _ _ _ _ _ _	= []
 zipWith7		:: (a->b->c->d->e->f->g->h) ->
                            [a]->[b]->[c]->[d]->[e]->[f]->[g]->[h]
 zipWith7 z (a:as) (b:bs) (c:cs) (d:ds) (e:es) (f:fs) (g:gs)
-		   =  z a b c d e f g : zipWith7 z as bs cs ds es fs gs
+       =  z a b c d e f g : zipWith7 z as bs cs ds es fs gs
 zipWith7 _ _ _ _ _ _ _ _ = []
 
 -- | The 'unzip4' function takes a list of quadruples and returns four
 -- lists, analogous to 'unzip'.
 unzip4			:: [(a,b,c,d)] -> ([a],[b],[c],[d])
 unzip4			=  foldr (\(a,b,c,d) ~(as,bs,cs,ds) ->
-					(a:as,b:bs,c:cs,d:ds))
-				 ([],[],[],[])
+          (a:as,b:bs,c:cs,d:ds))
+         ([],[],[],[])
 
 -- | The 'unzip5' function takes a list of five-tuples and returns five
 -- lists, analogous to 'unzip'.
 unzip5			:: [(a,b,c,d,e)] -> ([a],[b],[c],[d],[e])
 unzip5			=  foldr (\(a,b,c,d,e) ~(as,bs,cs,ds,es) ->
-					(a:as,b:bs,c:cs,d:ds,e:es))
-				 ([],[],[],[],[])
+          (a:as,b:bs,c:cs,d:ds,e:es))
+         ([],[],[],[],[])
 
 -- | The 'unzip6' function takes a list of six-tuples and returns six
 -- lists, analogous to 'unzip'.
 unzip6			:: [(a,b,c,d,e,f)] -> ([a],[b],[c],[d],[e],[f])
 unzip6			=  foldr (\(a,b,c,d,e,f) ~(as,bs,cs,ds,es,fs) ->
-					(a:as,b:bs,c:cs,d:ds,e:es,f:fs))
-				 ([],[],[],[],[],[])
+          (a:as,b:bs,c:cs,d:ds,e:es,f:fs))
+         ([],[],[],[],[],[])
 
 -- | The 'unzip7' function takes a list of seven-tuples and returns
 -- seven lists, analogous to 'unzip'.
 unzip7		:: [(a,b,c,d,e,f,g)] -> ([a],[b],[c],[d],[e],[f],[g])
 unzip7		=  foldr (\(a,b,c,d,e,f,g) ~(as,bs,cs,ds,es,fs,gs) ->
-				(a:as,b:bs,c:cs,d:ds,e:es,f:fs,g:gs))
-			 ([],[],[],[],[],[],[])
+        (a:as,b:bs,c:cs,d:ds,e:es,f:fs,g:gs))
+       ([],[],[],[],[],[],[])
 
 
 -- | The 'deleteFirstsBy' function takes a predicate and two lists and
@@ -807,7 +807,7 @@ qpart cmp x [] rlt rge r =
     rqsort cmp rlt (x:rqsort cmp rge r)
 qpart cmp x (y:ys) rlt rge r =
     case cmp x y of
-	GT -> qpart cmp x ys (y:rlt) rge r
+  GT -> qpart cmp x ys (y:rlt) rge r
         _  -> qpart cmp x ys rlt (y:rge) r
 
 -- rqsort is as qsort but anti-stable, i.e. reverses equal elements
@@ -821,8 +821,8 @@ rqpart cmp x [] rle rgt r =
     qsort cmp rle (x:qsort cmp rgt r)
 rqpart cmp x (y:ys) rle rgt r =
     case cmp y x of
-	GT -> rqpart cmp x ys rle (y:rgt) r
-    	_  -> rqpart cmp x ys (y:rle) rgt r
+  GT -> rqpart cmp x ys rle (y:rgt) r
+      _  -> rqpart cmp x ys (y:rle) rgt r
 -}
 
 #endif /* USE_REPORT_PRELUDE */
@@ -905,9 +905,9 @@ product	l	= prod l 1
 lines			:: String -> [String]
 lines ""		=  []
 lines s			=  let (l, s') = break (== '\n') s
-			   in  l : case s' of
-					[]     	-> []
-					(_:s'') -> lines s''
+         in  l : case s' of
+          []     	-> []
+          (_:s'') -> lines s''
 
 -- | 'unlines' is an inverse operation to 'lines'.
 -- It joins lines, after appending a terminating newline to each.
@@ -925,9 +925,9 @@ unlines (l:ls) = l ++ '\n' : unlines ls
 -- by white space.
 words			:: String -> [String]
 words s			=  case dropWhile {-partain:Char.-}isSpace s of
-				"" -> []
-				s' -> w : words s''
-				      where (w, s'') = 
+        "" -> []
+        s' -> w : words s''
+              where (w, s'') = 
                                              break {-partain:Char.-}isSpace s'
 
 -- | 'unwords' is an inverse operation to 'words'.
diff --git a/packages/base/Data/Ratio.hs b/packages/base/Data/Ratio.hs
index 22f3abe..f13ed65 100644
--- a/packages/base/Data/Ratio.hs
+++ b/packages/base/Data/Ratio.hs
@@ -70,25 +70,25 @@ import Ratio (Ratio(..), (%), numerator, denominator, approxRational)
 
 approxRational		:: (RealFrac a) => a -> a -> Rational
 approxRational rat eps	=  simplest (rat-eps) (rat+eps)
-	where simplest x y | y < x	=  simplest y x
-			   | x == y	=  xr
-			   | x > 0	=  simplest' n d n' d'
-			   | y < 0	=  - simplest' (-n') d' (-n) d
-			   | otherwise	=  0 :% 1
-					where xr  = toRational x
-					      n   = numerator xr
-					      d   = denominator xr
-					      nd' = toRational y
-					      n'  = numerator nd'
-					      d'  = denominator nd'
+  where simplest x y | y < x	=  simplest y x
+                     | x == y	=  xr
+                     | x > 0	=  simplest' n d n' d'
+                     | y < 0	=  - simplest' (-n') d' (-n) d
+                     | otherwise	=  0 :% 1
+          where xr  = toRational x
+                n   = numerator xr
+                d   = denominator xr
+                nd' = toRational y
+                n'  = numerator nd'
+                d'  = denominator nd'
 
-	      simplest' n d n' d'	-- assumes 0 < n%d < n'%d'
-			| r == 0     =	q :% 1
-			| q /= q'    =	(q+1) :% 1
-			| otherwise  =	(q*n''+d'') :% n''
-				     where (q,r)      =	 quotRem n d
-					   (q',r')    =	 quotRem n' d'
-					   nd''       =  simplest' d' r' d r
-					   n''        =  numerator nd''
-					   d''        =	 denominator nd''
+        simplest' n d n' d'	-- assumes 0 < n%d < n'%d'
+         | r == 0     =	q :% 1
+         | q /= q'    =	(q+1) :% 1
+         | otherwise  =	(q*n''+d'') :% n''
+             where (q,r)      =	 quotRem n d
+                   (q',r')    =	 quotRem n' d'
+                   nd''       =  simplest' d' r' d r
+                   n''        =  numerator nd''
+                   d''        =	 denominator nd''
 #endif
diff --git a/packages/base/Data/Typeable.hs b/packages/base/Data/Typeable.hs
index e9b0673..14bd73f 100644
--- a/packages/base/Data/Typeable.hs
+++ b/packages/base/Data/Typeable.hs
@@ -30,52 +30,52 @@
 module Data.Typeable
   (
 
-	-- * The Typeable class
-	Typeable( typeOf ),	-- :: a -> TypeRep
-
-	-- * Type-safe cast
-	cast,			-- :: (Typeable a, Typeable b) => a -> Maybe b
-	gcast,			-- a generalisation of cast
-
-	-- * Type representations
-	TypeRep,	-- abstract, instance of: Eq, Show, Typeable
-	TyCon,		-- abstract, instance of: Eq, Show, Typeable
-
-	-- * Construction of type representations
-	mkTyCon,	-- :: String  -> TyCon
-	mkTyConApp,	-- :: TyCon   -> [TypeRep] -> TypeRep
-	mkAppTy,	-- :: TypeRep -> TypeRep   -> TypeRep
-	mkFunTy,	-- :: TypeRep -> TypeRep   -> TypeRep
-
-	-- * Observation of type representations
-	splitTyConApp,	-- :: TypeRep -> (TyCon, [TypeRep])
-	funResultTy,	-- :: TypeRep -> TypeRep   -> Maybe TypeRep
-	typeRepTyCon,	-- :: TypeRep -> TyCon
-	typeRepArgs,	-- :: TypeRep -> [TypeRep]
-	tyConString,	-- :: TyCon   -> String
-
-	-- * The other Typeable classes
-	-- | /Note:/ The general instances are provided for GHC only.
-	Typeable1( typeOf1 ),	-- :: t a -> TypeRep
-	Typeable2( typeOf2 ),	-- :: t a b -> TypeRep
-	Typeable3( typeOf3 ),	-- :: t a b c -> TypeRep
-	Typeable4( typeOf4 ),	-- :: t a b c d -> TypeRep
-	Typeable5( typeOf5 ),	-- :: t a b c d e -> TypeRep
-	Typeable6( typeOf6 ),	-- :: t a b c d e f -> TypeRep
-	Typeable7( typeOf7 ),	-- :: t a b c d e f g -> TypeRep
-	gcast1,			-- :: ... => c (t a) -> Maybe (c (t' a))
-	gcast2,			-- :: ... => c (t a b) -> Maybe (c (t' a b))
-
-	-- * Default instances
-	-- | /Note:/ These are not needed by GHC, for which these instances
-	-- are generated by general instance declarations.
-	typeOfDefault,	-- :: (Typeable1 t, Typeable a) => t a -> TypeRep
-	typeOf1Default,	-- :: (Typeable2 t, Typeable a) => t a b -> TypeRep
-	typeOf2Default,	-- :: (Typeable3 t, Typeable a) => t a b c -> TypeRep
-	typeOf3Default,	-- :: (Typeable4 t, Typeable a) => t a b c d -> TypeRep
-	typeOf4Default,	-- :: (Typeable5 t, Typeable a) => t a b c d e -> TypeRep
-	typeOf5Default,	-- :: (Typeable6 t, Typeable a) => t a b c d e f -> TypeRep
-	typeOf6Default	-- :: (Typeable7 t, Typeable a) => t a b c d e f g -> TypeRep
+  -- * The Typeable class
+  Typeable( typeOf ),	-- :: a -> TypeRep
+
+  -- * Type-safe cast
+  cast,			-- :: (Typeable a, Typeable b) => a -> Maybe b
+  gcast,			-- a generalisation of cast
+
+  -- * Type representations
+  TypeRep,	-- abstract, instance of: Eq, Show, Typeable
+  TyCon,		-- abstract, instance of: Eq, Show, Typeable
+
+  -- * Construction of type representations
+  mkTyCon,	-- :: String  -> TyCon
+  mkTyConApp,	-- :: TyCon   -> [TypeRep] -> TypeRep
+  mkAppTy,	-- :: TypeRep -> TypeRep   -> TypeRep
+  mkFunTy,	-- :: TypeRep -> TypeRep   -> TypeRep
+
+  -- * Observation of type representations
+  splitTyConApp,	-- :: TypeRep -> (TyCon, [TypeRep])
+  funResultTy,	-- :: TypeRep -> TypeRep   -> Maybe TypeRep
+  typeRepTyCon,	-- :: TypeRep -> TyCon
+  typeRepArgs,	-- :: TypeRep -> [TypeRep]
+  tyConString,	-- :: TyCon   -> String
+
+  -- * The other Typeable classes
+  -- | /Note:/ The general instances are provided for GHC only.
+  Typeable1( typeOf1 ),	-- :: t a -> TypeRep
+  Typeable2( typeOf2 ),	-- :: t a b -> TypeRep
+  Typeable3( typeOf3 ),	-- :: t a b c -> TypeRep
+  Typeable4( typeOf4 ),	-- :: t a b c d -> TypeRep
+  Typeable5( typeOf5 ),	-- :: t a b c d e -> TypeRep
+  Typeable6( typeOf6 ),	-- :: t a b c d e f -> TypeRep
+  Typeable7( typeOf7 ),	-- :: t a b c d e f g -> TypeRep
+  gcast1,			-- :: ... => c (t a) -> Maybe (c (t' a))
+  gcast2,			-- :: ... => c (t a b) -> Maybe (c (t' a b))
+
+  -- * Default instances
+  -- | /Note:/ These are not needed by GHC, for which these instances
+  -- are generated by general instance declarations.
+  typeOfDefault,	-- :: (Typeable1 t, Typeable a) => t a -> TypeRep
+  typeOf1Default,	-- :: (Typeable2 t, Typeable a) => t a b -> TypeRep
+  typeOf2Default,	-- :: (Typeable3 t, Typeable a) => t a b c -> TypeRep
+  typeOf3Default,	-- :: (Typeable4 t, Typeable a) => t a b c d -> TypeRep
+  typeOf4Default,	-- :: (Typeable5 t, Typeable a) => t a b c d e -> TypeRep
+  typeOf5Default,	-- :: (Typeable6 t, Typeable a) => t a b c d e f -> TypeRep
+  typeOf6Default	-- :: (Typeable7 t, Typeable a) => t a b c d e f g -> TypeRep
 
   ) where
 
@@ -99,14 +99,14 @@ import GHC.IOBase	(IORef,newIORef,unsafePerformIO)
 -- It'd be better to give Typeable instances in the modules themselves
 -- but they all have to be compiled before Typeable
 import GHC.IOBase	( IO, MVar, Exception, ArithException, IOException, 
-			  ArrayException, AsyncException, Handle )
+        ArrayException, AsyncException, Handle )
 import GHC.ST		( ST )
 import GHC.STRef	( STRef )
 import GHC.Ptr          ( Ptr, FunPtr )
 import GHC.ForeignPtr   ( ForeignPtr )
 import GHC.Stable	( StablePtr, newStablePtr, freeStablePtr,
-			  deRefStablePtr, castStablePtrToPtr,
-			  castPtrToStablePtr )
+        deRefStablePtr, castStablePtrToPtr,
+        castPtrToStablePtr )
 import GHC.Exception	( block )
 import GHC.Arr		( Array, STArray )
 
@@ -114,12 +114,12 @@ import GHC.Arr		( Array, STArray )
 
 #ifdef __HUGS__
 import Hugs.Prelude	( Key(..), TypeRep(..), TyCon(..), Ratio,
-			  Exception, ArithException, IOException,
-			  ArrayException, AsyncException, Handle,
-			  Ptr, FunPtr, ForeignPtr, StablePtr )
+        Exception, ArithException, IOException,
+        ArrayException, AsyncException, Handle,
+        Ptr, FunPtr, ForeignPtr, StablePtr )
 import Hugs.IORef	( IORef, newIORef, readIORef, writeIORef )
 import Hugs.IOExts	( unsafePerformIO, unsafeCoerce )
-	-- For the Typeable instance
+  -- For the Typeable instance
 import Hugs.Array	( Array )
 import Hugs.ConcBase	( MVar )
 #endif
@@ -134,7 +134,7 @@ import NonStdUnsafeCoerce (unsafeCoerce)
 import NHC.IOExtras (IORef,newIORef,readIORef,writeIORef,unsafePerformIO)
 import IO (Handle)
 import Ratio (Ratio)
-	-- For the Typeable instance
+  -- For the Typeable instance
 import NHC.FFI	( Ptr,FunPtr,StablePtr,ForeignPtr )
 import Array	( Array )
 #endif
@@ -166,16 +166,16 @@ instance Eq TyCon where
 
 #endif
 
-	-- 
-	-- let fTy = mkTyCon "Foo" in show (mkTyConApp (mkTyCon ",,")
-	--                                 [fTy,fTy,fTy])
-	-- 
-	-- returns "(Foo,Foo,Foo)"
-	--
-	-- The TypeRep Show instance promises to print tuple types
-	-- correctly. Tuple type constructors are specified by a 
-	-- sequence of commas, e.g., (mkTyCon ",,,,") returns
-	-- the 5-tuple tycon.
+  -- 
+  -- let fTy = mkTyCon "Foo" in show (mkTyConApp (mkTyCon ",,")
+  --                                 [fTy,fTy,fTy])
+  -- 
+  -- returns "(Foo,Foo,Foo)"
+  --
+  -- The TypeRep Show instance promises to print tuple types
+  -- correctly. Tuple type constructors are specified by a 
+  -- sequence of commas, e.g., (mkTyCon ",,,,") returns
+  -- the 5-tuple tycon.
 
 ----------------- Construction --------------------
 
@@ -230,9 +230,9 @@ mkAppTy (TypeRep tr_k tc trs) arg_tr
 --
 
 mkTyCon :: String	-- ^ the name of the type constructor (should be unique
-			-- in the program, so it might be wise to use the
-			-- fully qualified name).
-	-> TyCon	-- ^ A unique 'TyCon' object
+      -- in the program, so it might be wise to use the
+      -- fully qualified name).
+  -> TyCon	-- ^ A unique 'TyCon' object
 mkTyCon str = TyCon (mkTyConKey str) str
 
 ----------------- Observation ---------------------
@@ -257,15 +257,15 @@ instance Show TypeRep where
       [] -> showsPrec p tycon
       [x]   | tycon == listTc -> showChar '[' . shows x . showChar ']'
       [a,r] | tycon == funTc  -> showParen (p > 8) $
-			         showsPrec 9 a .
+               showsPrec 9 a .
                                  showString " -> " .
                                  showsPrec 8 r
       xs | isTupleTyCon tycon -> showTuple tycon xs
-	 | otherwise	     ->
-	    showParen (p > 9) $
-   	    showsPrec p tycon . 
-	    showChar ' '      . 
-	    showArgs tys
+         | otherwise	     ->
+            showParen (p > 9) $
+               showsPrec p tycon . 
+            showChar ' '      . 
+            showArgs tys
 
 instance Show TyCon where
   showsPrec _ (TyCon _ s) = showString s
@@ -435,9 +435,9 @@ instance (Typeable7 s, Typeable a)
 cast :: (Typeable a, Typeable b) => a -> Maybe b
 cast x = r
        where
-	 r = if typeOf x == typeOf (fromJust r)
-               then Just $ unsafeCoerce x
-	       else Nothing
+        r = if typeOf x == typeOf (fromJust r)
+                    then Just $ unsafeCoerce x
+              else Nothing
 
 -- | A flexible variation parameterised in a type constructor
 gcast :: (Typeable a, Typeable b) => c a -> Maybe (c b)
@@ -592,8 +592,8 @@ hashKP :: KeyPr -> Int32
 hashKP (KeyPr (Key k1) (Key k2)) = (HT.hashInt k1 + HT.hashInt k2) `rem` HT.prime
 
 data Cache = Cache { next_key :: !(IORef Key),	-- Not used by GHC (calls genSym instead)
-		     tc_tbl   :: !(HT.HashTable String Key),
-		     ap_tbl   :: !(HT.HashTable KeyPr Key) }
+         tc_tbl   :: !(HT.HashTable String Key),
+         ap_tbl   :: !(HT.HashTable KeyPr Key) }
 
 {-# NOINLINE cache #-}
 #ifdef __GLASGOW_HASKELL__
@@ -603,25 +603,25 @@ foreign import ccall unsafe "RtsTypeable.h getOrSetTypeableStore"
 
 cache :: Cache
 cache = unsafePerformIO $ do
-		empty_tc_tbl <- HT.new (==) HT.hashString
-		empty_ap_tbl <- HT.new (==) hashKP
-		key_loc      <- newIORef (Key 1) 
-		let ret = Cache {	next_key = key_loc,
-					tc_tbl = empty_tc_tbl, 
-					ap_tbl = empty_ap_tbl }
+    empty_tc_tbl <- HT.new (==) HT.hashString
+    empty_ap_tbl <- HT.new (==) hashKP
+    key_loc      <- newIORef (Key 1) 
+    let ret = Cache {	next_key = key_loc,
+          tc_tbl = empty_tc_tbl, 
+          ap_tbl = empty_ap_tbl }
 #ifdef __GLASGOW_HASKELL__
-		block $ do
-			stable_ref <- newStablePtr ret
-			let ref = castStablePtrToPtr stable_ref
-			ref2 <- getOrSetTypeableStore ref
-			if ref==ref2
-				then deRefStablePtr stable_ref
-				else do
-					freeStablePtr stable_ref
-					deRefStablePtr
-						(castPtrToStablePtr ref2)
+    block $ do
+      stable_ref <- newStablePtr ret
+      let ref = castStablePtrToPtr stable_ref
+      ref2 <- getOrSetTypeableStore ref
+      if ref==ref2
+        then deRefStablePtr stable_ref
+        else do
+          freeStablePtr stable_ref
+          deRefStablePtr
+            (castPtrToStablePtr ref2)
 #else
-		return ret
+    return ret
 #endif
 
 newKey :: IORef Key -> IO Key
@@ -629,8 +629,8 @@ newKey :: IORef Key -> IO Key
 newKey kloc = do i <- genSym; return (Key i)
 #else
 newKey kloc = do { k@(Key i) <- readIORef kloc ;
-		   writeIORef kloc (Key (i+1)) ;
-		   return k }
+       writeIORef kloc (Key (i+1)) ;
+       return k }
 #endif
 
 #ifdef __GLASGOW_HASKELL__
@@ -641,24 +641,24 @@ foreign import ccall unsafe "genSymZh"
 mkTyConKey :: String -> Key
 mkTyConKey str 
   = unsafePerformIO $ do
-	let Cache {next_key = kloc, tc_tbl = tbl} = cache
-	mb_k <- HT.lookup tbl str
-	case mb_k of
-	  Just k  -> return k
-	  Nothing -> do { k <- newKey kloc ;
-			  HT.insert tbl str k ;
-			  return k }
+  let Cache {next_key = kloc, tc_tbl = tbl} = cache
+  mb_k <- HT.lookup tbl str
+  case mb_k of
+    Just k  -> return k
+    Nothing -> do { k <- newKey kloc ;
+        HT.insert tbl str k ;
+        return k }
 
 appKey :: Key -> Key -> Key
 appKey k1 k2
   = unsafePerformIO $ do
-	let Cache {next_key = kloc, ap_tbl = tbl} = cache
-	mb_k <- HT.lookup tbl kpr
-	case mb_k of
-	  Just k  -> return k
-	  Nothing -> do { k <- newKey kloc ;
-			  HT.insert tbl kpr k ;
-			  return k }
+  let Cache {next_key = kloc, ap_tbl = tbl} = cache
+  mb_k <- HT.lookup tbl kpr
+  case mb_k of
+    Just k  -> return k
+    Nothing -> do { k <- newKey kloc ;
+        HT.insert tbl kpr k ;
+        return k }
   where
     kpr = KeyPr k1 k2
 
diff --git a/packages/base/Foreign/C/Error.hs b/packages/base/Foreign/C/Error.hs
index ac26141..7e2baac 100644
--- a/packages/base/Foreign/C/Error.hs
+++ b/packages/base/Foreign/C/Error.hs
@@ -67,15 +67,15 @@ module Foreign.C.Error (
   throwErrnoIfRetry,    -- :: (a -> Bool) -> String -> IO a       -> IO a
   throwErrnoIfRetry_,   -- :: (a -> Bool) -> String -> IO a       -> IO ()
   throwErrnoIfMinus1,   -- :: Num a 
-			-- =>                String -> IO a       -> IO a
+      -- =>                String -> IO a       -> IO a
   throwErrnoIfMinus1_,  -- :: Num a 
-			-- =>                String -> IO a       -> IO ()
+      -- =>                String -> IO a       -> IO ()
   throwErrnoIfMinus1Retry,  
-			-- :: Num a 
-			-- =>                String -> IO a       -> IO a
+      -- :: Num a 
+      -- =>                String -> IO a       -> IO a
   throwErrnoIfMinus1Retry_,  
-			-- :: Num a 
-			-- =>                String -> IO a       -> IO ()
+      -- :: Num a 
+      -- =>                String -> IO a       -> IO ()
   throwErrnoIfNull,	-- ::                String -> IO (Ptr a) -> IO (Ptr a)
   throwErrnoIfNullRetry,-- ::                String -> IO (Ptr a) -> IO (Ptr a)
 
@@ -314,7 +314,7 @@ foreign import ccall unsafe "HsBase.h __hscore_set_errno" set_errno :: CInt -> I
 -- | Throw an 'IOError' corresponding to the current value of 'getErrno'.
 --
 throwErrno     :: String	-- ^ textual description of the error location
-	       -> IO a
+         -> IO a
 throwErrno loc  =
   do
     errno <- getErrno
@@ -328,10 +328,10 @@ throwErrno loc  =
 -- if the result value of the 'IO' action meets the given predicate.
 --
 throwErrnoIf    :: (a -> Bool)	-- ^ predicate to apply to the result value
-				-- of the 'IO' operation
-		-> String	-- ^ textual description of the location
-		-> IO a		-- ^ the 'IO' operation to be executed
-		-> IO a
+        -- of the 'IO' operation
+    -> String	-- ^ textual description of the location
+    -> IO a		-- ^ the 'IO' operation to be executed
+    -> IO a
 throwErrnoIf pred loc f  = 
   do
     res <- f
@@ -353,35 +353,35 @@ throwErrnoIfRetry pred loc f  =
     res <- f
     if pred res
       then do
-	err <- getErrno
-	if err == eINTR
-	  then throwErrnoIfRetry pred loc f
-	  else throwErrno loc
-      else return res
+       err <- getErrno
+       if err == eINTR
+         then throwErrnoIfRetry pred loc f
+         else throwErrno loc
+           else return res
 
 -- | as 'throwErrnoIfRetry', but checks for operations that would block and
 -- executes an alternative action before retrying in that case.
 --
 throwErrnoIfRetryMayBlock
-		:: (a -> Bool)	-- ^ predicate to apply to the result value
-				-- of the 'IO' operation
-		-> String	-- ^ textual description of the location
-		-> IO a		-- ^ the 'IO' operation to be executed
-		-> IO b		-- ^ action to execute before retrying if
-				-- an immediate retry would block
-		-> IO a
+    :: (a -> Bool)	-- ^ predicate to apply to the result value
+        -- of the 'IO' operation
+    -> String	-- ^ textual description of the location
+    -> IO a		-- ^ the 'IO' operation to be executed
+    -> IO b		-- ^ action to execute before retrying if
+        -- an immediate retry would block
+    -> IO a
 throwErrnoIfRetryMayBlock pred loc f on_block  = 
   do
     res <- f
     if pred res
       then do
-	err <- getErrno
-	if err == eINTR
-	  then throwErrnoIfRetryMayBlock pred loc f on_block
-          else if err == eWOULDBLOCK || err == eAGAIN
-	         then do on_block; throwErrnoIfRetryMayBlock pred loc f on_block
-                 else throwErrno loc
-      else return res
+       err <- getErrno
+       if err == eINTR
+         then throwErrnoIfRetryMayBlock pred loc f on_block
+               else if err == eWOULDBLOCK || err == eAGAIN
+                then do { on_block; throwErrnoIfRetryMayBlock pred loc f on_block }
+                      else throwErrno loc
+           else return res
 
 -- | as 'throwErrnoIfRetry', but discards the result.
 --
@@ -453,10 +453,10 @@ throwErrnoIfNullRetryMayBlock  = throwErrnoIfRetryMayBlock (== nullPtr)
 -- error messages.
 --
 errnoToIOError	:: String	-- ^ the location where the error occurred
-		-> Errno	-- ^ the error number
-		-> Maybe Handle	-- ^ optional handle associated with the error
-		-> Maybe String	-- ^ optional filename associated with the error
-		-> IOError
+    -> Errno	-- ^ the error number
+    -> Maybe Handle	-- ^ optional handle associated with the error
+    -> Maybe String	-- ^ optional filename associated with the error
+    -> IOError
 errnoToIOError loc errno maybeHdl maybeName = unsafePerformIO $ do
     str <- strerror errno >>= peekCString
 #if __GLASGOW_HASKELL__
diff --git a/packages/base/Foreign/C/Types.hs b/packages/base/Foreign/C/Types.hs
index 7e8c5a3..d7bd9e8 100644
--- a/packages/base/Foreign/C/Types.hs
+++ b/packages/base/Foreign/C/Types.hs
@@ -141,8 +141,7 @@ INTEGRAL_TYPE(CULLong,tyConCULLong,"CULLong",HTYPE_UNSIGNED_LONG_LONG)
 "fromIntegral/CLong->a"   fromIntegral = \(CLong   x) -> fromIntegral x
 "fromIntegral/CULong->a"  fromIntegral = \(CULong  x) -> fromIntegral x
 "fromIntegral/CLLong->a"  fromIntegral = \(CLLong  x) -> fromIntegral x
-"fromIntegral/CULLong->a" fromIntegral = \(CULLong x) -> fromIntegral x
- #-}
+"fromIntegral/CULLong->a" fromIntegral = \(CULLong x) -> fromIntegral x #-}
 
 -- | Haskell type representing the C @float@ type.
 FLOATING_TYPE(CFloat,tyConCFloat,"CFloat",HTYPE_FLOAT)
@@ -159,8 +158,7 @@ FLOATING_TYPE(CLDouble,tyConCLDouble,"CLDouble",HTYPE_DOUBLE)
 
 "realToFrac/CFloat->a"    realToFrac = \(CFloat   x) -> realToFrac x
 "realToFrac/CDouble->a"   realToFrac = \(CDouble  x) -> realToFrac x
-"realToFrac/CLDouble->a"  realToFrac = \(CLDouble x) -> realToFrac x
- #-}
+"realToFrac/CLDouble->a"  realToFrac = \(CLDouble x) -> realToFrac x #-}
 
 -- | Haskell type representing the C @ptrdiff_t@ type.
 INTEGRAL_TYPE(CPtrdiff,tyConCPtrdiff,"CPtrdiff",HTYPE_PTRDIFF_T)
@@ -180,8 +178,7 @@ INTEGRAL_TYPE(CSigAtomic,tyConCSigAtomic,"CSigAtomic",HTYPE_SIG_ATOMIC_T)
 "fromIntegral/CPtrdiff->a"   fromIntegral = \(CPtrdiff   x) -> fromIntegral x
 "fromIntegral/CSize->a"      fromIntegral = \(CSize      x) -> fromIntegral x
 "fromIntegral/CWchar->a"     fromIntegral = \(CWchar     x) -> fromIntegral x
-"fromIntegral/CSigAtomic->a" fromIntegral = \(CSigAtomic x) -> fromIntegral x
- #-}
+"fromIntegral/CSigAtomic->a" fromIntegral = \(CSigAtomic x) -> fromIntegral x #-}
 
 -- | Haskell type representing the C @clock_t@ type.
 ARITHMETIC_TYPE(CClock,tyConCClock,"CClock",HTYPE_CLOCK_T)
@@ -205,8 +202,7 @@ INTEGRAL_TYPE(CUIntMax,tyConCUIntMax,"CUIntMax",HTYPE_UINTMAX_T)
 "fromIntegral/a->CIntPtr"  fromIntegral = \x -> CIntPtr  (fromIntegral x)
 "fromIntegral/a->CUIntPtr" fromIntegral = \x -> CUIntPtr (fromIntegral x)
 "fromIntegral/a->CIntMax"  fromIntegral = \x -> CIntMax  (fromIntegral x)
-"fromIntegral/a->CUIntMax" fromIntegral = \x -> CUIntMax (fromIntegral x)
- #-}
+"fromIntegral/a->CUIntMax" fromIntegral = \x -> CUIntMax (fromIntegral x) #-}
 
 -- C99 types which are still missing include:
 -- wint_t, wctrans_t, wctype_t
diff --git a/packages/base/GHC/Base.lhs b/packages/base/GHC/Base.lhs
index cf3c5a3..1902ca8 100644
--- a/packages/base/GHC/Base.lhs
+++ b/packages/base/GHC/Base.lhs
@@ -382,8 +382,7 @@ augment g xs = g (:) xs
 		       (h::forall b. (a->b->b) -> b -> b) .
 		       augment g (build h) = build (\c n -> g c (h c n))
 "augment/nil"   forall (g::forall b. (a->b->b) -> b -> b) .
-			augment g [] = build g
- #-}
+			augment g [] = build g #-}
 
 -- This rule is true, but not (I think) useful:
 --	augment g (augment h t) = augment (\cn -> g c (h c n)) t
@@ -431,8 +430,7 @@ mapFB c f x ys = c (f x) ys
 {-# RULES
 "map"	    [~1] forall f xs.	map f xs		= build (\c n -> foldr (mapFB c f) n xs)
 "mapList"   [1]  forall f.	foldr (mapFB (:) f) []	= map f
-"mapFB"	    forall c f g.	mapFB (mapFB c f) g	= mapFB c (f.g) 
-  #-}
+"mapFB"	    forall c f g.	mapFB (mapFB c f) g	= mapFB c (f.g)   #-}
 \end{code}
 
 
@@ -452,8 +450,7 @@ mapFB c f x ys = c (f x) ys
 (++) (x:xs) ys = x : xs ++ ys
 
 {-# RULES
-"++"	[~1] forall xs ys. xs ++ ys = augment (\c n -> foldr c n xs) ys
-  #-}
+"++"	[~1] forall xs ys. xs ++ ys = augment (\c n -> foldr c n xs) ys  #-}
 
 \end{code}
 
@@ -593,8 +590,7 @@ instance Ord Char where
 "x# `gtChar#` x#" forall x#. x# `gtChar#` x# = False
 "x# `geChar#` x#" forall x#. x# `geChar#` x# = True
 "x# `leChar#` x#" forall x#. x# `leChar#` x# = True
-"x# `ltChar#` x#" forall x#. x# `ltChar#` x# = False
-  #-}
+"x# `ltChar#` x#" forall x#. x# `ltChar#` x# = False  #-}
 
 -- | The 'Prelude.toEnum' method restricted to the type 'Data.Char.Char'.
 chr :: Int -> Char
@@ -870,8 +866,7 @@ plusInt, minusInt, timesInt, quotInt, remInt, divInt, modInt, gcdInt :: Int -> I
 "x# *# 0#" forall x#. x# *# 0# = 0#
 "0# *# x#" forall x#. 0# *# x# = 0#
 "x# *# 1#" forall x#. x# *# 1# = x#
-"1# *# x#" forall x#. 1# *# x# = x#
-  #-}
+"1# *# x#" forall x#. 1# *# x# = x#  #-}
 
 gcdInt (I# a) (I# b) = g a b
    where g 0# 0# = error "GHC.Base.gcdInt: gcd 0 0 is undefined"
@@ -901,8 +896,7 @@ gtInt, geInt, eqInt, neInt, ltInt, leInt :: Int -> Int -> Bool
 "x# ==# x#" forall x#. x# ==# x# = True
 "x# /=# x#" forall x#. x# /=# x# = False
 "x# <# x#"  forall x#. x# <#  x# = False
-"x# <=# x#" forall x#. x# <=# x# = True
-  #-}
+"x# <=# x#" forall x#. x# <=# x# = True  #-}
 
 {-# RULES
 "plusFloat x 0.0"   forall x#. plusFloat#  x#   0.0# = x#
@@ -913,8 +907,7 @@ gtInt, geInt, eqInt, neInt, ltInt, leInt :: Int -> Int -> Bool
 "timesFloat0.0 x"   forall x#. timesFloat# 0.0# x#   = 0.0#
 "timesFloat x 1.0"  forall x#. timesFloat# x#   1.0# = x#
 "timesFloat 1.0 x"  forall x#. timesFloat# 1.0# x#   = x#
-"divideFloat x 1.0" forall x#. divideFloat# x#  1.0# = x#
-  #-}
+"divideFloat x 1.0" forall x#. divideFloat# x#  1.0# = x#  #-}
 
 {-# RULES
 "plusDouble x 0.0"   forall x#. (+##) x#    0.0## = x#
@@ -925,8 +918,7 @@ gtInt, geInt, eqInt, neInt, ltInt, leInt :: Int -> Int -> Bool
 "timesDouble 0.0 x"  forall x#. (*##) 0.0## x#    = 0.0##
 "timesDouble x 1.0"  forall x#. (*##) x#    1.0## = x#
 "timesDouble 1.0 x"  forall x#. (*##) 1.0## x#    = x#
-"divideDouble x 1.0" forall x#. (/##) x#    1.0## = x#
-  #-}
+"divideDouble x 1.0" forall x#. (/##) x#    1.0## = x#  #-}
 
 -- Wrappers for the shift operations.  The uncheckedShift# family are
 -- undefined when the amount being shifted by is greater than the size
@@ -969,14 +961,12 @@ a `iShiftRL#` b | b >=# WORD_SIZE_IN_BITS# = 0#
 #if WORD_SIZE_IN_BITS == 32
 {-# RULES
 "narrow32Int#"  forall x#. narrow32Int#   x# = x#
-"narrow32Word#" forall x#. narrow32Word#   x# = x#
-   #-}
+"narrow32Word#" forall x#. narrow32Word#   x# = x#   #-}
 #endif
 
 {-# RULES
 "int2Word2Int"  forall x#. int2Word# (word2Int# x#) = x#
-"word2Int2Word" forall x#. word2Int# (int2Word# x#) = x#
-  #-}
+"word2Int2Word" forall x#. word2Int# (int2Word# x#) = x#  #-}
 \end{code}
 
 
@@ -1063,14 +1053,12 @@ unpackNBytes#  addr len# = unpack [] (len# -# 1#)
 	    ch -> unpack (C# ch : acc) (i# -# 1#)
 
 {-# RULES
-"unpack"       [~1] forall a   . unpackCString# a		   = build (unpackFoldrCString# a)
-"unpack-list"  [1]  forall a   . unpackFoldrCString# a (:) [] = unpackCString# a
-"unpack-append"     forall a n . unpackFoldrCString# a (:) n  = unpackAppendCString# a n
-
 -- There's a built-in rule (in PrelRules.lhs) for
 -- 	unpackFoldr "foo" c (unpackFoldr "baz" c n)  =  unpackFoldr "foobaz" c n
 
-  #-}
+"unpack"       [~1] forall a   . unpackCString# a		   = build (unpackFoldrCString# a)
+"unpack-list"  [1]  forall a   . unpackFoldrCString# a (:) [] = unpackCString# a
+"unpack-append"     forall a n . unpackFoldrCString# a (:) n  = unpackAppendCString# a n  #-}
 \end{code}
 
 #ifdef __HADDOCK__
diff --git a/packages/base/GHC/Enum.lhs b/packages/base/GHC/Enum.lhs
index 69c49e0..d363982 100644
--- a/packages/base/GHC/Enum.lhs
+++ b/packages/base/GHC/Enum.lhs
@@ -342,8 +342,7 @@ instance  Enum Char  where
 "efdtChar"	[~1] forall x1 x2 l.	efdtChar x1 x2 l  = build (\ c n -> efdtCharFB c n x1 x2 l)
 "eftCharList"	[1]  eftCharFB  (:) [] = eftChar
 "efdCharList"	[1]  efdCharFB  (:) [] = efdChar
-"efdtCharList"	[1]  efdtCharFB (:) [] = efdtChar
- #-}
+"efdtCharList"	[1]  efdtCharFB (:) [] = efdtChar #-}
 
 
 -- We can do better than for Ints because we don't
@@ -462,8 +461,7 @@ instance  Enum Int  where
 
 {-# RULES
 "eftInt"	[~1] forall x y. eftInt x y = build (\ c n -> eftIntFB c n x y)
-"eftIntList"	[1] eftIntFB  (:) [] = eftInt
- #-}
+"eftIntList"	[1] eftIntFB  (:) [] = eftInt #-}
 
 eftInt :: Int# -> Int# -> [Int]
 -- [x1..x2]
diff --git a/packages/base/GHC/Float.lhs b/packages/base/GHC/Float.lhs
index cac8c0a..4160fe3 100644
--- a/packages/base/GHC/Float.lhs
+++ b/packages/base/GHC/Float.lhs
@@ -955,6 +955,5 @@ foreign import ccall unsafe "isDoubleNegativeZero" isDoubleNegativeZero :: Doubl
 "realToFrac/Float->Float"   realToFrac   = id :: Float -> Float
 "realToFrac/Float->Double"  realToFrac   = float2Double
 "realToFrac/Double->Float"  realToFrac   = double2Float
-"realToFrac/Double->Double" realToFrac   = id :: Double -> Double
-    #-}
+"realToFrac/Double->Double" realToFrac   = id :: Double -> Double    #-}
 \end{code}
diff --git a/packages/base/GHC/Int.hs b/packages/base/GHC/Int.hs
index 6fb44ca..a98be51 100644
--- a/packages/base/GHC/Int.hs
+++ b/packages/base/GHC/Int.hs
@@ -134,8 +134,7 @@ instance Bits Int8 where
 {-# RULES
 "fromIntegral/Int8->Int8" fromIntegral = id :: Int8 -> Int8
 "fromIntegral/a->Int8"    fromIntegral = \x -> case fromIntegral x of I# x# -> I8# (narrow8Int# x#)
-"fromIntegral/Int8->a"    fromIntegral = \(I8# x#) -> fromIntegral (I# x#)
-  #-}
+"fromIntegral/Int8->a"    fromIntegral = \(I8# x#) -> fromIntegral (I# x#)  #-}
 
 ------------------------------------------------------------------------
 -- type Int16
@@ -241,8 +240,7 @@ instance Bits Int16 where
 "fromIntegral/Int8->Int16"   fromIntegral = \(I8# x#) -> I16# x#
 "fromIntegral/Int16->Int16"  fromIntegral = id :: Int16 -> Int16
 "fromIntegral/a->Int16"      fromIntegral = \x -> case fromIntegral x of I# x# -> I16# (narrow16Int# x#)
-"fromIntegral/Int16->a"      fromIntegral = \(I16# x#) -> fromIntegral (I# x#)
-  #-}
+"fromIntegral/Int16->a"      fromIntegral = \(I16# x#) -> fromIntegral (I# x#)  #-}
 
 ------------------------------------------------------------------------
 -- type Int32
@@ -391,8 +389,7 @@ foreign import "stg_shiftRL32"     unsafe shiftRL32#     :: Word32# -> Int# -> W
 "fromIntegral/Int32->Int"    fromIntegral = \(I32# x#) -> I#   (int32ToInt# x#)
 "fromIntegral/Int32->Word"   fromIntegral = \(I32# x#) -> W#   (int2Word# (int32ToInt# x#))
 "fromIntegral/Int32->Word32" fromIntegral = \(I32# x#) -> W32# (int32ToWord32# x#)
-"fromIntegral/Int32->Int32"  fromIntegral = id :: Int32 -> Int32
-  #-}
+"fromIntegral/Int32->Int32"  fromIntegral = id :: Int32 -> Int32  #-}
 
 #else 
 
@@ -493,8 +490,7 @@ instance Bits Int32 where
 "fromIntegral/Int16->Int32"  fromIntegral = \(I16# x#) -> I32# x#
 "fromIntegral/Int32->Int32"  fromIntegral = id :: Int32 -> Int32
 "fromIntegral/a->Int32"      fromIntegral = \x -> case fromIntegral x of I# x# -> I32# (narrow32Int# x#)
-"fromIntegral/Int32->a"      fromIntegral = \(I32# x#) -> fromIntegral (I# x#)
-  #-}
+"fromIntegral/Int32->a"      fromIntegral = \(I32# x#) -> fromIntegral (I# x#)  #-}
 
 #endif 
 
@@ -677,8 +673,7 @@ foreign import ccall unsafe "stg_integerToInt64"  integerToInt64#  :: Int# -> By
 "fromIntegral/Int64->Int"    fromIntegral = \(I64# x#) -> I#   (int64ToInt# x#)
 "fromIntegral/Int64->Word"   fromIntegral = \(I64# x#) -> W#   (int2Word# (int64ToInt# x#))
 "fromIntegral/Int64->Word64" fromIntegral = \(I64# x#) -> W64# (int64ToWord64# x#)
-"fromIntegral/Int64->Int64"  fromIntegral = id :: Int64 -> Int64
-  #-}
+"fromIntegral/Int64->Int64"  fromIntegral = id :: Int64 -> Int64  #-}
 
 #else 
 
@@ -763,8 +758,7 @@ instance Bits Int64 where
 
 {-# RULES
 "fromIntegral/a->Int64" fromIntegral = \x -> case fromIntegral x of I# x# -> I64# x#
-"fromIntegral/Int64->a" fromIntegral = \(I64# x#) -> fromIntegral (I# x#)
-  #-}
+"fromIntegral/Int64->a" fromIntegral = \(I64# x#) -> fromIntegral (I# x#)  #-}
 
 #endif
 
diff --git a/packages/base/GHC/List.lhs b/packages/base/GHC/List.lhs
index 60fc90b..8b4b84b 100644
--- a/packages/base/GHC/List.lhs
+++ b/packages/base/GHC/List.lhs
@@ -66,8 +66,7 @@ badHead = errorEmptyList "head"
 "head/build"	forall (g::forall b.(a->b->b)->b->b) .
 		head (build g) = g (\x _ -> x) badHead
 "head/augment"	forall xs (g::forall b. (a->b->b) -> b -> b) . 
-		head (augment g xs) = g (\x _ -> x) (head xs)
- #-}
+		head (augment g xs) = g (\x _ -> x) (head xs) #-}
 
 -- | Extract the elements after the head of a list, which must be non-empty.
 tail                    :: [a] -> [a]
@@ -136,8 +135,7 @@ filterFB c p x r | p x       = x `c` r
 {-# RULES
 "filter"     [~1] forall p xs.  filter p xs = build (\c n -> foldr (filterFB c p) n xs)
 "filterList" [1]  forall p.	foldr (filterFB (:) p) [] = filter p
-"filterFB"	  forall c p q. filterFB (filterFB c p) q = filterFB c (\x -> q x && p x)
- #-}
+"filterFB"	  forall c p q. filterFB (filterFB c p) q = filterFB c (\x -> q x && p x) #-}
 
 -- Note the filterFB rule, which has p and q the "wrong way round" in the RHS.
 --     filterFB (filterFB c p) q a b
@@ -231,8 +229,7 @@ iterateFB c f x = x `c` iterateFB c f (f x)
 
 {-# RULES
 "iterate"    [~1] forall f x.	iterate f x = build (\c _n -> iterateFB c f x)
-"iterateFB"  [1]		iterateFB (:) = iterate
- #-}
+"iterateFB"  [1]		iterateFB (:) = iterate #-}
 
 
 -- | 'repeat' @x@ is an infinite list, with @x@ the value of every element.
@@ -247,8 +244,7 @@ repeatFB c x = xs where xs = x `c` xs
 
 {-# RULES
 "repeat"    [~1] forall x. repeat x = build (\c _n -> repeatFB c x)
-"repeatFB"  [1]  repeatFB (:)	    = repeat
- #-}
+"repeatFB"  [1]  repeatFB (:)	    = repeat #-}
 
 -- | 'replicate' @n x@ is a list of length @n@ with @x@ the value of
 -- every element.
@@ -314,8 +310,7 @@ splitAt n xs           =  (take n xs, drop n xs)
 #else /* hack away */
 {-# RULES
 "take"	   [~1] forall n xs . take n xs = case n of I# n# -> build (\c nil -> foldr (takeFB c nil) (takeConst nil) xs n#)
-"takeList"  [1] forall n xs . foldr (takeFB (:) []) (takeConst []) xs n = takeUInt n xs
- #-}
+"takeList"  [1] forall n xs . foldr (takeFB (:) []) (takeConst []) xs n = takeUInt n xs #-}
 
 {-# NOINLINE [0] takeConst #-}
 -- just a version of const that doesn't get inlined too early, so we
@@ -436,8 +431,7 @@ or (x:xs)	=  x || or xs
 "and/build"	forall (g::forall b.(Bool->b->b)->b->b) . 
 		and (build g) = g (&&) True
 "or/build"	forall (g::forall b.(Bool->b->b)->b->b) . 
-		or (build g) = g (||) False
- #-}
+		or (build g) = g (||) False #-}
 #endif
 
 -- | Applied to a predicate and a list, 'any' determines if any element
@@ -460,8 +454,7 @@ all p (x:xs)	=  p x && all p xs
 "any/build"	forall p (g::forall b.(a->b->b)->b->b) . 
 		any p (build g) = g ((||) . p) False
 "all/build"	forall p (g::forall b.(a->b->b)->b->b) . 
-		all p (build g) = g ((&&) . p) True
- #-}
+		all p (build g) = g ((&&) . p) True #-}
 #endif
 
 -- | 'elem' is the list membership predicate, usually written in infix form,
@@ -497,9 +490,8 @@ concat :: [[a]] -> [a]
 concat = foldr (++) []
 
 {-# RULES
-  "concat" forall xs. concat xs = build (\c n -> foldr (\x y -> foldr c y x) n xs)
 -- We don't bother to turn non-fusible applications of concat back into concat
- #-}
+  "concat" forall xs. concat xs = build (\c n -> foldr (\x y -> foldr c y x) n xs) #-}
 
 \end{code}
 
@@ -555,8 +547,7 @@ foldr2_right  k _z  y  r (x:xs) = k x y (r xs)
 		  foldr2 k z (build g) ys = g (foldr2_left  k z) (\_ -> z) ys
 
 "foldr2/right"	forall k z xs (g::forall b.(a->b->b)->b->b) . 
-		  foldr2 k z xs (build g) = g (foldr2_right k z) (\_ -> z) xs
- #-}
+		  foldr2 k z xs (build g) = g (foldr2_right k z) (\_ -> z) xs #-}
 \end{code}
 
 The foldr2/right rule isn't exactly right, because it changes
@@ -585,8 +576,7 @@ zipFB c x y r = (x,y) `c` r
 
 {-# RULES
 "zip"	   [~1]	forall xs ys. zip xs ys	= build (\c n -> foldr2 (zipFB c) n xs ys)
-"zipList"  [1]	foldr2 (zipFB (:)) []   = zip
- #-}
+"zipList"  [1]	foldr2 (zipFB (:)) []   = zip #-}
 \end{code}
 
 \begin{code}
@@ -619,8 +609,7 @@ zipWithFB c f x y r = (x `f` y) `c` r
 
 {-# RULES
 "zipWith"	[~1] forall f xs ys.	zipWith f xs ys = build (\c n -> foldr2 (zipWithFB c f) n xs ys)
-"zipWithList"	[1]  forall f. 	foldr2 (zipWithFB (:) f) [] = zipWith f
-  #-}
+"zipWithList"	[1]  forall f. 	foldr2 (zipWithFB (:) f) [] = zipWith f  #-}
 \end{code}
 
 \begin{code}
diff --git a/packages/base/GHC/Num.lhs b/packages/base/GHC/Num.lhs
index 540204d..0efa3e5 100644
--- a/packages/base/GHC/Num.lhs
+++ b/packages/base/GHC/Num.lhs
@@ -409,8 +409,7 @@ instance  Enum Integer  where
 "enumDeltaInteger"	[~1] forall x y.  enumDeltaInteger x y     = build (\c _ -> enumDeltaIntegerFB c x y)
 "efdtInteger"		[~1] forall x y l.enumDeltaToInteger x y l = build (\c n -> enumDeltaToIntegerFB c n x y l)
 "enumDeltaInteger" 	[1] enumDeltaIntegerFB   (:)    = enumDeltaInteger
-"enumDeltaToInteger" 	[1] enumDeltaToIntegerFB (:) [] = enumDeltaToInteger
- #-}
+"enumDeltaToInteger" 	[1] enumDeltaToIntegerFB (:) [] = enumDeltaToInteger #-}
 
 enumDeltaIntegerFB :: (Integer -> b -> b) -> Integer -> Integer -> b
 enumDeltaIntegerFB c x d = x `c` enumDeltaIntegerFB c (x+d) d
diff --git a/packages/base/GHC/Real.lhs b/packages/base/GHC/Real.lhs
index 31e8160..260de92 100644
--- a/packages/base/GHC/Real.lhs
+++ b/packages/base/GHC/Real.lhs
@@ -352,16 +352,14 @@ fromIntegral :: (Integral a, Num b) => a -> b
 fromIntegral = fromInteger . toInteger
 
 {-# RULES
-"fromIntegral/Int->Int" fromIntegral = id :: Int -> Int
-    #-}
+"fromIntegral/Int->Int" fromIntegral = id :: Int -> Int    #-}
 
 -- | general coercion to fractional types
 realToFrac :: (Real a, Fractional b) => a -> b
 realToFrac = fromRational . toRational
 
 {-# RULES
-"realToFrac/Int->Int" realToFrac = id :: Int -> Int
-    #-}
+"realToFrac/Int->Int" realToFrac = id :: Int -> Int    #-}
 \end{code}
 
 %*********************************************************
@@ -428,8 +426,7 @@ lcm x y		=  abs ((x `quot` (gcd x y)) * y)
 {-# RULES
 "gcd/Int->Int->Int"             gcd = gcdInt
 "gcd/Integer->Integer->Integer" gcd = gcdInteger
-"lcm/Integer->Integer->Integer" lcm = lcmInteger
- #-}
+"lcm/Integer->Integer->Integer" lcm = lcmInteger #-}
 
 integralEnumFrom :: (Integral a, Bounded a) => a -> [a]
 integralEnumFrom n = map fromInteger [toInteger n .. toInteger (maxBound `asTypeOf` n)]
diff --git a/packages/base/GHC/Word.hs b/packages/base/GHC/Word.hs
index 7bdbe67..53d49ae 100644
--- a/packages/base/GHC/Word.hs
+++ b/packages/base/GHC/Word.hs
@@ -172,8 +172,7 @@ instance Bits Word where
 {-# RULES
 "fromIntegral/Int->Word"  fromIntegral = \(I# x#) -> W# (int2Word# x#)
 "fromIntegral/Word->Int"  fromIntegral = \(W# x#) -> I# (word2Int# x#)
-"fromIntegral/Word->Word" fromIntegral = id :: Word -> Word
-  #-}
+"fromIntegral/Word->Word" fromIntegral = id :: Word -> Word  #-}
 
 ------------------------------------------------------------------------
 -- type Word8
@@ -271,8 +270,7 @@ instance Bits Word8 where
 "fromIntegral/Word8->Word8"   fromIntegral = id :: Word8 -> Word8
 "fromIntegral/Word8->Integer" fromIntegral = toInteger :: Word8 -> Integer
 "fromIntegral/a->Word8"       fromIntegral = \x -> case fromIntegral x of W# x# -> W8# (narrow8Word# x#)
-"fromIntegral/Word8->a"       fromIntegral = \(W8# x#) -> fromIntegral (W# x#)
-  #-}
+"fromIntegral/Word8->a"       fromIntegral = \(W8# x#) -> fromIntegral (W# x#)  #-}
 
 ------------------------------------------------------------------------
 -- type Word16
@@ -371,8 +369,7 @@ instance Bits Word16 where
 "fromIntegral/Word16->Word16"  fromIntegral = id :: Word16 -> Word16
 "fromIntegral/Word16->Integer" fromIntegral = toInteger :: Word16 -> Integer
 "fromIntegral/a->Word16"       fromIntegral = \x -> case fromIntegral x of W# x# -> W16# (narrow16Word# x#)
-"fromIntegral/Word16->a"       fromIntegral = \(W16# x#) -> fromIntegral (W# x#)
-  #-}
+"fromIntegral/Word16->a"       fromIntegral = \(W16# x#) -> fromIntegral (W# x#)  #-}
 
 ------------------------------------------------------------------------
 -- type Word32
@@ -492,8 +489,7 @@ foreign import unsafe "stg_shiftRL32"     shiftRL32#     :: Word32# -> Int# -> W
 "fromIntegral/Word->Word32"   fromIntegral = \(W#   x#) -> W32# (wordToWord32# x#)
 "fromIntegral/Word32->Int"    fromIntegral = \(W32# x#) -> I#   (word2Int# (word32ToWord# x#))
 "fromIntegral/Word32->Word"   fromIntegral = \(W32# x#) -> W#   (word32ToWord# x#)
-"fromIntegral/Word32->Word32" fromIntegral = id :: Word32 -> Word32
-  #-}
+"fromIntegral/Word32->Word32" fromIntegral = id :: Word32 -> Word32  #-}
 
 #else 
 
@@ -598,8 +594,7 @@ instance Bits Word32 where
 "fromIntegral/Word32->Word32"  fromIntegral = id :: Word32 -> Word32
 "fromIntegral/Word32->Integer" fromIntegral = toInteger :: Word32 -> Integer
 "fromIntegral/a->Word32"       fromIntegral = \x -> case fromIntegral x of W# x# -> W32# (narrow32Word# x#)
-"fromIntegral/Word32->a"       fromIntegral = \(W32# x#) -> fromIntegral (W# x#)
-  #-}
+"fromIntegral/Word32->a"       fromIntegral = \(W32# x#) -> fromIntegral (W# x#)  #-}
 
 #endif
 
@@ -765,8 +760,7 @@ foreign import ccall unsafe "stg_integerToWord64" integerToWord64# :: Int# -> By
 "fromIntegral/Word->Word64"   fromIntegral = \(W#   x#) -> W64# (wordToWord64# x#)
 "fromIntegral/Word64->Int"    fromIntegral = \(W64# x#) -> I#   (word2Int# (word64ToWord# x#))
 "fromIntegral/Word64->Word"   fromIntegral = \(W64# x#) -> W#   (word64ToWord# x#)
-"fromIntegral/Word64->Word64" fromIntegral = id :: Word64 -> Word64
-  #-}
+"fromIntegral/Word64->Word64" fromIntegral = id :: Word64 -> Word64  #-}
 
 #else
 
@@ -851,8 +845,7 @@ instance Bits Word64 where
 
 {-# RULES
 "fromIntegral/a->Word64" fromIntegral = \x -> case fromIntegral x of W# x# -> W64# x#
-"fromIntegral/Word64->a" fromIntegral = \(W64# x#) -> fromIntegral (W# x#)
-  #-}
+"fromIntegral/Word64->a" fromIntegral = \(W64# x#) -> fromIntegral (W# x#)  #-}
 
 #endif
 
diff --git a/packages/base/Numeric.hs b/packages/base/Numeric.hs
index e24803e..6f3d35f 100644
--- a/packages/base/Numeric.hs
+++ b/packages/base/Numeric.hs
@@ -16,45 +16,45 @@
 
 module Numeric (
 
-	-- * Showing
+  -- * Showing
 
-	showSigned,       -- :: (Real a) => (a -> ShowS) -> Int -> a -> ShowS
+  showSigned,       -- :: (Real a) => (a -> ShowS) -> Int -> a -> ShowS
 
         showIntAtBase,    -- :: Integral a => a -> (a -> Char) -> a -> ShowS
-	showInt,          -- :: Integral a => a -> ShowS
+  showInt,          -- :: Integral a => a -> ShowS
         showHex,          -- :: Integral a => a -> ShowS
         showOct,          -- :: Integral a => a -> ShowS
 
-	showEFloat,       -- :: (RealFloat a) => Maybe Int -> a -> ShowS
-	showFFloat,       -- :: (RealFloat a) => Maybe Int -> a -> ShowS
-	showGFloat,       -- :: (RealFloat a) => Maybe Int -> a -> ShowS
-	showFloat,        -- :: (RealFloat a) => a -> ShowS
+  showEFloat,       -- :: (RealFloat a) => Maybe Int -> a -> ShowS
+  showFFloat,       -- :: (RealFloat a) => Maybe Int -> a -> ShowS
+  showGFloat,       -- :: (RealFloat a) => Maybe Int -> a -> ShowS
+  showFloat,        -- :: (RealFloat a) => a -> ShowS
 
-	floatToDigits,    -- :: (RealFloat a) => Integer -> a -> ([Int], Int)
+  floatToDigits,    -- :: (RealFloat a) => Integer -> a -> ([Int], Int)
 
-	-- * Reading
+  -- * Reading
 
-	-- | /NB:/ 'readInt' is the \'dual\' of 'showIntAtBase',
-	-- and 'readDec' is the \`dual\' of 'showInt'.
-	-- The inconsistent naming is a historical accident.
+  -- | /NB:/ 'readInt' is the \'dual\' of 'showIntAtBase',
+  -- and 'readDec' is the \`dual\' of 'showInt'.
+  -- The inconsistent naming is a historical accident.
 
-	readSigned,       -- :: (Real a) => ReadS a -> ReadS a
+  readSigned,       -- :: (Real a) => ReadS a -> ReadS a
 
-	readInt,          -- :: (Integral a) => a -> (Char -> Bool)
-			  --         -> (Char -> Int) -> ReadS a
-	readDec,          -- :: (Integral a) => ReadS a
-	readOct,          -- :: (Integral a) => ReadS a
-	readHex,          -- :: (Integral a) => ReadS a
+  readInt,          -- :: (Integral a) => a -> (Char -> Bool)
+        --         -> (Char -> Int) -> ReadS a
+  readDec,          -- :: (Integral a) => ReadS a
+  readOct,          -- :: (Integral a) => ReadS a
+  readHex,          -- :: (Integral a) => ReadS a
 
-	readFloat,        -- :: (RealFloat a) => ReadS a
-	
-	lexDigits,        -- :: ReadS String
+  readFloat,        -- :: (RealFloat a) => ReadS a
+  
+  lexDigits,        -- :: ReadS String
 
-	-- * Miscellaneous
+  -- * Miscellaneous
 
         fromRat,          -- :: (RealFloat a) => Rational -> a
 
-	) where
+  ) where
 
 #ifdef __GLASGOW_HASKELL__
 import GHC.Base
@@ -120,15 +120,15 @@ readFloatP =
 -- | Reads a /signed/ 'Real' value, given a reader for an unsigned value.
 readSigned :: (Real a) => ReadS a -> ReadS a
 readSigned readPos = readParen False read'
-		     where read' r  = read'' r ++
-				      (do
-				        ("-",s) <- lex r
-					(x,t)   <- read'' s
-					return (-x,t))
-			   read'' r = do
-			       (str,s) <- lex r
-		      	       (n,"")  <- readPos str
-			       return (n,s)
+         where read' r  = read'' r ++
+                  (do
+                    ("-",s) <- lex r
+                    (x,t)   <- read'' s
+                    return (-x,t))
+               read'' r = do
+                  (str,s) <- lex r
+                  (n,"")  <- readPos str
+                  return (n,s)
 
 -- -----------------------------------------------------------------------------
 -- Showing
@@ -152,14 +152,14 @@ showInt n cs
 -- mutual module deps.
 
 {-# SPECIALIZE showEFloat ::
-	Maybe Int -> Float  -> ShowS,
-	Maybe Int -> Double -> ShowS #-}
+  Maybe Int -> Float  -> ShowS,
+  Maybe Int -> Double -> ShowS #-}
 {-# SPECIALIZE showFFloat ::
-	Maybe Int -> Float  -> ShowS,
-	Maybe Int -> Double -> ShowS #-}
+  Maybe Int -> Float  -> ShowS,
+  Maybe Int -> Double -> ShowS #-}
 {-# SPECIALIZE showGFloat ::
-	Maybe Int -> Float  -> ShowS,
-	Maybe Int -> Double -> ShowS #-}
+  Maybe Int -> Float  -> ShowS,
+  Maybe Int -> Double -> ShowS #-}
 
 -- | Show a signed 'RealFloat' value
 -- using scientific (exponential) notation (e.g. @2.45e2@, @1.5e-3@).
@@ -201,11 +201,11 @@ showIntAtBase base toChr n r
   | base <= 1 = error ("Numeric.showIntAtBase: applied to unsupported base " ++ show base)
   | n <  0    = error ("Numeric.showIntAtBase: applied to negative number " ++ show n)
   | otherwise = showIt (quotRem n base) r
-   where
+ where
     showIt (n,d) r = seq c $ -- stricter than necessary
       case n of
         0 -> r'
-	_ -> showIt (quotRem n base) r'
+        _ -> showIt (quotRem n base) r'
      where
       c  = toChr (fromIntegral d) 
       r' = c : r
diff --git a/packages/base/System/Cmd.hs b/packages/base/System/Cmd.hs
index 2d8635f..f83c7cb 100644
--- a/packages/base/System/Cmd.hs
+++ b/packages/base/System/Cmd.hs
@@ -79,8 +79,8 @@ system str = do
   old_quit <- installHandler sigQUIT Ignore Nothing
   (cmd,args) <- commandToProcess str
   p <- runProcessPosix "runCommand" cmd args Nothing Nothing 
-		Nothing Nothing Nothing
-		(Just defaultSignal) (Just defaultSignal)
+    Nothing Nothing Nothing
+    (Just defaultSignal) (Just defaultSignal)
   r <- waitForProcess p
   installHandler sigINT  old_int Nothing
   installHandler sigQUIT old_quit Nothing
@@ -107,8 +107,8 @@ rawSystem cmd args = do
   old_int  <- installHandler sigINT  Ignore Nothing
   old_quit <- installHandler sigQUIT Ignore Nothing
   p <- runProcessPosix "rawSystem" cmd args Nothing Nothing 
-		Nothing Nothing Nothing
-		(Just defaultSignal) (Just defaultSignal)
+    Nothing Nothing Nothing
+    (Just defaultSignal) (Just defaultSignal)
   r <- waitForProcess p
   installHandler sigINT  old_int Nothing
   installHandler sigQUIT old_quit Nothing
@@ -122,7 +122,7 @@ rawSystem cmd args = system (unwords (map translate (cmd:args)))
 translate :: String -> String
 translate str = '\'' : foldr escape "'" str
   where	escape '\'' = showString "'\\''"
-	escape c    = showChar c
+        escape c    = showChar c
 #else /* mingw32_HOST_OS &&  ! __GLASGOW_HASKELL__ */
 # if __HUGS__
 rawSystem cmd args = system (unwords (cmd : map translate args))
@@ -134,7 +134,7 @@ rawSystem cmd args = system (unwords (map translate (cmd:args)))
 translate :: String -> String
 translate str = '"' : snd (foldr escape (True,"\"") str)
   where	escape '"'  (b,     str) = (True,  '\\' : '"'  : str)
-	escape '\\' (True,  str) = (True,  '\\' : '\\' : str)
-	escape '\\' (False, str) = (False, '\\' : str)
-	escape c    (b,     str) = (False, c : str)
+        escape '\\' (True,  str) = (True,  '\\' : '\\' : str)
+        escape '\\' (False, str) = (False, '\\' : str)
+        escape c    (b,     str) = (False, c : str)
 #endif
diff --git a/packages/base/System/Directory.hs b/packages/base/System/Directory.hs
index e5e988f..4f0fd8a 100644
--- a/packages/base/System/Directory.hs
+++ b/packages/base/System/Directory.hs
@@ -337,10 +337,11 @@ removeDirectoryRecursive startLoc = do
     rm :: FilePath -> IO ()
     rm f = do temp <- try (removeFile f)
               case temp of
-                Left e  -> do isDir <- doesDirectoryExist f
-                              -- If f is not a directory, re-throw the error
-                              unless isDir $ ioError e
-                              removeDirectoryRecursive f
+                Left e  -> do 
+                    isDir <- doesDirectoryExist f
+                    -- If f is not a directory, re-throw the error
+                    unless isDir $ ioError e
+                    removeDirectoryRecursive f
                 Right _ -> return ()
 
 #if __GLASGOW_HASKELL__
@@ -643,10 +644,10 @@ long_path_size = 4096
     search :: [FilePath] -> IO (Maybe FilePath)
     search [] = return Nothing
     search (d:ds) = do
-	let path = d `joinFileName` fileName
-	b <- doesFileExist path
-	if b then return (Just path)
-             else search ds
+    	let path = d `joinFileName` fileName
+    	b <- doesFileExist path
+    	if b then return (Just path)
+                 else search ds
 #endif
 
 
diff --git a/packages/base/System/IO/Error.hs b/packages/base/System/IO/Error.hs
index 95fde85..9b897dc 100644
--- a/packages/base/System/IO/Error.hs
+++ b/packages/base/System/IO/Error.hs
@@ -23,10 +23,10 @@ module System.IO.Error (
 
 #ifndef __NHC__
     mkIOError,			-- :: IOErrorType -> String -> Maybe Handle
-				--    -> Maybe FilePath -> IOError
+                --    -> Maybe FilePath -> IOError
 
     annotateIOError,		-- :: IOError -> String -> Maybe Handle
-				--    -> Maybe FilePath -> IOError
+                --    -> Maybe FilePath -> IOError
 #endif
 
     -- ** Classifying I\/O errors
@@ -132,8 +132,7 @@ import IO
 
 #ifndef __NHC__
 try            :: IO a -> IO (Either IOError a)
-try f          =  catch (do r <- f
-                            return (Right r))
+try f          =  catch (do r <- f; return (Right r))
                         (return . Left)
 #endif
 
@@ -148,11 +147,11 @@ try f          =  catch (do r <- f
 mkIOError :: IOErrorType -> String -> Maybe Handle -> Maybe FilePath -> IOError
 mkIOError t location maybe_hdl maybe_filename =
                IOError{ ioe_type = t, 
-			ioe_location = location,
-	   		ioe_description = "",
-			ioe_handle = maybe_hdl, 
-			ioe_filename = maybe_filename
- 			}
+                ioe_location = location,
+                ioe_description = "",
+                ioe_handle = maybe_hdl, 
+                ioe_filename = maybe_filename
+             }
 #ifdef __NHC__
 mkIOError EOF       location maybe_hdl maybe_filename =
     EOFError location (fromJust maybe_hdl)
@@ -226,8 +225,8 @@ isUserError          = isUserErrorType             . ioeGetErrorType
 
 #ifdef __NHC__
 data IOErrorType = AlreadyExists | NoSuchThing | ResourceBusy
-		 | ResourceExhausted | EOF | IllegalOperation
-		 | PermissionDenied | UserError
+         | ResourceExhausted | EOF | IllegalOperation
+         | PermissionDenied | UserError
 #endif
 
 -- | I\/O error where the operation failed because one of its arguments
diff --git a/packages/base/System/Posix/Internals.hs b/packages/base/System/Posix/Internals.hs
index 711a880..f7417c8 100644
--- a/packages/base/System/Posix/Internals.hs
+++ b/packages/base/System/Posix/Internals.hs
@@ -76,16 +76,16 @@ fdFileSize :: Int -> IO Integer
 fdFileSize fd = 
   allocaBytes sizeof_stat $ \ p_stat -> do
     throwErrnoIfMinus1Retry "fileSize" $
-	c_fstat (fromIntegral fd) p_stat
+      c_fstat (fromIntegral fd) p_stat
     c_mode <- st_mode p_stat :: IO CMode 
     if not (s_isreg c_mode)
-	then return (-1)
-	else do
-    c_size <- st_size p_stat :: IO COff
-    return (fromIntegral c_size)
+    then return (-1)
+    else do
+     c_size <- st_size p_stat :: IO COff
+     return (fromIntegral c_size)
 
 data FDType  = Directory | Stream | RegularFile | RawDevice
-	       deriving (Eq)
+          deriving (Eq)
 
 fileType :: FilePath -> IO FDType
 fileType file =
@@ -101,7 +101,7 @@ fdType :: Int -> IO FDType
 fdType fd = 
   allocaBytes sizeof_stat $ \ p_stat -> do
     throwErrnoIfMinus1Retry "fdType" $
-	c_fstat (fromIntegral fd) p_stat
+      c_fstat (fromIntegral fd) p_stat
     statGetType p_stat
 
 statGetType p_stat = do
@@ -109,15 +109,15 @@ statGetType p_stat = do
   case () of
       _ | s_isdir c_mode    	-> return Directory
         | s_isfifo c_mode || s_issock c_mode || s_ischr  c_mode
-			  	-> return Stream
-	| s_isreg c_mode	-> return RegularFile
-	 -- Q: map char devices to RawDevice too?
-	| s_isblk c_mode        -> return RawDevice
-	| otherwise		-> ioError ioe_unknownfiletype
+              -> return Stream
+        | s_isreg c_mode	-> return RegularFile
+         -- Q: map char devices to RawDevice too?
+        | s_isblk c_mode        -> return RawDevice
+        | otherwise		-> ioError ioe_unknownfiletype
     
 
 ioe_unknownfiletype = IOError Nothing UnsupportedOperation "fdType"
-			"unknown file type" Nothing
+         "unknown file type" Nothing
 
 #if __GLASGOW_HASKELL__ && (defined(mingw32_HOST_OS) || defined(__MINGW32__))
 closeFd :: Bool -> CInt -> IO CInt
@@ -139,7 +139,7 @@ fdGetMode fd = do
                 (c__setmode (fromIntegral fd) (fromIntegral flags1))
 #else
     flags <- throwErrnoIfMinus1Retry "fdGetMode" 
-		(c_fcntl_read (fromIntegral fd) const_f_getfl)
+     (c_fcntl_read (fromIntegral fd) const_f_getfl)
 #endif
     let
        wH  = (flags .&. o_WRONLY) /= 0
@@ -147,11 +147,11 @@ fdGetMode fd = do
        rwH = (flags .&. o_RDWR) /= 0
 
        mode
-	 | wH && aH  = AppendMode
-	 | wH        = WriteMode
-	 | rwH       = ReadWriteMode
-	 | otherwise = ReadMode
-	  
+        | wH && aH  = AppendMode
+        | wH        = WriteMode
+        | rwH       = ReadWriteMode
+        | otherwise = ReadMode
+     
     return mode
 
 -- ---------------------------------------------------------------------------
@@ -167,8 +167,8 @@ setEcho fd on = do
   tcSetAttr fd $ \ p_tios -> do
     c_lflag <- c_lflag p_tios :: IO CTcflag
     let new_c_lflag
-	 | on        = c_lflag .|. fromIntegral const_echo
-	 | otherwise = c_lflag .&. complement (fromIntegral const_echo)
+         | on        = c_lflag .|. fromIntegral const_echo
+         | otherwise = c_lflag .&. complement (fromIntegral const_echo)
     poke_c_lflag p_tios (new_c_lflag :: CTcflag)
 
 getEcho :: Int -> IO Bool
@@ -184,49 +184,47 @@ setCooked fd cooked =
     -- turn on/off ICANON
     c_lflag <- c_lflag p_tios :: IO CTcflag
     let new_c_lflag | cooked    = c_lflag .|. (fromIntegral const_icanon)
-	            | otherwise = c_lflag .&. complement (fromIntegral const_icanon)
+                    | otherwise = c_lflag .&. complement (fromIntegral const_icanon)
     poke_c_lflag p_tios (new_c_lflag :: CTcflag)
 
     -- set VMIN & VTIME to 1/0 respectively
     when (not cooked) $ do
-            c_cc <- ptr_c_cc p_tios
-	    let vmin  = (c_cc `plusPtr` (fromIntegral const_vmin))  :: Ptr Word8
-		vtime = (c_cc `plusPtr` (fromIntegral const_vtime)) :: Ptr Word8
-	    poke vmin  1
-	    poke vtime 0
+       c_cc <- ptr_c_cc p_tios
+       let vmin  = (c_cc `plusPtr` (fromIntegral const_vmin))  :: Ptr Word8
+           vtime = (c_cc `plusPtr` (fromIntegral const_vtime)) :: Ptr Word8
+       poke vmin  1
+       poke vtime 0
 
 tcSetAttr :: FD -> (Ptr CTermios -> IO a) -> IO a
 tcSetAttr fd fun = do
      allocaBytes sizeof_termios  $ \p_tios -> do
-	throwErrnoIfMinus1Retry "tcSetAttr"
-	   (c_tcgetattr (fromIntegral fd) p_tios)
+      throwErrnoIfMinus1Retry "tcSetAttr" (c_tcgetattr (fromIntegral fd) p_tios)
 
 #ifdef __GLASGOW_HASKELL__
-	-- Save a copy of termios, if this is a standard file descriptor.
-	-- These terminal settings are restored in hs_exit().
-	when (fd <= 2) $ do
-	  p <- get_saved_termios fd
-	  when (p == nullPtr) $ do
-	     saved_tios <- mallocBytes sizeof_termios
-	     copyBytes saved_tios p_tios sizeof_termios
-	     set_saved_termios fd saved_tios
+      -- Save a copy of termios, if this is a standard file descriptor.
+      -- These terminal settings are restored in hs_exit().
+      when (fd <= 2) $ do
+        p <- get_saved_termios fd
+        when (p == nullPtr) $ do
+           saved_tios <- mallocBytes sizeof_termios
+           copyBytes saved_tios p_tios sizeof_termios
+           set_saved_termios fd saved_tios
 #endif
 
-	-- tcsetattr() when invoked by a background process causes the process
-	-- to be sent SIGTTOU regardless of whether the process has TOSTOP set
-	-- in its terminal flags (try it...).  This function provides a
-	-- wrapper which temporarily blocks SIGTTOU around the call, making it
-	-- transparent.
-	allocaBytes sizeof_sigset_t $ \ p_sigset -> do
-	allocaBytes sizeof_sigset_t $ \ p_old_sigset -> do
-	     c_sigemptyset p_sigset
-	     c_sigaddset   p_sigset const_sigttou
-	     c_sigprocmask const_sig_block p_sigset p_old_sigset
-	     r <- fun p_tios  -- do the business
-	     throwErrnoIfMinus1Retry_ "tcSetAttr" $
-		 c_tcsetattr (fromIntegral fd) const_tcsanow p_tios
-	     c_sigprocmask const_sig_setmask p_old_sigset nullPtr
-	     return r
+      -- tcsetattr() when invoked by a background process causes the process
+      -- to be sent SIGTTOU regardless of whether the process has TOSTOP set
+      -- in its terminal flags (try it...).  This function provides a
+      -- wrapper which temporarily blocks SIGTTOU around the call, making it
+      -- transparent.
+      allocaBytes sizeof_sigset_t $ \ p_sigset -> do
+        allocaBytes sizeof_sigset_t $ \ p_old_sigset -> do
+             c_sigemptyset p_sigset
+             c_sigaddset   p_sigset const_sigttou
+             c_sigprocmask const_sig_block p_sigset p_old_sigset
+             r <- fun p_tios  -- do the business
+             throwErrnoIfMinus1Retry_ "tcSetAttr" $ c_tcsetattr (fromIntegral fd) const_tcsanow p_tios
+             c_sigprocmask const_sig_setmask p_old_sigset nullPtr
+             return r
 
 #ifdef __GLASGOW_HASKELL__
 foreign import ccall unsafe "HsBase.h __hscore_get_saved_termios"
@@ -289,8 +287,8 @@ foreign import ccall unsafe "consUtils.h get_console_echo__"
 #if !defined(mingw32_HOST_OS) && !defined(__MINGW32__)
 
 setNonBlockingFD fd = do
-  flags <- throwErrnoIfMinus1Retry "setNonBlockingFD"
-		 (c_fcntl_read (fromIntegral fd) const_f_getfl)
+  flags <- throwErrnoIfMinus1Retry "setNonBlockingFD" 
+    (c_fcntl_read (fromIntegral fd) const_f_getfl)
   -- An error when setting O_NONBLOCK isn't fatal: on some systems 
   -- there are certain file handles on which this will fail (eg. /dev/null
   -- on FreeBSD) so we throw away the return code from fcntl_write.
@@ -360,7 +358,7 @@ foreign import ccall unsafe "HsBase.h read"
 
 foreign import ccall unsafe "dirUtils.h __hscore_renameFile"
    c_rename :: CString -> CString -> IO CInt
-		     
+           
 foreign import ccall unsafe "HsBase.h rewinddir"
    c_rewinddir :: Ptr CDir -> IO ()
 
diff --git a/packages/base/System/Time.hsc b/packages/base/System/Time.hsc
index f230e97..92338c8 100644
--- a/packages/base/System/Time.hsc
+++ b/packages/base/System/Time.hsc
@@ -66,15 +66,15 @@ TODO:
 
 module System.Time
      (
-	-- * Clock times
+  -- * Clock times
 
         ClockTime(..) -- non-standard, lib. report gives this as abstract
-	-- instance Eq, Ord
-	-- instance Show (non-standard)
+  -- instance Eq, Ord
+  -- instance Show (non-standard)
 
      ,	getClockTime
 
-	-- * Time differences
+  -- * Time differences
 
      ,  TimeDiff(..)
      ,  noTimeDiff      -- non-standard (but useful when constructing TimeDiff vals.)
@@ -85,7 +85,7 @@ module System.Time
      ,  timeDiffToString  -- non-standard
      ,  formatTimeDiff    -- non-standard
 
-	-- * Calendar times
+  -- * Calendar times
 
      ,  CalendarTime(..)
      ,  Month(..)
@@ -147,12 +147,12 @@ data Day
 -- external calendar time 'CalendarTime' for I\/O or other manipulations.
 
 data ClockTime = TOD Integer Integer
-		-- ^ Construct a clock time.  The arguments are a number
-		-- of seconds since 00:00:00 (UTC) on 1 January 1970,
-		-- and an additional number of picoseconds.
-		--
-		-- In Haskell 98, the 'ClockTime' type is abstract.
-	       deriving (Eq, Ord)
+    -- ^ Construct a clock time.  The arguments are a number
+    -- of seconds since 00:00:00 (UTC) on 1 January 1970,
+    -- and an additional number of picoseconds.
+    --
+    -- In Haskell 98, the 'ClockTime' type is abstract.
+         deriving (Eq, Ord)
 
 -- When a ClockTime is shown, it is converted to a CalendarTime in the current
 -- timezone and then printed.  FIXME: This is arguably wrong, since we can't
@@ -160,7 +160,7 @@ data ClockTime = TOD Integer Integer
 
 instance Show ClockTime where
     showsPrec _ t = showString (calendarTimeToString 
-	  			 (unsafePerformIO (toCalendarTime t)))
+           (unsafePerformIO (toCalendarTime t)))
 
 {-
 The numeric fields have the following ranges.
@@ -191,15 +191,15 @@ data CalendarTime
      , ctHour    :: Int		-- ^ Hour of the day (0 to 23)
      , ctMin     :: Int		-- ^ Minutes (0 to 59)
      , ctSec     :: Int		-- ^ Seconds (0 to 61, allowing for up to
-				-- two leap seconds)
+        -- two leap seconds)
      , ctPicosec :: Integer	-- ^ Picoseconds
      , ctWDay    :: Day		-- ^ Day of the week
      , ctYDay    :: Int		-- ^ Day of the year
-				-- (0 to 364, or 365 in leap years)
+        -- (0 to 364, or 365 in leap years)
      , ctTZName  :: String	-- ^ Name of the time zone
      , ctTZ      :: Int		-- ^ Variation from UTC in seconds
      , ctIsDST   :: Bool	-- ^ 'True' if Daylight Savings Time would
-				-- be in effect, and 'False' otherwise
+        -- be in effect, and 'False' otherwise
  }
  deriving (Eq,Ord,Read,Show)
 
@@ -264,27 +264,27 @@ getClockTime = do
 
 addToClockTime  :: TimeDiff  -> ClockTime -> ClockTime
 addToClockTime (TimeDiff year mon day hour min sec psec) 
-	       (TOD c_sec c_psec) = 
-	let
-	  sec_diff = toInteger sec +
+         (TOD c_sec c_psec) = 
+  let
+    sec_diff = toInteger sec +
                      60 * toInteger min +
                      3600 * toInteger hour +
                      24 * 3600 * toInteger day
-          (d_sec, d_psec) = (c_psec + psec) `quotRem` 1000000000000
-          cal      = toUTCTime (TOD (c_sec + sec_diff + d_sec) d_psec)
-          new_mon  = fromEnum (ctMonth cal) + r_mon 
-	  month' = fst tmp
-	  yr_diff = snd tmp
-          tmp
-	    | new_mon < 0  = (toEnum (12 + new_mon), (-1))
-	    | new_mon > 11 = (toEnum (new_mon `mod` 12), 1)
-	    | otherwise    = (toEnum new_mon, 0)
-	    
-	  (r_yr, r_mon) = mon `quotRem` 12
-
-          year' = ctYear cal + year + r_yr + yr_diff
-	in
-	toClockTime cal{ctMonth=month', ctYear=year'}
+    (d_sec, d_psec) = (c_psec + psec) `quotRem` 1000000000000
+    cal      = toUTCTime (TOD (c_sec + sec_diff + d_sec) d_psec)
+    new_mon  = fromEnum (ctMonth cal) + r_mon 
+    month' = fst tmp
+    yr_diff = snd tmp
+    tmp
+      | new_mon < 0  = (toEnum (12 + new_mon), (-1))
+      | new_mon > 11 = (toEnum (new_mon `mod` 12), 1)
+      | otherwise    = (toEnum new_mon, 0)
+      
+    (r_yr, r_mon) = mon `quotRem` 12
+
+    year' = ctYear cal + year + r_yr + yr_diff
+  in
+  toClockTime cal{ctMonth=month', ctYear=year'}
 
 -- | @'diffClockTimes' t1 t2@ returns the difference between two clock
 -- times @t1@ and @t2@ as a 'TimeDiff'.
@@ -436,20 +436,20 @@ toCalTime toUTC (TOD s psecs)
            "clock secs out of range")
   | otherwise = do
     (sec,min,hour,mday,mon,year,wday,yday,isdst,zone,off) <- 
-  		toCalTimePrim (if toUTC then 1 else 0) (fromIntegral s)
+      toCalTimePrim (if toUTC then 1 else 0) (fromIntegral s)
     return (CalendarTime{ ctYear=1900+year
-  		        , ctMonth=toEnum mon
-		        , ctDay=mday
-		        , ctHour=hour
-		        , ctMin=min
-		        , ctSec=sec
-		        , ctPicosec=psecs
-		        , ctWDay=toEnum wday
-		        , ctYDay=yday
-		        , ctTZName=(if toUTC then "UTC" else zone)
-		        , ctTZ=(if toUTC then 0 else off)
-		        , ctIsDST=not toUTC && (isdst/=0)
-		        })
+              , ctMonth=toEnum mon
+            , ctDay=mday
+            , ctHour=hour
+            , ctMin=min
+            , ctSec=sec
+            , ctPicosec=psecs
+            , ctWDay=toEnum wday
+            , ctYDay=yday
+            , ctTZName=(if toUTC then "UTC" else zone)
+            , ctTZ=(if toUTC then 0 else off)
+            , ctIsDST=not toUTC && (isdst/=0)
+            })
 #else /* ! __HUGS__ */
 throwAwayReturnPointer :: (Ptr CTime -> Ptr CTm -> IO (Ptr CTm))
                        -> (Ptr CTime -> Ptr CTm -> IO (       ))
@@ -457,7 +457,7 @@ throwAwayReturnPointer fun x y = fun x y >> return ()
 
 #if !HAVE_LOCALTIME_R || !HAVE_GMTIME_R
 clockToCalendarTime_static :: (Ptr CTime -> IO (Ptr CTm)) -> Bool -> ClockTime
-	 -> IO CalendarTime
+   -> IO CalendarTime
 clockToCalendarTime_static fun is_utc (TOD secs psec) = do
   with (fromIntegral secs :: CTime)  $ \ p_timer -> do
     p_tm <- fun p_timer 	-- can't fail, according to POSIX
@@ -466,7 +466,7 @@ clockToCalendarTime_static fun is_utc (TOD secs psec) = do
 
 #if HAVE_LOCALTIME_R || HAVE_GMTIME_R
 clockToCalendarTime_reentrant :: (Ptr CTime -> Ptr CTm -> IO ()) -> Bool -> ClockTime
-	 -> IO CalendarTime
+   -> IO CalendarTime
 clockToCalendarTime_reentrant fun is_utc (TOD secs psec) = do
   with (fromIntegral secs :: CTime)  $ \ p_timer -> do
     allocaBytes (#const sizeof(struct tm)) $ \ p_tm -> do
@@ -491,21 +491,21 @@ clockToCalendarTime_aux is_utc p_tm psec = do
     tzname <- peekCString zone
     
     let month  | mon >= 0 && mon <= 11 = toEnum (fromIntegral mon)
-    	       | otherwise             = error ("toCalendarTime: illegal month value: " ++ show mon)
+             | otherwise             = error ("toCalendarTime: illegal month value: " ++ show mon)
     
     return (CalendarTime 
-		(1900 + fromIntegral year) 
-		month
-		(fromIntegral mday)
-		(fromIntegral hour)
-		(fromIntegral min)
-		(fromIntegral sec)
-		psec
-            	(toEnum (fromIntegral wday))
-		(fromIntegral yday)
-		(if is_utc then "UTC" else tzname)
-		(if is_utc then 0     else fromIntegral tz)
-		(if is_utc then False else isdst /= 0))
+    (1900 + fromIntegral year) 
+    month
+    (fromIntegral mday)
+    (fromIntegral hour)
+    (fromIntegral min)
+    (fromIntegral sec)
+    psec
+              (toEnum (fromIntegral wday))
+    (fromIntegral yday)
+    (if is_utc then "UTC" else tzname)
+    (if is_utc then 0     else fromIntegral tz)
+    (if is_utc then False else isdst /= 0))
 #endif /* ! __HUGS__ */
 
 -- | converts a 'CalendarTime' into the corresponding internal
@@ -515,13 +515,13 @@ clockToCalendarTime_aux is_utc p_tm psec = do
 toClockTime :: CalendarTime -> ClockTime
 #ifdef __HUGS__
 toClockTime (CalendarTime yr mon mday hour min sec psec
-			  _wday _yday _tzname tz _isdst) =
+        _wday _yday _tzname tz _isdst) =
   unsafePerformIO $ do
     s <- toClockTimePrim (yr-1900) (fromEnum mon) mday hour min sec tz
     return (TOD (fromIntegral s) psec)
 #else /* ! __HUGS__ */
 toClockTime (CalendarTime year mon mday hour min sec psec 
-			  _wday _yday _tzname tz isdst) =
+        _wday _yday _tzname tz isdst) =
 
      -- `isDst' causes the date to be wrong by one hour...
      -- FIXME: check, whether this works on other arch's than Linux, too...
@@ -544,8 +544,8 @@ toClockTime (CalendarTime year mon mday hour min sec psec
         (#poke struct tm,tm_mon  ) p_tm	(fromIntegral (fromEnum mon) :: CInt)
         (#poke struct tm,tm_year ) p_tm	(fromIntegral year - 1900 :: CInt)
         (#poke struct tm,tm_isdst) p_tm	isDst
-	t <- throwIf (== -1) (\_ -> "Time.toClockTime: invalid input")
-		(mktime p_tm)
+  t <- throwIf (== -1) (\_ -> "Time.toClockTime: invalid input")
+    (mktime p_tm)
         -- 
         -- mktime expects its argument to be in the local timezone, but
         -- toUTCTime makes UTC-encoded CalendarTime's ...
@@ -560,8 +560,8 @@ toClockTime (CalendarTime year mon mday hour min sec psec
         -- 
         gmtoff <- gmtoff p_tm
         let realToInteger = round . realToFrac :: Real a => a -> Integer
-	    res = realToInteger t - fromIntegral tz + fromIntegral gmtoff
-	return (TOD res psec)
+      res = realToInteger t - fromIntegral tz + fromIntegral gmtoff
+  return (TOD res psec)
 #endif /* ! __HUGS__ */
 
 -- -----------------------------------------------------------------------------
diff --git a/packages/base/configure b/packages/base/configure
index 13598f4..c3782f9 100755
--- a/packages/base/configure
+++ b/packages/base/configure
@@ -7149,8 +7149,8 @@ else
 echo "${ECHO_T}not supported" >&6; }
 fi
 
-{ echo "$as_me:$LINENO: checking Haskell type for int" >&5
-echo $ECHO_N "checking Haskell type for int... $ECHO_C" >&6; }
+{ echo "$as_me:$LINENO: checking Haskell type for int (HTYPE_INT)" >&5
+echo $ECHO_N "checking Haskell type for int (HTYPE_INT)... $ECHO_C" >&6; }
 if test "${fptools_cv_htype_int+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -7289,7 +7289,7 @@ fi
 CPPFLAGS="$fp_check_htype_save_cppflags"
 fi
  if test "$fptools_cv_htype_sup_int" = yes; then
-  { echo "$as_me:$LINENO: result: $fptools_cv_htype_int" >&5
+  { echo "$as_me:$LINENO: result: HTYPE_INT: $fptools_cv_htype_int" >&5
 echo "${ECHO_T}$fptools_cv_htype_int" >&6; }
 
 cat >>confdefs.h <<_ACEOF
@@ -7297,7 +7297,7 @@ cat >>confdefs.h <<_ACEOF
 _ACEOF
 
 else
-  { echo "$as_me:$LINENO: result: not supported" >&5
+  { echo "$as_me:$LINENO: result: HTYPE_INT: not supported" >&5
 echo "${ECHO_T}not supported" >&6; }
 fi
 
diff --git a/src/Makefile.in b/src/Makefile.in
index b2b3aba..1c621a0 100644
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -91,7 +91,7 @@ all		:: hugs$(EXEEXT) runhugs$(EXEEXT) ffihugs$(EXEEXT)
 
 hugs$(EXEEXT)	: $(IOBJECTS) $(WOBJECTS) $(RC_FILES)
 		  $(CC) $(LDFLAGS) $(IOBJECTS) $(WOBJECTS) $(LIBS) -o hugs$(EXEEXT) 
-		  $(STRIP)
+		  $(STRIP) hugs$(EXEEXT) 
 
 version.$(OBJEXT) : version.c $(SOURCES)
 		  @$(CC) \
diff --git a/src/machdep.c b/src/machdep.c
index 3cb32c6..a1a3d0d 100644
--- a/src/machdep.c
+++ b/src/machdep.c
@@ -2383,9 +2383,9 @@ String flags; {
         insert(flags);
     }
 
-#if 0
+// #if 0
     printf("Executing '%s'\n",buffer);
-#endif
+// #endif
     if (shellEsc(buffer,TRUE,TRUE) != 0) {
         ERRMSG(0) "Error while running compilation command '%s'", buffer
         EEND;
